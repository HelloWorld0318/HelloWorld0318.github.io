<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挥斥方遒</title>
  
  <subtitle>CODING MY AMBITION</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-23T10:43:42.246Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>挥斥方遒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="http://yoursite.com/2020/02/17/big_data/zookeeper/"/>
    <id>http://yoursite.com/2020/02/17/big_data/zookeeper/</id>
    <published>2020-02-17T15:19:26.000Z</published>
    <updated>2020-02-23T10:43:42.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ZooKeeper概述"><a href="#ZooKeeper概述" class="headerlink" title="ZooKeeper概述"></a>ZooKeeper概述</h3><blockquote><p>ZooKeeper是一个开源的分布式的，为分布式应用<strong>提供协调服务</strong>的Apache项目。</p></blockquote><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>从设计模式的角度来理解，ZooKeeper是基于观察者模式设计的分布式服务管理框架，它<strong>负责存储和管理大家都关心的数据</strong>，然后<strong>接受观察者的注册</strong>，一旦这些数据的状态发生变化，ZooKeeper就将<strong>负责通知已经在ZooKeeper上注册的那些观察者</strong>做出相应的反应，从而实现集群中类似Master/Slave管理模式。<br><img src="/img/zookeeper/zooker工作机制.jpg" alt><br>ZooKeeper = 文件系统 + 通知机制</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><img src="/img/zookeeper/zookeep特点.bmp" alt></p><ul><li>ZooKeeper一个领导者（Leader），多个跟随者（Follower）组成的集群</li><li>集群中之只要有半数以上节点存活，ZooKeeper集群就能正常服务</li><li>全局数据一致性：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</li><li>更新请求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行</li><li>实时性，在一定时间范围内，Client能读到最新数据。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一颗树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。<br><img src="/img/zookeeper/zookeeper数据结构.png" alt></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>提供的服务包括：统一命名服务，统一配置管理，统一集群管理，服务器节点动态上下线，软负载均衡等。</p><h5 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h5><p>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如：IP不容易记住，而域名容易记住。</p><h5 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h5><p>1.分布式环境下，配置文件同步非常常见。</p><ul><li>一般要求一个集群中，所有节点的配置信息是一致的，比如Kafka集群，</li><li>对配置文件修改后，希望能够快速同步到各个节点上。</li></ul><p>2.配置管理可交由ZooKeeper实现。</p><ul><li>可将配置信息写入ZooKeeper上的一个ZNode</li><li>各个客户端服务器监听这个ZNode</li><li>一旦ZNode中的数据被修改，ZooKeeper将通知各个客户端服务器。</li></ul><h5 id="统一集群管理"><a href="#统一集群管理" class="headerlink" title="统一集群管理"></a>统一集群管理</h5><p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。<br>ZooKeeper可以实现实时监控节点状态变化</p><ul><li>可将节点信息写入ZooKeeper上的一个ZNode。</li><li>监听这个ZNode可获取它的实时状态变化。</li></ul><h5 id="服务器动态上下线"><a href="#服务器动态上下线" class="headerlink" title="服务器动态上下线"></a>服务器动态上下线</h5><p>客户端能实时洞察到服务器上下线的变化。</p><h5 id="软负载均衡"><a href="#软负载均衡" class="headerlink" title="软负载均衡"></a>软负载均衡</h5><p>在ZooKeeper中记录每台服务器的访问数，让访问最少的服务器去处理最新的客户端请求。</p><h3 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h3><h4 id="本地模式安装部署"><a href="#本地模式安装部署" class="headerlink" title="本地模式安装部署"></a>本地模式安装部署</h4><h4 id="分布式安装部署"><a href="#分布式安装部署" class="headerlink" title="分布式安装部署"></a>分布式安装部署</h4><h3 id="ZooKeeper内部原理"><a href="#ZooKeeper内部原理" class="headerlink" title="ZooKeeper内部原理"></a>ZooKeeper内部原理</h3><p>ZooKeeper的选举机制 重点学习</p><h3 id="ZooKeeper实战"><a href="#ZooKeeper实战" class="headerlink" title="ZooKeeper实战"></a>ZooKeeper实战</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ZooKeeper概述&quot;&gt;&lt;a href=&quot;#ZooKeeper概述&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper概述&quot;&gt;&lt;/a&gt;ZooKeeper概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ZooKeeper是一个开源的分布式的，为
      
    
    </summary>
    
      <category term="大数据技术学习" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>第一部分：线性表</title>
    <link href="http://yoursite.com/2020/01/28/leetcode/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/01/28/leetcode/第一部分-线性表/</id>
    <published>2020-01-28T14:50:57.000Z</published>
    <updated>2020-02-27T12:58:19.894Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章 广告的基本知识</title>
    <link href="http://yoursite.com/2020/01/17/ad/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B9%BF%E5%91%8A%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/01/17/ad/第一章-广告的基本知识/</id>
    <published>2020-01-17T09:03:49.000Z</published>
    <updated>2020-01-17T09:10:18.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="广告的目的"><a href="#广告的目的" class="headerlink" title="广告的目的"></a>广告的目的</h3><h3 id="广告的有效性模型"><a href="#广告的有效性模型" class="headerlink" title="广告的有效性模型"></a>广告的有效性模型</h3><h3 id="广告与营销的区别"><a href="#广告与营销的区别" class="headerlink" title="广告与营销的区别"></a>广告与营销的区别</h3><h3 id="在线广告的特点"><a href="#在线广告的特点" class="headerlink" title="在线广告的特点"></a>在线广告的特点</h3><h3 id="在线广告的市场"><a href="#在线广告的市场" class="headerlink" title="在线广告的市场"></a>在线广告的市场</h3><h3 id="计算广告核心问题和挑战"><a href="#计算广告核心问题和挑战" class="headerlink" title="计算广告核心问题和挑战"></a>计算广告核心问题和挑战</h3><h3 id="广告，搜索，推荐的区别"><a href="#广告，搜索，推荐的区别" class="headerlink" title="广告，搜索，推荐的区别"></a>广告，搜索，推荐的区别</h3><h3 id="投资回报（ROI）分析"><a href="#投资回报（ROI）分析" class="headerlink" title="投资回报（ROI）分析"></a>投资回报（ROI）分析</h3><h3 id="在线广告系统结构"><a href="#在线广告系统结构" class="headerlink" title="在线广告系统结构"></a>在线广告系统结构</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;广告的目的&quot;&gt;&lt;a href=&quot;#广告的目的&quot; class=&quot;headerlink&quot; title=&quot;广告的目的&quot;&gt;&lt;/a&gt;广告的目的&lt;/h3&gt;&lt;h3 id=&quot;广告的有效性模型&quot;&gt;&lt;a href=&quot;#广告的有效性模型&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="计算广告" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>Scala简介</title>
    <link href="http://yoursite.com/2019/12/23/scala/1Scala%20%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/12/23/scala/1Scala 简介及开发环境配置/</id>
    <published>2019-12-23T06:11:53.000Z</published>
    <updated>2019-12-24T06:56:43.349Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>Scala</strong>(Scalable language)是一门现代的多范式编程语言，是开发高扩展性、以数据为中心的应用程序的理想语言，其设计初衷是要集成面向对象编程和函数式编程的各种特性。Scala是一门综合了<strong>面向对象</strong>和<strong>函数式编程概念</strong>的<strong>静态类型</strong>的编程语言，它运行在标准的JVM平台上，可以与所有的Java类库无缝协作。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote></blockquote><p>1.Scala是面向对象的<br>Scala是一种面向对象的语言，每个值都是对象，每个方法都是调用。举例来说，如果你执行<code>1+2</code>，则对应Scala而言，实际是在调用Int类定义的名为<code>+</code>的方法。<br><br><br>2.Scala是函数式的<br>Scala不只是一门纯的面向对象的语言，它也是功能完整的函数式编程语言。函数式编程以两个核心理念为指导：</p><ul><li>函数是一等公民；</li><li>程序中的操作应该讲输入值映射为输出值，而不是当场修改数据。即方法不应该有副作用。</li></ul><p>Scala 是编写可扩展、分布式、基于组件且支持并发和分布 的应用程序的最完美语言。</p><h3 id="Scala：在适合的领域做王者就够了"><a href="#Scala：在适合的领域做王者就够了" class="headerlink" title="Scala：在适合的领域做王者就够了"></a>Scala：在适合的领域做王者就够了</h3><p>今日头条的王石冲表示，其实多年Scala使用下来，我们大可放弃把Scala推向主流的这个想法。而应该认清和接受Scala的定位：在大公司内部，它用于开发某个核心组件或基础设置，由少数人参与并把控质量；在新兴的特定垂直领域的小公司，利用Scala的优点与其生态提供的工具，打造解决特定问题的工具和服务，这可能才是Scala最好的归宿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
  </entry>
  
  <entry>
    <title>第八部分：搜索</title>
    <link href="http://yoursite.com/2019/12/08/leetcode/%E7%AC%AC%E5%85%AB%E9%83%A8%E5%88%86-%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/12/08/leetcode/第八部分-搜索/</id>
    <published>2019-12-08T11:13:55.000Z</published>
    <updated>2019-12-23T06:25:15.187Z</updated>
    
    <content type="html"><![CDATA[<p>当题目看不出任何规律，既不能用分治，贪心，也不能用动态规划时，这时候万能方法——搜索，就派上用场了。搜索分为广搜和深搜，广搜里面又用普通广搜，双向广搜，A*搜索等。神搜里面又用普通深搜，回溯法等。</p><p>广搜和深搜非常类似（除了在扩展节点这部分不一样），二者有相同的框架，如何表示状态？如何扩展状态？如何判重？尤其是判重，解决了这个问题，基本上整个问题就解决了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当题目看不出任何规律，既不能用分治，贪心，也不能用动态规划时，这时候万能方法——搜索，就派上用场了。搜索分为广搜和深搜，广搜里面又用普通广搜，双向广搜，A*搜索等。神搜里面又用普通深搜，回溯法等。&lt;/p&gt;
&lt;p&gt;广搜和深搜非常类似（除了在扩展节点这部分不一样），二者有相同的
      
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>python基础知识</title>
    <link href="http://yoursite.com/2019/11/24/python/python/"/>
    <id>http://yoursite.com/2019/11/24/python/python/</id>
    <published>2019-11-23T16:00:00.000Z</published>
    <updated>2019-11-24T03:03:55.054Z</updated>
    
    <content type="html"><![CDATA[<p><strong>init</strong>.py的作用就是让一个呈结构化分布（已文件夹形式组织）的代码文件夹变成可以被导入import的软件包。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;init&lt;/strong&gt;.py的作用就是让一个呈结构化分布（已文件夹形式组织）的代码文件夹变成可以被导入import的软件包。&lt;/p&gt;

      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>第九部分-动态规划</title>
    <link href="http://yoursite.com/2019/10/27/leetcode/%E7%AC%AC%E4%B9%9D%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2019/10/27/leetcode/第九部分-动态规划/</id>
    <published>2019-10-27T08:00:56.000Z</published>
    <updated>2019-12-23T06:25:19.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>动态规划</strong>（Dynamic programming，在这里，programming是指一种表格法，并非编写计算机程序）是<strong>运筹学</strong>的一个分支，是求解<strong>决策过程最优化</strong>的数学方法。它是20世纪50年代初美国数学家R.E.Bellman等人提出的<strong>最优化原理</strong>，它利用各阶段之间的关系，逐个求解，最终求的<strong>全局最优解</strong>。在设计动态规划算法时，需要确认<strong>原问题与子问题、动态规划状态、边界状态估值、状态转移方程</strong>等关键要素。<br>在算法面试中，动态规划是<strong>最常考察</strong>的题型之一，大多数面试官都已<strong>能否较好的解决动态规划</strong>相关问题来区分候选人<strong>是否“聪明”</strong>。<br>通常按如下的4个步骤来设计一个动态规划的算法：<br>1.确认原问题和子问题（问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解）。<br>2.确认状态。<br>3.确认边界状态的值。<br>4.确定状态转移方程。</p><h3 id="例题解答"><a href="#例题解答" class="headerlink" title="例题解答"></a>例题解答</h3><h4 id="算法导论例题1-钢条切割问题的分析与实现"><a href="#算法导论例题1-钢条切割问题的分析与实现" class="headerlink" title="算法导论例题1 钢条切割问题的分析与实现"></a>算法导论例题1 钢条切割问题的分析与实现</h4><h4 id="算法导论例题2-矩阵链相乘的问题"><a href="#算法导论例题2-矩阵链相乘的问题" class="headerlink" title="算法导论例题2 矩阵链相乘的问题"></a>算法导论例题2 矩阵链相乘的问题</h4><h4 id="算法导论例题3-最长公共子序列"><a href="#算法导论例题3-最长公共子序列" class="headerlink" title="算法导论例题3 最长公共子序列"></a>算法导论例题3 最长公共子序列</h4><h4 id="LeetCode-70-Climbing-Stairs"><a href="#LeetCode-70-Climbing-Stairs" class="headerlink" title="LeetCode 70.Climbing Stairs"></a>LeetCode 70.Climbing Stairs</h4><p>在爬楼梯的时候<br>1.确认原问题和子问题<br>原问题是求解n阶台阶所有走法的数量，子问题是求1阶台阶，2阶台阶，…，n阶台阶的走法。<br>2.确认状态<br>本题的动态规划状态单一，第i个状态即为第i阶走法的所有走法数量。<br>3.确认边界状态的值<br>边界状态为1阶台阶和2阶台阶的走法，1阶台阶有1种走法，2阶台阶有2种走法。即dp[1]=1,dp[2]=2。<br>4.确定状态转移方程<br>将求第i个状态的值转移为求第i-1个状态值和第i-2个状态的值。<br>动态规划状态转移方程为:dp[i] = dp[i-1] + dp[i-2]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（Dynamic programming，在这里，programming是指一种表格法，并非编写计
      
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>第十部分:高级数据结构</title>
    <link href="http://yoursite.com/2019/09/21/leetcode/%E7%AC%AC%E5%8D%81%E9%83%A8%E5%88%86-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/09/21/leetcode/第十部分-高级数据结构/</id>
    <published>2019-09-21T13:05:47.000Z</published>
    <updated>2020-02-28T11:29:15.283Z</updated>
    
    <content type="html"><![CDATA[<p>第十部分总结三种高级数据结构：Trie树，并查集，线段树。</p><h3 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h3><h4 id="trie的概念"><a href="#trie的概念" class="headerlink" title="trie的概念"></a>trie的概念</h4><p>trie树，又称<strong>字典树</strong>或前缀树，是一种有序的、用于<strong>统计、排序和存储</strong>字符串的数据结构，它与二叉查找树不同，关键字不是直接保存在节点中，而是<strong>由节点在树中的位置决定</strong>。<br>一个节点的所有子孙都有<strong>相同的前缀</strong>，也就是这个节点对应的<strong>字符串</strong>，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有<strong>叶子节点</strong>和<strong>部分内部节点</strong>所对应的键才有相应的值。<br>trie树的最大优点就是利用字符串的<strong>公共前缀</strong>来减少存储空间与查询时间，从而最大限度地减少无谓的字符串比较，是非常高效的字符串查找数据结构。<br>如下图所示，该trie树用12个节点保存了6个字符串abcd，abc，abd，b，bcd，efg共6个字符串。<br><img src="/img/data_structure/trie_example.jpg" width="40%" height="20%"><br>该trie树中，字符串abcd，abd的公共前缀是ab，因此可以只存储一份ab以节省空间。当然，如果系统中存在大量字符串且这些字符串基本没有公共前缀，则相应的trie树将非常消耗内存，这也是trie树的一个缺点。</p><h4 id="trie树的基本实现"><a href="#trie树的基本实现" class="headerlink" title="trie树的基本实现"></a>trie树的基本实现</h4><h5 id="trie树中节点数据结构定义"><a href="#trie树中节点数据结构定义" class="headerlink" title="trie树中节点数据结构定义"></a>trie树中节点数据结构定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段树的数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的字符值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的孩子节点，key是孩子节点值,value是孩子节点的下一个字典树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是叶子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isLeaf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        isLeaf = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isLeaf = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找指定字符串在trie树中是否存在"><a href="#查找指定字符串在trie树中是否存在" class="headerlink" title="查找指定字符串在trie树中是否存在"></a>查找指定字符串在trie树中是否存在</h5><p>查找指定的单词是否在trie树里面。如果单词在trie树里面，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word != <span class="keyword">null</span> &amp;&amp; word.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur.children.containsKey(charArray[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children.get(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isLeaf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="trie树中插入字符串"><a href="#trie树中插入字符串" class="headerlink" title="trie树中插入字符串"></a>trie树中插入字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word != <span class="keyword">null</span> &amp;&amp; word.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur.children.containsKey(charArray[i])) &#123;</span><br><span class="line">                TrieNode node = <span class="keyword">new</span> TrieNode(charArray[i]);</span><br><span class="line">                cur.children.put(charArray[i], node);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children.get(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isLeaf = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取trie树中所有的单词"><a href="#获取trie树中所有的单词" class="headerlink" title="获取trie树中所有的单词"></a>获取trie树中所有的单词</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Trie树全部单词(存储路径，记录遍历的路径上面的节点,结果返回到arrayListWord中)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllWordFromTrie</span><span class="params">(TrieNode trieNode, StringBuilder word, </span></span></span><br><span class="line"><span class="function"><span class="params">                               List&lt;String&gt; arrayListWord)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (trieNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, TrieNode&gt; entry : trieNode.children.entrySet()) &#123;</span><br><span class="line">            word.append(entry.getKey());</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue().isLeaf) &#123;</span><br><span class="line">                arrayListWord.add(word.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            getAllWordFromTrie(entry.getValue(), word, arrayListWord);</span><br><span class="line">            word.deleteCharAt(word.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断给定的前缀在trie中是否存在"><a href="#判断给定的前缀在trie中是否存在" class="headerlink" title="判断给定的前缀在trie中是否存在"></a>判断给定的前缀在trie中是否存在</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix != <span class="keyword">null</span> &amp;&amp; prefix.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = prefix.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur.children.containsKey(charArray[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children.get(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trie树总结"><a href="#trie树总结" class="headerlink" title="trie树总结"></a>trie树总结</h4><p>Trie树是一种非常重要的数据结构，它在信息检索，字符串匹配等领域有广泛的应用，同时，它也是很多算法和复杂数据结构的基础，如后缀树，AC自动机等。<br>以上有关Trie的整体代码实现请点击<a href="https://github.com/HelloWorld0318/leetcode/blob/master/src/main/java/com/hjx/leetcode/tree/trie/Trie.java" target="_blank" rel="noopener">这里</a><br>推荐两道leetcode上面关于字典树的题目。<br>1.<a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Implement Trie (Prefix Tree)</a>,对应的解答在<a href="https://github.com/HelloWorld0318/leetcode/blob/master/src/main/java/com/hjx/leetcode/problem0208/Trie.java" target="_blank" rel="noopener">这里</a><br>2.<a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">Add and Search Word - Data structure design</a>，对应的解答在<a href="https://github.com/HelloWorld0318/leetcode/blob/master/src/main/java/com/hjx/leetcode/problem0211/WordDictionary.java" target="_blank" rel="noopener">这里</a></p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h4><p><strong>并查集</strong>(Union Find)，又称不相交集合(Disjiont Set)，它应用于N个元素的集合<strong>求并</strong>与<strong>查询</strong>问题，在该应用场景中，我们通常是在开始时让每个元素构成一个<strong>单元素</strong>的集合，然后按<strong>一定顺序</strong>将属于<strong>同一组</strong>的元素所在的集合<strong>合并</strong>，其间要<strong>反复查找</strong>一个元素在哪个集合中。虽然该问题并不复杂，但面对<strong>极大的数据量</strong>时，普通的数据结构往往无法解决，并查集就是解决该种问题<strong>最为优秀的算法</strong>。</p><h4 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h4><p>并查集主要有两种操作。</p><ul><li>find(int p)：查询元素p属于哪个集合。</li><li>union(int p,int q)：将元素p和元素q合并操作。这样元素p和q就属于一个集合了。<br>请先看下面的图自己模拟一遍过程<br><img src="/img/data_structure/union_set1.jpg" width="80%" height="40%"><h5 id="数组实现并查集合"><a href="#数组实现并查集合" class="headerlink" title="数组实现并查集合"></a>数组实现并查集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisjointSetByArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ids[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DisjointSetByArray</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置表示集合数组id[i]，初始时每个元素构成一个单元素的集合，</span></span><br><span class="line">        <span class="comment">// 编号为i的元素属于集合i</span></span><br><span class="line">        ids = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ids[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询元素p属于哪个集合时直接返回id[i]</span></span><br><span class="line">        <span class="keyword">return</span> ids[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 负责度为O(n)</span></span><br><span class="line">        <span class="keyword">int</span> pid = find(p);</span><br><span class="line">        <span class="keyword">int</span> qid = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pid == qid) &#123;</span><br><span class="line">            <span class="comment">// 合并时，若两个集合属于同一个集合，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ids.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ids[i] == pid) &#123;</span><br><span class="line">                ids[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> elementCount = <span class="number">8</span>;</span><br><span class="line">        DisjointSetByArray disjointSet = <span class="keyword">new</span> DisjointSetByArray(elementCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [0, 1, 2, 3, 4, 0, 6, 7]</span></span><br><span class="line">        disjointSet.union(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(disjointSet.ids));</span><br><span class="line">        System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">        <span class="comment">// [2, 1, 2, 3, 4, 2, 6, 7]</span></span><br><span class="line">        disjointSet.union(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(Arrays.toString(disjointSet.ids));</span><br><span class="line">        System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">        <span class="comment">// [2, 1, 2, 3, 4, 2, 6, 7]</span></span><br><span class="line">        disjointSet.union(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(disjointSet.ids));</span><br><span class="line">        System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">        <span class="comment">// [3, 1, 3, 3, 4, 3, 6, 7]</span></span><br><span class="line">        disjointSet.union(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(disjointSet.ids));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对应的解答在<a href="https://github.com/HelloWorld0318/leetcode/blob/master/src/main/java/com/hjx/leetcode/disjoint_set/DisjointSetByArray.java" target="_blank" rel="noopener">这里</a></p><h5 id="森林实现并查集合"><a href="#森林实现并查集合" class="headerlink" title="森林实现并查集合"></a>森林实现并查集合</h5><p>使用<strong>森林</strong>存储集合之间的关系，属于<strong>同一集合</strong>的<strong>不同元素</strong>，都有一个<strong>相同的根节点</strong>，代表着这个集合。<br>当进行<strong>查找</strong>某元素属于哪个集合时，即遍历该元素到<strong>根节点</strong>，返回<strong>根节点</strong>所代表的集合；在遍历过程中使用<strong>路径压缩</strong>的优化算法，使整体树的形状<strong>更加扁平</strong>，从而优化<strong>查询的</strong>时间复杂度。<br>当进行<strong>合并</strong>时，即将两颗子树<strong>合为</strong>一棵树，将一棵子树的根节点<strong>指向</strong>另一个子树的根节点；在合并时可按子树的<strong>大小</strong>，将规模较小的子树<strong>合并</strong>到规模较大的子树上，从而使树规模<strong>更加平衡</strong>，从而优化未来<strong>查询</strong>的时间复杂度。<br><img src="/img/data_structure/union_set2.jpg" width="80%" height="40%"></p><p>在查找时，普通的查找即通过id数组遍历至根节点：<br>当p与当前集合id[p]不同时(直到p与id[p]相同时跳出循环)，进行循环:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = id[p]<br>返回p的值</p><p>在查找时增加路径压缩的优化算法:<br>当p与当前集合id[p]不同时(直到p与id[p]相同时跳出循环)，进行循环:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将p的父节点id[p]更新为id[p]的父节点id[id[p]],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = id[p]<br>返回p的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != ids[p]) &#123;</span><br><span class="line">        ids[p] = ids[ids[p]];</span><br><span class="line">        p = ids[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当进行集合的合并时，即将两颗子树合为一棵树，将一棵子树的根节点指向另一棵子树的根节点；<br>在合并时可按子树的大小，将规模较小的子树合并到规模较大的子树上，从而使树更加平衡，从而优化未来查询的时间复杂度。</p><p>合并p所在的集合与q所在的集合：<br>查找p所在集合的根，i=find(p);<br>查找q所在集合的根，j=find(q);<br>如果i与j相同，则直接返回。</p><p>如果i所在子树规模小于j所在子树规模：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将i的根指向j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j的规模增加i子树的规模<br>否则<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将j的根指向i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i的规模增加j子树的规模<br>子树个树减1<br><img src="/img/data_structure/union_set3.jpg" width="80%" height="40%"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ids[p];</span><br><span class="line">    <span class="keyword">int</span> j = ids[q];</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size[i] &lt; size[j]) &#123;</span><br><span class="line">        ids[i] = j;</span><br><span class="line">        size[j] += size[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ids[j] = i;</span><br><span class="line">        size[i] += size[j];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整的代码实现点击<a href="https://github.com/HelloWorld0318/leetcode/blob/master/src/main/java/com/hjx/leetcode/disjoint_set/DisjointSetByForest.java" target="_blank" rel="noopener">这里</a></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>LeetCode547<a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">朋友圈的个数</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        DisjointSet disjointSet = <span class="keyword">new</span> DisjointSet(M.length);</span><br><span class="line">        <span class="comment">// 使用并查集的方法实现(i和j是朋友，可以看成是并查集的一次union操作)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    disjointSet.union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> disjointSet.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="线段树的概念"><a href="#线段树的概念" class="headerlink" title="线段树的概念"></a>线段树的概念</h4><p>线段树是一种平衡二叉搜索树(完全二叉树)，它将一个线段区间划分成一些单元区间。对于线段树中的每一个非叶子结点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]，最后的叶子结点数目为N，与数组下标对应。线段树的操作一般包括建立、查询、插入、跟新等操作，建立规模为N的时间复杂度是O(NlogN)，其他操作的时间复杂度为O(logN)<br><img src="/img/data_structure/segment_tree1.jpg" width="80%" height="40%"><br>由于线段树是完成二叉树，线段树可以使用数组保存，如：<br>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]<br>[15,3,12, 1, 2, 7, 5, 0, 1, 0,  0,  3,  4]<br><img src="/img/data_structure/segment_tree2.jpg" width="80%" height="40%"></p><h4 id="线段树的构造"><a href="#线段树的构造" class="headerlink" title="线段树的构造"></a>线段树的构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线段树数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原始数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建线段树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos   当前线段(节点)在线段树数组(value)中的下标pos</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  当前线段的左端点left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 当前线段的右端点right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        value[pos] = nums[left];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    buildSegmentTree(pos * <span class="number">2</span> + <span class="number">1</span>, left, mid);</span><br><span class="line">    buildSegmentTree(pos * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">    value[pos] = value[pos * <span class="number">2</span> + <span class="number">1</span>] + value[pos * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树的遍历"><a href="#线段树的遍历" class="headerlink" title="线段树的遍历"></a>线段树的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线段树数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原始数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSegmentTree</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layer; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">"---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"["</span> + left + <span class="string">" "</span> + right + <span class="string">"]"</span> + <span class="string">"["</span> + pos + <span class="string">"]"</span> + <span class="string">" "</span> + value[pos]);</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    printSegmentTree(pos * <span class="number">2</span> + <span class="number">1</span>, left, mid, layer + <span class="number">1</span>);</span><br><span class="line">    printSegmentTree(pos * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, right, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树的求和"><a href="#线段树的求和" class="headerlink" title="线段树的求和"></a>线段树的求和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求取区间和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos    当前线段(节点)在线段树数组(value)中的下标pos</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left   当前线段的左端点left，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right  当前线段的右端点right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> qleft  待求和区间的左端点qleft</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> qright 待求和区间的右端点qright</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 待求和区间段的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRangeSegmentTree</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> qleft, <span class="keyword">int</span> qright)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qleft &gt; right || qright &lt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qleft &lt;= left &amp;&amp; right &lt;= qright) &#123;</span><br><span class="line">        <span class="keyword">return</span> value[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sumRangeSegmentTree(pos * <span class="number">2</span> + <span class="number">1</span>, left, mid, qleft, qright) +</span><br><span class="line">            sumRangeSegmentTree(pos * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, right, qleft, qright);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线段树的更新"><a href="#线段树的更新" class="headerlink" title="线段树的更新"></a>线段树的更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线段树的更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos      当前线段(节点)在线段树数组(value)中的下标pos</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left     当前线段树的左端点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right    当前线段树的右端点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index    待更新的数组位置下标Index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 更新值value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSegmentTree</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right &amp;&amp; left == index) &#123;</span><br><span class="line">        value[pos] = newValue;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= mid) &#123;</span><br><span class="line">        updateSegmentTree(pos * <span class="number">2</span> + <span class="number">1</span>, left, mid, index, newValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateSegmentTree(pos * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, right, index, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    value[pos] = value[pos * <span class="number">2</span> + <span class="number">1</span>] + value[pos * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体功能代码在<a href="https://github.com/HelloWorld0318/leetcode/blob/master/src/main/java/com/hjx/leetcode/problem0307/NumArray.java" target="_blank" rel="noopener">这里</a>，对应的题目为<a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">LeetCode307 Range Sum Query - Mutable</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第十部分总结三种高级数据结构：Trie树，并查集，线段树。&lt;/p&gt;
&lt;h3 id=&quot;trie树&quot;&gt;&lt;a href=&quot;#trie树&quot; class=&quot;headerlink&quot; title=&quot;trie树&quot;&gt;&lt;/a&gt;trie树&lt;/h3&gt;&lt;h4 id=&quot;trie的概念&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>Java字节码文件结构剖析</title>
    <link href="http://yoursite.com/2019/08/17/jvm/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/17/jvm/Java字节码文件结构剖析/</id>
    <published>2019-08-17T09:32:08.000Z</published>
    <updated>2019-08-26T15:23:18.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为Java开发者，我们知道Java语言是跨平台的，而支撑这个特性很重要的根基是Java虚拟机和字节码存储格式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java虚拟机发展到了今天，已经脱离了Java语言，形成了一套相对独立的、高性能的执行方案。除了Java 外，Scala、Groovy、Kotlin等，这些语言都可以运行在Java虚拟机之上。而实现这种语言无关性的基础仍然是Java虚拟机和字节码存储格式。本文主要详细介绍Class类文件的结构。在具体介绍Class类文件结构之前，会先介绍javap这个反编译命令的使用。</p></blockquote><h3 id="反编译命令介绍"><a href="#反编译命令介绍" class="headerlink" title="反编译命令介绍"></a>反编译命令介绍</h3><p>javap命名是JDK自带的反编译工具。它的作用就是根据class字节码文件，反编译出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。javap的用法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap &lt;options&gt; &lt;classes&gt;</span><br></pre></td></tr></table></figure></p><p>使用javap -help可以看到javap的options参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>一般常用的是-v -l -c三个选项：<br>javap -v:不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息<br>javap -l:会输出行号和本地变量表信息。<br>javap -c:会对当前class字节码进行反编译生成汇编代码。</p><h3 id="Java字节码文件结构剖析"><a href="#Java字节码文件结构剖析" class="headerlink" title="Java字节码文件结构剖析"></a>Java字节码文件结构剖析</h3><h4 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h4><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行期的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。<br>整个Class文件本质上就是一张表，它由下面的表所示的数据项构成。</p><blockquote><blockquote><p>画图</p></blockquote></blockquote><h4 id="介绍前准备"><a href="#介绍前准备" class="headerlink" title="介绍前准备"></a>介绍前准备</h4><p>本文进行的Java字节码文件剖析将以下面的程序为示例进行介绍<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对MyTest1.class文件进行反编译得到的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">警告: 二进制文件classcode.MyTest1包含com.hjx.jvm.classcode.MyTest1</span><br><span class="line">Classfile /Users/houjinxiang/Documents/jdk8/out/production/classes/com/hjx/jvm/classcode/MyTest1.class</span><br><span class="line">  Last modified 2019-8-17; size 489 bytes</span><br><span class="line">  MD5 checksum 1f830080eef4d29e73755ad871c8774e</span><br><span class="line">  Compiled from &quot;MyTest1.java&quot;</span><br><span class="line">public class com.hjx.jvm.classcode.MyTest1</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#21         // com/hjx/jvm/classcode/MyTest1.a:I</span><br><span class="line">   #3 = Class              #22            // com/hjx/jvm/classcode/MyTest1</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/hjx/jvm/classcode/MyTest1;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               MyTest1.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               com/hjx/jvm/classcode/MyTest1</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.hjx.jvm.classcode.MyTest1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: iconst_1</span><br><span class="line">         6: putfield      #2                  // Field a:I</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 5: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      10     0  this   Lcom/hjx/jvm/classcode/MyTest1;</span><br><span class="line"></span><br><span class="line">  public int getA();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field a:I</span><br><span class="line">         4: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/hjx/jvm/classcode/MyTest1;</span><br><span class="line"></span><br><span class="line">  public void setA(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iload_1</span><br><span class="line">         2: putfield      #2                  // Field a:I</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Lcom/hjx/jvm/classcode/MyTest1;</span><br><span class="line">            0       6     1     a   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyTest1.java&quot;</span><br></pre></td></tr></table></figure></p><p>用Hex Field软件打开MyTest1.class文件，得到如下的二进行文件显示：<br><img src="/img/jvm/class1.png" alt></p><h4 id="魔术与Class文件的版本"><a href="#魔术与Class文件的版本" class="headerlink" title="魔术与Class文件的版本"></a>魔术与Class文件的版本</h4><p>1.使用javap -verbose命名分析一个字节码文件时，将会分析该字节码文件的魔数，版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量等信息。<br>2.魔数：所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE<br>3.魔数之后的4个字节为版本信息，前两个字节表示minor version(次版本)，后两个字节表示major version（主版本号）<br>4.常量池（constant pool）：紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看成是Class文件的资源仓库，比如说Java类中定义的方法与变量信息。常量池中主要存储两类常量：字面量与符号引用。字面量如文本字符串，Java中声明为final的常量值等，而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符。<br>5.常量池的总体结构：Java类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池数量紧跟在主版本号后面，占据两个字节，常量池数组则紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型，结构都是不同的；但是，每一种元素的第一个数据都是一个u1类型，该字节是一个标志位，占据1个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中的元素的个数=常量池 -1 （其中0暂时不使用）。目的是满足某些常量池索引值的数据在特定情况下需要表达【不引用任何一个常量池】的含义：根本原因在于，索引为0也是一个常量，只不过它不位于常量表中，这个常量对应null值；所以，常量池的索引从1而非0开始。<br>在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符加对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如下所示：B（Byte）,C(char),D(double),F(float),I(int),J(long),S(short),Z(boolean),V(void),L(对象类型)，如Ljava/long/String;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作为Java开发者，我们知道Java语言是跨平台的，而支撑这个特性很重要的根基是Java虚拟机和字节码存储格式。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbs
      
    
    </summary>
    
      <category term="深入理解JVM" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM性能调优入门</title>
    <link href="http://yoursite.com/2019/08/10/jvm/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/08/10/jvm/JVM性能调优入门/</id>
    <published>2019-08-10T12:24:28.000Z</published>
    <updated>2019-08-17T12:27:59.120Z</updated>
    
    <content type="html"><![CDATA[<p>理解如何进行JVM调优就变得非常有必要。<br><br></p><p>垃圾收集</p><h3 id="1-性能属性"><a href="#1-性能属性" class="headerlink" title="1.性能属性"></a>1.性能属性</h3><p>吞吐量：是评价垃圾收集器能力的重要指标之一，指不考虑垃圾收集引起的停顿时间或内存消耗，垃圾收集器能支撑应用程序达到的最高性能指标。<br>延迟：也是评价垃圾收集器能力的重要指标，度量标准是缩短由于垃圾收集引起的停顿时间或完全消除因垃圾收集所引起的停顿，避免应用程序运行时发生抖动。<br>内存占用：垃圾收集器流畅运行所需要的内存数量。</p><p>这其中任何一个属性性能的提高几乎都是以另一个或两个属性性能的损失做代价的。换句话说，某一个属性上的性能提高总会牺牲另一个或两个属性。然而，对大多数的应用而言，极少出现这三个属性的重要程序都同等的情况。很多时候，某一个或两个属性的性能要比另一个重要。</p><h3 id="2-原则"><a href="#2-原则" class="headerlink" title="2.原则"></a>2.原则</h3><p>每次Minor Gc都尽可能多地收集垃圾对象。我们把这称为“Minor Gc”原则。遵守这一原则可以减少应用程序发生Full Gc的频率。Fucc Gc的持续时间总是最长的，是应用程序无法达到其延迟或吞吐量要求的罪魁祸首。</p><p>处理吞吐量和延迟问题时，垃圾处理器能使用的内存越大，即Java堆空间越大，垃圾收集的效果越好，应用程序运行也越流畅。我们称之为“GC内存最大化原则”。</p><p>这三个性能属性（吞吐量，延迟，内存占用）中任意选择两个进行JVM垃圾收集器调优。我们称之为“GC调优的3选2原则”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;理解如何进行JVM调优就变得非常有必要。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;垃圾收集&lt;/p&gt;
&lt;h3 id=&quot;1-性能属性&quot;&gt;&lt;a href=&quot;#1-性能属性&quot; class=&quot;headerlink&quot; title=&quot;1.性能属性&quot;&gt;&lt;/a&gt;1.性能属性&lt;/h3&gt;&lt;p&gt;吞吐量：是评
      
    
    </summary>
    
      <category term="深入理解JVM" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>基于Spark Streaming+Canal+Kafka对Mysql增量数据实时进行检测分析</title>
    <link href="http://yoursite.com/2019/08/05/big_data/%E5%9F%BA%E4%BA%8ESpark-Streaming-Canal-Kafka%E5%AF%B9Mysql%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/05/big_data/基于Spark-Streaming-Canal-Kafka对Mysql增量数据实时进行检测分析/</id>
    <published>2019-08-05T03:22:15.000Z</published>
    <updated>2019-08-17T13:03:25.970Z</updated>
    
    <content type="html"><![CDATA[<p>待完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;待完成&lt;/p&gt;

      
    
    </summary>
    
      <category term="大数据技术学习" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题分类</title>
    <link href="http://yoursite.com/2019/08/01/leetcode/LeetCode%E5%88%B7%E9%A2%98%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/08/01/leetcode/LeetCode刷题分类/</id>
    <published>2019-08-01T08:01:11.000Z</published>
    <updated>2019-11-24T02:20:51.418Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM内存空间划分与作用详解</title>
    <link href="http://yoursite.com/2019/08/01/jvm/JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/08/01/jvm/JVM内存空间划分与作用详解/</id>
    <published>2019-08-01T03:57:26.000Z</published>
    <updated>2019-11-17T09:11:19.716Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名Java程序员，在编写程序时除了尽情发挥Java的各种优势外，还应该去了解和思考一下Java技术体系中这些技术特征是如何实现的。如果开发人员不了解虚拟机一些技术特性的运行原理，就无法写出最适合虚拟机运行和自优化的代码。</p><p>一旦使用了关键字strictfp来生明某个类，接口或者方法时，那么在这个关键字声明的范围内的所有浮点运算都是精确的，符合ieee-754标准。</p><p>JDK1.5在Java语法的易用性上面做出了非常大的改进。例如：自动装箱、范型、动态注解、枚举、可变长参数、遍历循环（foreach循环）等语法特性都是在JDK1.5中加入的。</p><p>HotSpot VM的热点代码探测能力可以通过执行计数器找到最具有编译价值的代码，然后通过JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无需等待本地代码输出才能执行程序，即使编译的时间压力也相对减少，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。</p><p>模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。站在整个软件工业化的高度来看，模块化是建立各种功能的标准件的前提。</p><h3 id="Java内存模块图"><a href="#Java内存模块图" class="headerlink" title="Java内存模块图"></a>Java内存模块图</h3><h3 id="各区域介绍"><a href="#各区域介绍" class="headerlink" title="各区域介绍"></a>各区域介绍</h3><h3 id="JDK1-8以后的JVM内存模块图"><a href="#JDK1-8以后的JVM内存模块图" class="headerlink" title="JDK1.8以后的JVM内存模块图"></a>JDK1.8以后的JVM内存模块图</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。<br>程序计数器处于线程独占区。<br>如果线程执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果只在执行的是native方法，这个计数器的值为undefined<br>此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>虚拟机栈描述的是Java方法执行的动态内存模型。<br>帧栈<br>    每个方法执行，都会创建一个帧栈，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等。</p><p>局部变量表<br>    存放编译器可知的各种基本数据类型，引用类型，returnAddress类型<br>    局部变量表的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多少内存时固定的，在方法运行期间时不会改变局部变量表的大小<br>大小</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>虚拟机栈为虚拟机执行Java方法服务。<br>本地方法栈为虚拟机执行native方法服务。<br>HostSpot虚拟机不区分本地方法栈和虚拟机栈</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>存放对象实例<br>垃圾收集器管理的主要区域<br>新生代，老年代</p><h3 id="OOM分析"><a href="#OOM分析" class="headerlink" title="OOM分析"></a>OOM分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名Java程序员，在编写程序时除了尽情发挥Java的各种优势外，还应该去了解和思考一下Java技术体系中这些技术特征是如何实现的。如果开发人员不了解虚拟机一些技术特性的运行原理，就无法写出最适合虚拟机运行和自优化的代码。&lt;/p&gt;
&lt;p&gt;一旦使用了关键字strictfp
      
    
    </summary>
    
      <category term="深入理解JVM" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>69.sqrt(x)</title>
    <link href="http://yoursite.com/2018/09/15/leetcode/69-sqrt-x/"/>
    <id>http://yoursite.com/2018/09/15/leetcode/69-sqrt-x/</id>
    <published>2018-09-15T14:44:39.000Z</published>
    <updated>2018-09-16T01:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">Sqrt(x)(难度级别：easy)</a><br><strong>Description</strong>:<br>Implement int sqrt(int x).<br>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.<br>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.<br><strong>Example 1</strong>:<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure></p><h3 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h3><p>虽然这道题的难度级别只有easy，但是个人觉得还是一个非常有意思的题目。解题方法就是用“二分查找”的思想。还有一点需要注意的是，如果你用乘法，可能会出现超过int范围值的问题。具体解题代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Title</span>: mySqrt </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span>: Compute and return the square root of x</span></span><br><span class="line"><span class="comment">  * (采用二分查找的思路)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x x是一个整数，并且非负</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> int  x的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> end = x / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> lastMedium = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line"><span class="keyword">int</span> medium = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x / medium &gt; medium) &#123;<span class="comment">// 注意这里不要用乘法</span></span><br><span class="line">start = medium + <span class="number">1</span>;</span><br><span class="line">lastMedium = medium;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x / medium &lt; medium) &#123;</span><br><span class="line">end = medium - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> medium;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastMedium;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sqrtx/description/&quot; tar
      
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>AOP以及自己实现一个AOP</title>
    <link href="http://yoursite.com/2018/09/14/spring/AOP%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAOP/"/>
    <id>http://yoursite.com/2018/09/14/spring/AOP以及自己实现一个AOP/</id>
    <published>2018-09-14T07:22:49.000Z</published>
    <updated>2018-09-15T03:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP(面向对象编程)的延续。是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>在AOP中，采用了横向抽取机制，取代了传统纵向继承体系重复性代码。<br>AOP的经典应用有事务管理，性能监视，安全检查，缓存，日志等。</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p><img src="/img/spring/aop1.jpg" alt><br>1.目标类(Target)：需要被代理的对象。例如：UserService<br>2.连接点(JoinPoint):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法。<br>3.切入点(PointCut)：已经被增强的连接点。例如：addUser()，注意，切入点是连接点的子集。<br>4.通知(Advice)：通知/增强，增强代码。例如：after,before。<br>5.代理(Proxy)：代理类<br>6.织入（Warve）：是指把增强advice应用到目标对象target来创建新的代理对象Proxy的过程<br>7.切面(Aspect)：是切入点pointcut和通知advice的结合<br>一个线是一个特殊的面。一个切入点和一个通知，组成一个特殊的面。</p><h3 id="采用JDK的动态代理实现AOP"><a href="#采用JDK的动态代理实现AOP" class="headerlink" title="采用JDK的动态代理实现AOP"></a>采用JDK的动态代理实现AOP</h3><p>利用Proxy实现AOP的主要步骤如下：<br>（1）创建接口<br>（2）创建接口实现类<br>（3）创建代理工厂类</p><h4 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建接口的实现类"><a href="#创建接口的实现类" class="headerlink" title="创建接口的实现类"></a>创建接口的实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiveImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"新增用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建代理工厂类"><a href="#创建代理工厂类" class="headerlink" title="创建代理工厂类"></a>创建代理工厂类</h4><p>增强代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogAdvice</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在方法开始前开启日志</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logStart</span><span class="params">(Method method)</span></span>;</span><br><span class="line"><span class="comment">// 在方法结束侯关闭日历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增强代码的实现类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdviceImpl</span> <span class="keyword">implements</span> <span class="title">LogAdvice</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method name "</span> + method.getName() + <span class="string">"start"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method name"</span> + method.getName() + <span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建代理工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object advice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyBean</span><span class="params">(Object target,Object advice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line"><span class="keyword">this</span>.advice = advice;</span><br><span class="line">LogAdvice logAdvice = <span class="keyword">new</span> LogAdviceImpl();</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(ProxyFactory.class.getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Method logStart = advice.getClass().getDeclaredMethod(<span class="string">"logStart"</span>,Method.class);</span><br><span class="line">logStart.invoke(advice,method);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">Method logEnd = advice.getClass().getDeclaredMethod(<span class="string">"logEnd"</span>, Method.class);</span><br><span class="line">logEnd.invoke(advice, method);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">UserService userService = (UserService) proxyFactory.getProxyBean(</span><br><span class="line"><span class="keyword">new</span> UserServiveImpl(), <span class="keyword">new</span> LogAdviceImpl());</span><br><span class="line">userService.addUser();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method name addUser log start</span><br><span class="line">新增用户</span><br><span class="line">method nameaddUser log end</span><br></pre></td></tr></table></figure></p><h3 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h3><p>利用Proxy实现AOP功能的总结如下：<br>（1）目标类必须时间接口<br>（2）返回创建的代理对象<br>（3）重写InvocationHandler里面的invoke()方法<br>（4）限制条件放在invoke()方法中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AOP概述&quot;&gt;&lt;a href=&quot;#AOP概述&quot; class=&quot;headerlink&quot; title=&quot;AOP概述&quot;&gt;&lt;/a&gt;AOP概述&lt;/h3&gt;&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为:面向切面编程，通过预编译方式和
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring中bean的生命周期</title>
    <link href="http://yoursite.com/2018/09/07/spring/Spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/09/07/spring/Spring中bean的生命周期/</id>
    <published>2018-09-07T12:18:18.000Z</published>
    <updated>2018-09-15T02:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring中bean的生命周期"><a href="#Spring中bean的生命周期" class="headerlink" title="Spring中bean的生命周期"></a>Spring中bean的生命周期</h3><blockquote><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。<br>相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图为一个典型的bean装载到Springy应用上下文中的一个典型的生命周期过程。</p></blockquote><p><img src="/img/spring/spring-bean-lifecycle.jpg" alt><br>（1）实例化Bean<br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用creatBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。<br>容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。<br>实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。<br>（2）设置对象属性（DI）<br>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。<br>紧接着，Spring根据BeanDefinition中的信息进行依赖注入。<br>并且根据BeanWrapper提供的设置属性的接口完成依赖注入。<br>（3）注入Aware接口<br>紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。<br>（4）BeanPostProcessor<br>当经过上述几个步骤后，bean对象已经被正确构造了，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。<br>postProcessBeforeInitialization(Object bean,String beanName):当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会先于InitializationBean执行，因此称为前置处理。所有Aware接口的注入就是在这一步完成的。<br>postProcessAfterInitialization(Object bean,String beanName):当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会在InitializationBean完成后执行，因此称为后置处理。<br>（5）InitializingBean与init-method<br>当BeanPostProcessor的前置处理完成后就会进行本阶段。InitializingBean接口只有一个函数：afterPropertiesSet()<br>这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在一步没办法处理对象本身，只能增加一些额外的逻辑。若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet()函数。<br>当然，Spring为了降低对客户端代码的侵入性，给bean的配置提供了init-method属性，该属性指定在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上任然使用了InitializingBean接口。<br>（6）DisposableBean的destroy-method<br>和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>需要Spring创建的bean实例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第一步：bean被实例化,调用Person类的构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第二步：通过set方法去填充属性"</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第三步：调用BeanNameAware的setBeanName(),beanName:"</span> + beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">"第五步：ApplicationContextAware的setApplicationContext()方法被调用,这样该Bean就获得了自己所在的ApplicationContext"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第七步：InitializingBean的afterPropertiesSet()方法被调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第八步：Bean配置了init-method方法，则会执行init-method配置的方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第十步：调用DisposableBean的destory()方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的销毁方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第十一步：自定义的销毁方法myDestroy被调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"name is :"</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyBeanPostProcessor实现BeanPostProcessor接口，重写里面的postProcessBeforeInitialization和postProcessAfterInitialization方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用"</span>);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法"</span>);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personId"</span> <span class="attr">class</span>=<span class="string">"com.phicomm.lifecycle.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInit"</span> <span class="attr">destroy-method</span>=<span class="string">"myDestroy"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"hellokitty"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"postProcessor"</span> <span class="attr">class</span>=<span class="string">"com.phicomm.lifecycle.MyBeanPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcPersonServiceTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始初始化容器"</span>);</span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/phicomm/lifecycle/applicationContext.xml"</span>);</span><br><span class="line">System.out.println(<span class="string">"xml加载完毕"</span>);</span><br><span class="line">        Person person1 = (Person) ac.getBean(<span class="string">"personId"</span>);</span><br><span class="line">        System.out.println(person1);        </span><br><span class="line">        System.out.println(<span class="string">"关闭容器"</span>);</span><br><span class="line">        ((ClassPathXmlApplicationContext)ac).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行的结果的如下，符合Spring bean的生命周期中的各个步骤<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">开始初始化容器</span><br><span class="line">九月 15, 2018 9:43:42 上午 org.springframework.context.support.AbstractApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3eb07fd3: startup date [Sat Sep 15 09:43:42 CST 2018]; root of context hierarchy</span><br><span class="line">九月 15, 2018 9:43:42 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</span><br><span class="line">信息: Loading XML bean definitions from class path resource [com/phicomm/lifecycle/applicationContext.xml]</span><br><span class="line">第一步：bean被实例化,调用Person类的构造方法</span><br><span class="line">第二步：通过set方法去填充属性</span><br><span class="line">第三步：调用BeanNameAware的setBeanName(),beanName:personId</span><br><span class="line">第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory</span><br><span class="line">第五步：ApplicationContextAware的setApplicationContext()方法被调用,这样该Bean就获得了自己所在的ApplicationContext</span><br><span class="line">第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用</span><br><span class="line">com.phicomm.lifecycle.Person</span><br><span class="line">第七步：InitializingBean的afterPropertiesSet()方法被调用</span><br><span class="line">第八步：Bean配置了init-method方法，则会执行init-method配置的方法</span><br><span class="line">第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法</span><br><span class="line">xml加载完毕</span><br><span class="line">name is :hellokitty</span><br><span class="line">关闭容器</span><br><span class="line">九月 15, 2018 9:43:42 上午 org.springframework.context.support.AbstractApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@3eb07fd3: startup date [Sat Sep 15 09:43:42 CST 2018]; root of context hierarchy</span><br><span class="line">第十步：调用DisposableBean的destory()方法</span><br><span class="line">第十一步：自定义的销毁方法myDestroy被调用</span><br></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>（1）如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个protype bean的整个生命周期负责：容器在初始化，配置，装饰或者装配完一个prototype实例后，将它交个客户端，随后就对该prototype实例不闻不问了。<br>（2）BeanFactory容器中，B与ApplicationContext相比，有如下几点不同：<br>1、BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法；<br>2、BeanPostProcessor接口的postProcessBeforeInitialization()<br>方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册;<br>3、BeanFactory容器启动的时候，不会去实例化所有的Bean，包括所有scope为Sinleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。<br>BeanFactory的示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BfPersonServiceTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始初始化容器"</span>);</span><br><span class="line">ConfigurableBeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(</span><br><span class="line"><span class="keyword">new</span> ClassPathResource(<span class="string">"com/phicomm/lifecycle/applicationContext.xml"</span>));</span><br><span class="line">System.out.println(<span class="string">"xml加载完毕"</span>);</span><br><span class="line"><span class="comment">// beanFactory需要手动注册beanPostProcessor类的方法</span></span><br><span class="line">bf.addBeanPostProcessor(<span class="keyword">new</span> MyBeanPostProcessor());</span><br><span class="line">Person person1 = (Person) bf.getBean(<span class="string">"personId"</span>);</span><br><span class="line">System.out.println(person1);</span><br><span class="line">System.out.println(<span class="string">"关闭容器"</span>);</span><br><span class="line">bf.destroySingletons();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">开始初始化容器</span><br><span class="line">九月 15, 2018 9:58:02 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</span><br><span class="line">信息: Loading XML bean definitions from class path resource [com/phicomm/lifecycle/applicationContext.xml]</span><br><span class="line">xml加载完毕</span><br><span class="line">第一步：bean被实例化,调用Person类的构造方法</span><br><span class="line">第二步：通过set方法去填充属性</span><br><span class="line">第三步：调用BeanNameAware的setBeanName(),beanName:personId</span><br><span class="line">第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory</span><br><span class="line">第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用</span><br><span class="line">第七步：InitializingBean的afterPropertiesSet()方法被调用</span><br><span class="line">第八步：Bean配置了init-method方法，则会执行init-method配置的方法</span><br><span class="line">第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法</span><br><span class="line">name is :hellokitty</span><br><span class="line">关闭容器</span><br><span class="line">第十步：调用DisposableBean的destory()方法</span><br><span class="line">第十一步：自定义的销毁方法myDestroy被调用</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring中bean的生命周期&quot;&gt;&lt;a href=&quot;#Spring中bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring中bean的生命周期&quot;&gt;&lt;/a&gt;Spring中bean的生命周期&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>redis集群搭建</title>
    <link href="http://yoursite.com/2018/08/24/redis/redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/08/24/redis/redis集群搭建/</id>
    <published>2018-08-24T07:58:31.000Z</published>
    <updated>2019-12-23T06:24:04.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h3><h3 id="redis-cluster架构图"><a href="#redis-cluster架构图" class="headerlink" title="redis-cluster架构图"></a>redis-cluster架构图</h3><h3 id="redis-cluster图片-容错"><a href="#redis-cluster图片-容错" class="headerlink" title="redis-cluster图片-容错"></a>redis-cluster图片-容错</h3><h3 id="redis-cluster搭建过程"><a href="#redis-cluster搭建过程" class="headerlink" title="redis-cluster搭建过程"></a>redis-cluster搭建过程</h3><h3 id="添加Master节点"><a href="#添加Master节点" class="headerlink" title="添加Master节点"></a>添加Master节点</h3><h3 id="删除Master节点"><a href="#删除Master节点" class="headerlink" title="删除Master节点"></a>删除Master节点</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis的主从复制&quot;&gt;&lt;a href=&quot;#redis的主从复制&quot; class=&quot;headerlink&quot; title=&quot;redis的主从复制&quot;&gt;&lt;/a&gt;redis的主从复制&lt;/h3&gt;&lt;h3 id=&quot;redis-cluster架构图&quot;&gt;&lt;a href=&quot;#redis
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://yoursite.com/2018/08/17/designpattern/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/17/designpattern/装饰模式/</id>
    <published>2018-08-17T15:19:19.000Z</published>
    <updated>2018-09-11T08:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="装饰模式的动机和定义"><a href="#装饰模式的动机和定义" class="headerlink" title="装饰模式的动机和定义"></a>装饰模式的动机和定义</h3><h4 id="装饰模式的动机"><a href="#装饰模式的动机" class="headerlink" title="装饰模式的动机"></a>装饰模式的动机</h4><p>一般有两种方式可以实现给一个类或对象增加行为：<br>（1）继承机制：使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方式是静态的，用户不能控制增加行为的方法和时机。<br>（2）关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器（Decorator）。</p><h4 id="装饰模式的定义"><a href="#装饰模式的定义" class="headerlink" title="装饰模式的定义"></a>装饰模式的定义</h4><blockquote><p>装饰模式可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。<br>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.[GOF]<br>装饰模式可以在无需创建子类的情况下扩展类的功能。在对象功能扩展方面，它比继承更有弹性。</p></blockquote><p>装饰模式的类图如下所示：<br><img src="/img/Decorator/Decorator.png" alt><br>Component：抽象构件<br>ConcreteComponent：具体构件<br>Decorator：抽象装饰类，维持一个指向Component对象的指针或引用，并定义一个与Component接口一致的接口。Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。<br>ConcreteDecorator：具体装饰类</p><h3 id="装饰模式实例演示"><a href="#装饰模式实例演示" class="headerlink" title="装饰模式实例演示"></a>装饰模式实例演示</h3><p>通俗来讲，装饰模式就像打包一个快递。现在以一个具体的情景来说明装饰模式。<br>现实的发票有三部分组成：头部分，主体部分（数据部分），尾部分；不同的对象打印出来的头和尾是不一样的，但是主体部分是一样，要实现这样的需求，就应该采用装饰模式，下面是UML图：<br><img src="/img/Decorator/printer.png" alt><br>参照上图可知装饰模式的各种角色有：<br>(1)抽象构建角色（IPrintable）：定义一个抽象接口，以规范准备接受附加责任的对象。<br>(2)具体构件角色（Order）：这是被装饰者，定义一个将要被装饰模式增加功能的类。<br>(3)装饰角色（OrderDecorator）:持有一个构件对象的实例，并定义了抽象构件定义的接口。<br>(4)具体装饰角色（HeaderDecorator FooterDecorator）：负责给构件添加增加的功能。<br>首先，设计客户端使用的接口，在此例中即IPrintable，设计此接口的目的是对下面的实现类和各种装饰类加以抽象，方便客户端统一使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个有打印方法的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPrintable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 接口打印方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设计一个实现类可供客户端使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">IPrintable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发票的主题内容"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在开始设计具有真正功能的装饰类之前，先来考虑一下实现的问题。假设有很多装饰类被设计出来，在这些类中一定会有两类代码存在，一类是装饰上的功能代码，在此例中比如打印头部和尾部的代码；另一类是调用被装饰对象的功能代码，在此例中就是Order类的print()方法。<br>在这两类方法中，第一类代码是不重复的，每个类各不一样，但是第二类代码在这些类中却完全一样，这违背了“不要重复自己（Don’t Repeat Youself）DRY”原则，所以在这里需要设计一个所有装饰类的父类来改善这种设计。<br>发票装饰类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发票装饰抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDecorator</span> <span class="keyword">implements</span> <span class="title">IPrintable</span></span>&#123;</span><br><span class="line"><span class="comment">// 用于装饰的私有对象</span></span><br><span class="line"><span class="keyword">private</span> IPrintable iprintable;</span><br><span class="line"><span class="comment">// 构造方法，使用时传入装饰对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderDecorator</span><span class="params">(IPrintable iprintable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.iprintable = iprintable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实现接口方法，注意此处调用装饰对象的对应方法</span></span><br><span class="line">iprintable.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以打印发票头部信息的类如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderDecorator</span> <span class="keyword">extends</span> <span class="title">OrderDecorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderDecorator</span><span class="params">(IPrintable iprintable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(iprintable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"打印发票头部"</span>);</span><br><span class="line"><span class="keyword">super</span>.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以打印发票尾部的类的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooterDecorator</span> <span class="keyword">extends</span> <span class="title">OrderDecorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FooterDecorator</span><span class="params">(IPrintable iprintable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(iprintable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.print();</span><br><span class="line">System.out.println(<span class="string">"打印发票尾部"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">IPrintable iprintable = <span class="keyword">new</span> Order();</span><br><span class="line">iprintable.print();</span><br><span class="line">System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">iprintable = <span class="keyword">new</span> FooterDecorator(iprintable);</span><br><span class="line">iprintable.print();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">iprintable = <span class="keyword">new</span> HeaderDecorator(iprintable);</span><br><span class="line">iprintable.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">发票的主体内容</span><br><span class="line">------------------------------</span><br><span class="line">发票的主体内容</span><br><span class="line">打印发票尾部</span><br><span class="line">------------------------------</span><br><span class="line">打印发票头部</span><br><span class="line">发票的主体内容</span><br><span class="line">打印发票尾部</span><br></pre></td></tr></table></figure></p><h3 id="JDK中装饰模式介绍"><a href="#JDK中装饰模式介绍" class="headerlink" title="JDK中装饰模式介绍"></a>JDK中装饰模式介绍</h3><p>在JDK中，有很多使用装饰模式的案例，如java.io包中对流的处理。</p><h4 id="Java的I-O中装饰模式的体现"><a href="#Java的I-O中装饰模式的体现" class="headerlink" title="Java的I/O中装饰模式的体现"></a>Java的I/O中装饰模式的体现</h4><p>在Java中流（Stream）是一种有序的字节数据对象。流又分为输入流（InputStream）和输出流（OutputStream）。输入流从外部资源（文件，内存，socket等）读入字节数据到Java对象；输出流则把Java对象（字节数据）写入到外部资源。<br>所有Java I/O都可归类以下两种：（1）字节数据输入输出I/O；（2）字符数据输入输出I/O。在下例中，只研究InputStream类的装饰模式，理解了这一种设计方式，其他的就很好理解了，因为它们的设计方式是很相似的。<br>Java中的I/O体现装饰模式的类图如下：<br><img src="/img/Decorator/fileDecorator.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此输入对象将被增加过滤功能</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法时传入被修饰对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DataInputStream的部分实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此可见，JDK中的装饰模式与标准的装饰模式的差别很小。</p><h4 id="编写自己的Java-I-O装饰者"><a href="#编写自己的Java-I-O装饰者" class="headerlink" title="编写自己的Java I/O装饰者"></a>编写自己的Java I/O装饰者</h4><p>假设现有我有如下的需求：需要将所有输入的字母装换成大写。<br>通过装饰者模式来实现的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">UpperCaseInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个读取一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">super</span>.read();</span><br><span class="line"><span class="keyword">return</span> c == -<span class="number">1</span> ? c : Character.toUpperCase((<span class="keyword">char</span>) (c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读取len长的字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="keyword">super</span>.read(b, offset, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result; i++) &#123;</span><br><span class="line">b[i] = (<span class="keyword">byte</span>) Character.toUpperCase((<span class="keyword">char</span>) (b[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream in = <span class="keyword">new</span> UpperCaseInputStream(</span><br><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\test.txt"</span>)));</span><br><span class="line"><span class="keyword">while</span> ((c = in.read()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原始文件的内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>运行InputTest输出的代码如下：<br><img src="/img/Decorator/console.png" alt></p><h3 id="装饰着模式关键点"><a href="#装饰着模式关键点" class="headerlink" title="装饰着模式关键点"></a>装饰着模式关键点</h3><blockquote><p>装饰模式的作用是可以动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。<br>在实际应用中，装饰模式通常用做给现有的类增加功能，可以根据应用的需要，对装饰模式的类进行任意顺序的包装，最后生成符合要求的对象。注意传统的装饰模式的特点是聚合了被装饰类的接口。在使用上，如果每种装饰类可能抛出不同的异常，则要对异常进行特别处理。<br>开放-关闭原则的设计意义</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;装饰模式的动机和定义&quot;&gt;&lt;a href=&quot;#装饰模式的动机和定义&quot; class=&quot;headerlink&quot; title=&quot;装饰模式的动机和定义&quot;&gt;&lt;/a&gt;装饰模式的动机和定义&lt;/h3&gt;&lt;h4 id=&quot;装饰模式的动机&quot;&gt;&lt;a href=&quot;#装饰模式的动机&quot; class
      
    
    </summary>
    
      <category term="JAVA设计模式" scheme="http://yoursite.com/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>全面解析Java注解</title>
    <link href="http://yoursite.com/2018/08/17/Java/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/17/Java/注解的实现原理/</id>
    <published>2018-08-17T15:19:19.000Z</published>
    <updated>2018-09-04T11:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1.什么是注解"></a>1.什么是注解</h3><p>注解是JDK1.5的一个新特性，注解是插入你代码中的一种注释或者说是一种元数据（meta data），即一种描述数据的数据。所以，可以说注解就是源代码的元数据。这些注解信息可以在编译期使用预编译工具进行处理（pre-complier tools），也可以在运行期使用Java反射机制进行处理。<br>注解，其实就是对类，方法，属性进行一种标示，一种注释（注意，这个注释不是为了让我们开发或维护人员阅读更方便，而是为给JVM看），通过这些标示，JVM可以完成这些标示对应的功能。</p><h3 id="2-为什么要引入注解"><a href="#2-为什么要引入注解" class="headerlink" title="2.为什么要引入注解"></a>2.为什么要引入注解</h3><p>注解是JDK1.5引入的功能，但是为什么引入注解呢？在JDK1.5之前，Java还没有引入注解，这个时候如果我们要在Spring中声明一个Bean，我们只能通过xml配置的方式，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.phicomm.UserService"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是有了注解以后，我们可以不必写一个xml配置文件，可以直接在UserService类上完成Bean的声明工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于注解的开发方式。我们会发现它和代码结合的很紧密，所以注解比较适合做一些与代码相关度高的操作，例如将bean对应的服务暴露出去，<br>对于xml配置方式。我们会发现它将配置和代码隔离开来了所以XML配置更适合做一些全局的，与具体业务无关的操作。例如全局配置等。<br>基于注解开发还是XML的判断标准应该是：该配置与代码的相关度。如果代码与配置相关度高，那么使用注解配置，否则使用XML配置。</p><h3 id="3-JDK提供的注解"><a href="#3-JDK提供的注解" class="headerlink" title="3.JDK提供的注解"></a>3.JDK提供的注解</h3><p>JDK1.5版本在java.lang.annotation提供了四种元注解，专门注解其他的注解。<br><strong>@Documented</strong>：表示使用该注解的元素应被JavaDoc或类似工具文档化，它应用于类型声明，类型声明的注解会影响客户端对注解元素的使用。如果一个类型声明添加了Documented注解，那么它的注解会成为被注解元素的公共API的一部分。<br><strong>@Retention</strong>：定义该注解的生命周期，它接收RetentionPolicy参数。<br>RetentionPolicy.SOURCE：在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override，@SuppressWarning都属于这类注解。<br>RetentionPolicy.CLASS：在类加载的时候丢弃。在字节码文件的处理中有用。注释默认使用这种方式。<br>RetentionPolicy.RUNTIME：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。<br><strong>@Target</strong>：表示该注解用于什么地方。如果<strong>不明确指出，该注解可以放在任何地方</strong>。以下是一些可以用的参数。需要说明的是，属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。<br>ElementType.TYPE:用于描述类、接口或enum声明<br>ElementType.FIELD:用于描述实例变量<br>ElementType.METHOD<br>ElementType.PARAMETER<br>ElementType.CONSTRUCTOR<br>ElementType.LOCAL_VARIABLE<br>ElementType.ANNOTATION_TYPE 另一个注释<br>ElementType.PACKAGE 用于记录java文件的package信息<br><strong>@Inherited</strong>：表示一个注解类型会被自动继承，如果用户在类声明的时候查询注解类型，同时类声明中也没有这个类型的注解，那么注解类型会自动查询该类的父类，这个过程将会不停地重复，直到该类型的注解被找到为止，或是到达类结构的顶层（Object）。<br>JDK1.8加入了一种新的注解。<br><strong>@Repeatable</strong>：表示注解的值可以取多个。</p><p>JDK提供了五种内置注解：<br><strong>@Override</strong>：当我们想要覆盖父类的一个方法时，需要使用该注解告知编译器我们正在覆盖一个方法。这样的话，当父类的方法被删除或修改了，编译器会提示错误信息。<br><strong>@Deprecated</strong>：当我们想要让编译器知道一个方法已经被弃用（deprecate）时，应该使用这个注解。Java推荐在JavaDoc中提供信息，告知用户为什么这个方法被弃用，以及替代方法是什么。<br><strong>@SuppressWarning</strong>：这个注解仅仅告知编译器，忽略它们产生了特殊警告。比如，在Java泛型了使用原始类型。它的保持性策略是SOURCE，在编译器中将被丢弃。<br><strong>@SafeVarargs</strong>：参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作，它的存在会阻止编译器产生unchecked这样的警告。在JDK1.7中引入。<br><strong>@FunctionalInterfac</strong>e：函数式接口注解，这个是JDK1.8引入的。</p><h3 id="4-创建自定义的注解"><a href="#4-创建自定义的注解" class="headerlink" title="4.创建自定义的注解"></a>4.创建自定义的注解</h3><p>创建自定义注解需要注意如下：<br>（1）.注解方法不能有参数<br>（2）.注解方法的返回类型局限于原始类型，字符串，枚举，注解，或以上类型构成的数组<br>（3）.注解方法可以包含返回值<br>（4）.注解可以包含与其绑定的元注解，元注解为注解提供信息<br>（5）.如果只有一个参数成员，最好把参数名称设为“value”,后加小括号。<br>创建我们自定义的注解如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HelloAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "Hai"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用我们自己创建的注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HelloAnnotation</span>(say = <span class="string">"hello world"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HelloAnnotation helloAnnotation = TestMain.class.getAnnotation(HelloAnnotation.class);</span><br><span class="line">        System.out.println(helloAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的运行结果如下：<br><img src="/img/annotation0.jpg" alt></p><h3 id="5-注解的原理"><a href="#5-注解的原理" class="headerlink" title="5.注解的原理"></a>5.注解的原理</h3><h4 id="5-1-注解获得的具体对象是什么"><a href="#5-1-注解获得的具体对象是什么" class="headerlink" title="5.1 注解获得的具体对象是什么"></a>5.1 注解获得的具体对象是什么</h4><p>我们在TestMain类的main方法加入如下的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HelloAnnotation</span>(value = <span class="string">"hello world"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//运行时生成的动态代理对象是可以导出到文件的</span></span><br><span class="line">        System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        HelloAnnotation helloAnnotation = TestMain.class.getAnnotation(HelloAnnotation.class);</span><br><span class="line">        System.out.println(helloAnnotation.getClass().getName());</span><br><span class="line">        System.out.println(helloAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><img src="/img/annotation1.jpg" alt><br>而生成的动态代理类如下(省略到部分代码)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">HelloAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里生成的代理类重写了我们在注解中定义的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.phicomm.annotation.HelloAnnotation"</span>).getMethod(<span class="string">"value"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据“public final class $Proxy1 extends Proxy implements HelloAnnotation”这段代码，可以看出其实HelloAnnotation是一个接口。我们反编译HelloAnntation.class文件，得到如下的结果。<br><img src="/img/annotation3.jpg" alt><br>Java里面的Annotation的源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口Annotation被我们自定义的注解HelloAnnotation继承，而HelloAnnotation本质是一个接口，这个接口被代理类$Proxy1.java实现，而HelloAnnotation里面的方法都在$Proxy里面重写。这是JDK动态代理机制实现的。我们在TestMain获得的HelloAnnotation对象，就是由这个代理类生成的。</p><h4 id="5-2动态代理类-Proxy1是如何处理helloAnnotation-value-方法的调用的"><a href="#5-2动态代理类-Proxy1是如何处理helloAnnotation-value-方法的调用的" class="headerlink" title="5.2动态代理类$Proxy1是如何处理helloAnnotation.value()方法的调用的"></a>5.2动态代理类$Proxy1是如何处理helloAnnotation.value()方法的调用的</h4><p>熟悉JDK的动态代理一定会涉及到InvocationHandler，而annotation.value()方法的调用一定是通过绑定在InvocationHandler实例的invoke方法上，通过method.invoke()这种形式调用的。我们下面讲解这部分内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">HelloAnnotation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由多态的知识我们知道，helloAnnotation.value()的调用最终会转移到代理类$Proxy重写的value()方法上面，最终执行的代码是(String)super.h.invoke(this, m3, (Object[])null);那这里的InvocationHandler的实例是什么？<br>我们再Proxy的构造方法上面加断点，可以看出这里的InvocationHandler实例是AnnocationInvocationHandler的实例<br><img src="/img/annotation4.jpg" alt><br>而我们的helloAnnotation.value()方法是如何执行的？我们再AnnocationInvocationHandler.java的invoke()方法上加断点单步调试。<br><img src="/img/annotation5.jpg" alt><br>从上图可以看到，value()方法的返回值是从LinkedHashMap里面获得的。这个map结构的key值是方法名，value值是方法的返回值。我们一步步看这个LinkedHashMap结构是如何构造的。<br><img src="/img/annotation6.jpg" alt><br>这个LinkedHashMap是在AnnotationParser类的parseAnnotation2方法中构建的。我们单步调试进入parseNumberValue()方法内部<br><img src="/img/annotation7.png" alt><br><img src="/img/annotation8.png" alt><br><img src="/img/annotation9.png" alt><br>反编译TestMain.class的内容，我们获得了如下内容<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/reflectStudy/out/production/reflectStudy/com/phicomm/annotation/TestMain.class</span><br><span class="line">  Last modified 2018-8-18; size 1125 bytes</span><br><span class="line">  MD5 checksum b6f5e94bc326b15093fbf4b43283ff86</span><br><span class="line">  Compiled from "TestMain.java"</span><br><span class="line">public class com.phicomm.annotation.TestMain</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta">   #</span>1 = Methodref          #13.#32        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line"><span class="meta">   #</span>2 = String             #33            // sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line"><span class="meta">   #</span>3 = String             #34            // true</span><br><span class="line"><span class="meta">   #</span>4 = Methodref          #35.#36        // java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"><span class="meta">   #</span>5 = Class              #37            // com/phicomm/annotation/TestMain</span><br><span class="line"><span class="meta">   #</span>6 = Class              #38            // com/phicomm/annotation/HelloAnnotation</span><br><span class="line"><span class="meta">   #</span>7 = Methodref          #39.#40        // java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line"><span class="meta">   #</span>8 = Fieldref           #35.#41        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="meta">   #</span>9 = Methodref          #13.#42        // java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line"><span class="meta">  #</span>10 = Methodref          #39.#43        // java/lang/Class.getName:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>11 = Methodref          #44.#45        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"><span class="meta">  #</span>12 = InterfaceMethodref #6.#46         // com/phicomm/annotation/HelloAnnotation.value:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>13 = Class              #47            // java/lang/Object</span><br><span class="line"><span class="meta">  #</span>14 = Utf8               &lt;init&gt;</span><br><span class="line"><span class="meta">  #</span>15 = Utf8               ()V</span><br><span class="line"><span class="meta">  #</span>16 = Utf8               Code</span><br><span class="line"><span class="meta">  #</span>17 = Utf8               LineNumberTable</span><br><span class="line"><span class="meta">  #</span>18 = Utf8               LocalVariableTable</span><br><span class="line"><span class="meta">  #</span>19 = Utf8               this</span><br><span class="line"><span class="meta">  #</span>20 = Utf8               Lcom/phicomm/annotation/TestMain;</span><br><span class="line"><span class="meta">  #</span>21 = Utf8               main</span><br><span class="line"><span class="meta">  #</span>22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line"><span class="meta">  #</span>23 = Utf8               args</span><br><span class="line"><span class="meta">  #</span>24 = Utf8               [Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>25 = Utf8               helloAnnotation</span><br><span class="line"><span class="meta">  #</span>26 = Utf8               Lcom/phicomm/annotation/HelloAnnotation;</span><br><span class="line"><span class="meta">  #</span>27 = Utf8               SourceFile</span><br><span class="line"><span class="meta">  #</span>28 = Utf8               TestMain.java</span><br><span class="line"><span class="meta">  #</span>29 = Utf8               RuntimeVisibleAnnotations</span><br><span class="line"><span class="meta">  #</span>30 = Utf8               value</span><br><span class="line"><span class="meta">  #</span>31 = Utf8               hello world</span><br><span class="line"><span class="meta">  #</span>32 = NameAndType        #14:#15        // "&lt;init&gt;":()V</span><br><span class="line"><span class="meta">  #</span>33 = Utf8               sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line"><span class="meta">  #</span>34 = Utf8               true</span><br><span class="line"><span class="meta">  #</span>35 = Class              #48            // java/lang/System</span><br><span class="line"><span class="meta">  #</span>36 = NameAndType        #49:#50        // setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>37 = Utf8               com/phicomm/annotation/TestMain</span><br><span class="line"><span class="meta">  #</span>38 = Utf8               com/phicomm/annotation/HelloAnnotation</span><br><span class="line"><span class="meta">  #</span>39 = Class              #51            // java/lang/Class</span><br><span class="line"><span class="meta">  #</span>40 = NameAndType        #52:#53        // getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line"><span class="meta">  #</span>41 = NameAndType        #54:#55        // out:Ljava/io/PrintStream;</span><br><span class="line"><span class="meta">  #</span>42 = NameAndType        #56:#57        // getClass:()Ljava/lang/Class;</span><br><span class="line"><span class="meta">  #</span>43 = NameAndType        #58:#59        // getName:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>44 = Class              #60            // java/io/PrintStream</span><br><span class="line"><span class="meta">  #</span>45 = NameAndType        #61:#62        // println:(Ljava/lang/String;)V</span><br><span class="line"><span class="meta">  #</span>46 = NameAndType        #30:#59        // value:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>47 = Utf8               java/lang/Object</span><br><span class="line"><span class="meta">  #</span>48 = Utf8               java/lang/System</span><br><span class="line"><span class="meta">  #</span>49 = Utf8               setProperty</span><br><span class="line"><span class="meta">  #</span>50 = Utf8               (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>51 = Utf8               java/lang/Class</span><br><span class="line"><span class="meta">  #</span>52 = Utf8               getAnnotation</span><br><span class="line"><span class="meta">  #</span>53 = Utf8               (Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line"><span class="meta">  #</span>54 = Utf8               out</span><br><span class="line"><span class="meta">  #</span>55 = Utf8               Ljava/io/PrintStream;</span><br><span class="line"><span class="meta">  #</span>56 = Utf8               getClass</span><br><span class="line"><span class="meta">  #</span>57 = Utf8               ()Ljava/lang/Class;</span><br><span class="line"><span class="meta">  #</span>58 = Utf8               getName</span><br><span class="line"><span class="meta">  #</span>59 = Utf8               ()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>60 = Utf8               java/io/PrintStream</span><br><span class="line"><span class="meta">  #</span>61 = Utf8               println</span><br><span class="line"><span class="meta">  #</span>62 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.phicomm.annotation.TestMain();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/phicomm/annotation/TestMain;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: ldc           #2                  // String sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line">         2: ldc           #3                  // String true</span><br><span class="line">         4: invokestatic  #4                  // Method java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">         7: pop</span><br><span class="line">         8: ldc           #5                  // class com/phicomm/annotation/TestMain</span><br><span class="line">        10: ldc           #6                  // class com/phicomm/annotation/HelloAnnotation</span><br><span class="line">        12: invokevirtual #7                  // Method java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line">        15: checkcast     #6                  // class com/phicomm/annotation/HelloAnnotation</span><br><span class="line">        18: astore_1</span><br><span class="line">        19: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        22: aload_1</span><br><span class="line">        23: invokevirtual #9                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">        26: invokevirtual #10                 // Method java/lang/Class.getName:()Ljava/lang/String;</span><br><span class="line">        29: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        32: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        35: aload_1</span><br><span class="line">        36: invokeinterface #12,  1           // InterfaceMethod com/phicomm/annotation/HelloAnnotation.value:()Ljava/lang/String;</span><br><span class="line">        41: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        44: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 8</span><br><span class="line">        line 10: 19</span><br><span class="line">        line 11: 32</span><br><span class="line">        line 12: 44</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      45     0  args   [Ljava/lang/String;</span><br><span class="line">           19      26     1 helloAnnotation   Lcom/phicomm/annotation/HelloAnnotation;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: "TestMain.java"</span><br><span class="line">RuntimeVisibleAnnotations:</span><br><span class="line">  0: #26(#30=s#31)</span><br></pre></td></tr></table></figure></p><p>从上面可以看到如下的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#30 = Utf8               value</span><br><span class="line">#31 = Utf8               hello world</span><br></pre></td></tr></table></figure></p><p>可以看到#31与var3的31对应（也就是常量池的索引），对应的值解释hello world。这就是value()方法的调用细节。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注解本质上是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke()方法。该方法会从memerValues这里Map中索引出对应的值（这个map结构中自定义注解中的方法名作为key值，value值是方法的返回值）。而memberValues的来源是Java常量池。而给类添加的注解最终体现在类的字节码文件上面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是注解&quot;&gt;&lt;a href=&quot;#1-什么是注解&quot; class=&quot;headerlink&quot; title=&quot;1.什么是注解&quot;&gt;&lt;/a&gt;1.什么是注解&lt;/h3&gt;&lt;p&gt;注解是JDK1.5的一个新特性，注解是插入你代码中的一种注释或者说是一种元数据（meta data）
      
    
    </summary>
    
      <category term="Java语言学习" scheme="http://yoursite.com/categories/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>模板方法模式模式</title>
    <link href="http://yoursite.com/2018/08/17/designpattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/17/designpattern/模板方法模式/</id>
    <published>2018-08-17T15:19:19.000Z</published>
    <updated>2018-09-10T02:20:34.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA设计模式" scheme="http://yoursite.com/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
