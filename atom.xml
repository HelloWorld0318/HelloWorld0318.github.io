<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挥斥方遒</title>
  
  <subtitle>CODING MY AMBITION</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-05T03:22:15.342Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>挥斥方遒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Spark Streaming+Canal+Kafka对Mysql增量数据实时进行检测分析</title>
    <link href="http://yoursite.com/2019/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%9F%BA%E4%BA%8ESpark-Streaming-Canal-Kafka%E5%AF%B9Mysql%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/05/大数据/基于Spark-Streaming-Canal-Kafka对Mysql增量数据实时进行检测分析/</id>
    <published>2019-08-05T03:22:15.000Z</published>
    <updated>2019-08-05T03:22:15.342Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题分类</title>
    <link href="http://yoursite.com/2019/08/01/LeetCode%E5%88%B7%E9%A2%98%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/08/01/LeetCode刷题分类/</id>
    <published>2019-08-01T08:01:11.000Z</published>
    <updated>2019-08-01T08:01:11.048Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM内存空间划分与作用详解</title>
    <link href="http://yoursite.com/2019/08/01/jvm/JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/08/01/jvm/JVM内存空间划分与作用详解/</id>
    <published>2019-08-01T03:57:26.000Z</published>
    <updated>2019-08-06T15:34:46.071Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名Java程序员，在编写程序时除了尽情发挥Java的各种优势外，还应该去了解和思考一下Java技术体系中这些技术特征是如何实现的。</p><p>一旦使用了关键字strictfp来生明某个类，接口或者方法时，那么在这个关键字声明的范围内的所有浮点运算都是精确的，符合ieee-754标准。</p><p>JDK1.5在Java语法的易用性上面做出了非常大的改进。例如：自动装箱、范型、动态注解、枚举、可变长参数、遍历循环（foreach循环）等语法特性都是在JDK1.5中加入的。</p><p>HotSpot VM的热点代码探测能力可以通过执行计数器找到最具有编译价值的代码，然后通过JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无需等待本地代码输出才能执行程序，即使编译的时间压力也相对减少，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。</p><p>模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。站在整个软件工业化的高度来看，模块化是建立各种功能的标准件的前提。</p><h3 id="Java内存模块图"><a href="#Java内存模块图" class="headerlink" title="Java内存模块图"></a>Java内存模块图</h3><h3 id="各区域介绍"><a href="#各区域介绍" class="headerlink" title="各区域介绍"></a>各区域介绍</h3><h3 id="JDK1-8以后的JVM内存模块图"><a href="#JDK1-8以后的JVM内存模块图" class="headerlink" title="JDK1.8以后的JVM内存模块图"></a>JDK1.8以后的JVM内存模块图</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。<br>程序计数器处于线程独占区。<br>如果线程执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果只在执行的是native方法，这个计数器的值为undefined<br>此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>虚拟机栈描述的是Java方法执行的动态内存模型。<br>帧栈<br>    每个方法执行，都会创建一个帧栈，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等。</p><p>局部变量表<br>    存放编译器可知的各种基本数据类型，引用类型，returnAddress类型<br>    局部变量表的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多少内存时固定的，在方法运行期间时不会改变局部变量表的大小<br>大小</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>虚拟机栈为虚拟机执行Java方法服务。<br>本地方法栈为虚拟机执行native方法服务。<br>HostSpot虚拟机不区分本地方法栈和虚拟机栈</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>存放对象实例<br>垃圾收集器管理的主要区域<br>新生代，老年代</p><h3 id="OOM分析"><a href="#OOM分析" class="headerlink" title="OOM分析"></a>OOM分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名Java程序员，在编写程序时除了尽情发挥Java的各种优势外，还应该去了解和思考一下Java技术体系中这些技术特征是如何实现的。&lt;/p&gt;
&lt;p&gt;一旦使用了关键字strictfp来生明某个类，接口或者方法时，那么在这个关键字声明的范围内的所有浮点运算都是精确的，符合i
      
    
    </summary>
    
      <category term="深入理解JVM" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>69.sqrt(x)</title>
    <link href="http://yoursite.com/2018/09/15/leetcode/69-sqrt-x/"/>
    <id>http://yoursite.com/2018/09/15/leetcode/69-sqrt-x/</id>
    <published>2018-09-15T14:44:39.000Z</published>
    <updated>2018-09-16T01:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">Sqrt(x)(难度级别：easy)</a><br><strong>Description</strong>:<br>Implement int sqrt(int x).<br>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.<br>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.<br><strong>Example 1</strong>:<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure></p><h3 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h3><p>虽然这道题的难度级别只有easy，但是个人觉得还是一个非常有意思的题目。解题方法就是用“二分查找”的思想。还有一点需要注意的是，如果你用乘法，可能会出现超过int范围值的问题。具体解题代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Title</span>: mySqrt </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span>: Compute and return the square root of x</span></span><br><span class="line"><span class="comment">  * (采用二分查找的思路)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x x是一个整数，并且非负</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> int  x的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> end = x / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> lastMedium = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line"><span class="keyword">int</span> medium = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x / medium &gt; medium) &#123;<span class="comment">// 注意这里不要用乘法</span></span><br><span class="line">start = medium + <span class="number">1</span>;</span><br><span class="line">lastMedium = medium;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x / medium &lt; medium) &#123;</span><br><span class="line">end = medium - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> medium;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastMedium;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sqrtx/description/&quot; tar
      
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>AOP以及自己实现一个AOP</title>
    <link href="http://yoursite.com/2018/09/14/spring/AOP%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAOP/"/>
    <id>http://yoursite.com/2018/09/14/spring/AOP以及自己实现一个AOP/</id>
    <published>2018-09-14T07:22:49.000Z</published>
    <updated>2018-09-15T03:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP(面向对象编程)的延续。是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>在AOP中，采用了横向抽取机制，取代了传统纵向继承体系重复性代码。<br>AOP的经典应用有事务管理，性能监视，安全检查，缓存，日志等。</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p><img src="/img/spring/aop1.jpg" alt><br>1.目标类(Target)：需要被代理的对象。例如：UserService<br>2.连接点(JoinPoint):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法。<br>3.切入点(PointCut)：已经被增强的连接点。例如：addUser()，注意，切入点是连接点的子集。<br>4.通知(Advice)：通知/增强，增强代码。例如：after,before。<br>5.代理(Proxy)：代理类<br>6.织入（Warve）：是指把增强advice应用到目标对象target来创建新的代理对象Proxy的过程<br>7.切面(Aspect)：是切入点pointcut和通知advice的结合<br>一个线是一个特殊的面。一个切入点和一个通知，组成一个特殊的面。</p><h3 id="采用JDK的动态代理实现AOP"><a href="#采用JDK的动态代理实现AOP" class="headerlink" title="采用JDK的动态代理实现AOP"></a>采用JDK的动态代理实现AOP</h3><p>利用Proxy实现AOP的主要步骤如下：<br>（1）创建接口<br>（2）创建接口实现类<br>（3）创建代理工厂类</p><h4 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建接口的实现类"><a href="#创建接口的实现类" class="headerlink" title="创建接口的实现类"></a>创建接口的实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiveImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"新增用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建代理工厂类"><a href="#创建代理工厂类" class="headerlink" title="创建代理工厂类"></a>创建代理工厂类</h4><p>增强代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogAdvice</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在方法开始前开启日志</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logStart</span><span class="params">(Method method)</span></span>;</span><br><span class="line"><span class="comment">// 在方法结束侯关闭日历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增强代码的实现类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdviceImpl</span> <span class="keyword">implements</span> <span class="title">LogAdvice</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method name "</span> + method.getName() + <span class="string">"start"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method name"</span> + method.getName() + <span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建代理工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object advice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyBean</span><span class="params">(Object target,Object advice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line"><span class="keyword">this</span>.advice = advice;</span><br><span class="line">LogAdvice logAdvice = <span class="keyword">new</span> LogAdviceImpl();</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(ProxyFactory.class.getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Method logStart = advice.getClass().getDeclaredMethod(<span class="string">"logStart"</span>,Method.class);</span><br><span class="line">logStart.invoke(advice,method);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">Method logEnd = advice.getClass().getDeclaredMethod(<span class="string">"logEnd"</span>, Method.class);</span><br><span class="line">logEnd.invoke(advice, method);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">UserService userService = (UserService) proxyFactory.getProxyBean(</span><br><span class="line"><span class="keyword">new</span> UserServiveImpl(), <span class="keyword">new</span> LogAdviceImpl());</span><br><span class="line">userService.addUser();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method name addUser log start</span><br><span class="line">新增用户</span><br><span class="line">method nameaddUser log end</span><br></pre></td></tr></table></figure></p><h3 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h3><p>利用Proxy实现AOP功能的总结如下：<br>（1）目标类必须时间接口<br>（2）返回创建的代理对象<br>（3）重写InvocationHandler里面的invoke()方法<br>（4）限制条件放在invoke()方法中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AOP概述&quot;&gt;&lt;a href=&quot;#AOP概述&quot; class=&quot;headerlink&quot; title=&quot;AOP概述&quot;&gt;&lt;/a&gt;AOP概述&lt;/h3&gt;&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为:面向切面编程，通过预编译方式和
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring中bean的生命周期</title>
    <link href="http://yoursite.com/2018/09/07/spring/Spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/09/07/spring/Spring中bean的生命周期/</id>
    <published>2018-09-07T12:18:18.000Z</published>
    <updated>2018-09-15T02:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring中bean的生命周期"><a href="#Spring中bean的生命周期" class="headerlink" title="Spring中bean的生命周期"></a>Spring中bean的生命周期</h3><blockquote><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。<br>相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图为一个典型的bean装载到Springy应用上下文中的一个典型的生命周期过程。</p></blockquote><p><img src="/img/spring/spring-bean-lifecycle.jpg" alt><br>（1）实例化Bean<br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用creatBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。<br>容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。<br>实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。<br>（2）设置对象属性（DI）<br>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。<br>紧接着，Spring根据BeanDefinition中的信息进行依赖注入。<br>并且根据BeanWrapper提供的设置属性的接口完成依赖注入。<br>（3）注入Aware接口<br>紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。<br>（4）BeanPostProcessor<br>当经过上述几个步骤后，bean对象已经被正确构造了，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。<br>postProcessBeforeInitialization(Object bean,String beanName):当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会先于InitializationBean执行，因此称为前置处理。所有Aware接口的注入就是在这一步完成的。<br>postProcessAfterInitialization(Object bean,String beanName):当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会在InitializationBean完成后执行，因此称为后置处理。<br>（5）InitializingBean与init-method<br>当BeanPostProcessor的前置处理完成后就会进行本阶段。InitializingBean接口只有一个函数：afterPropertiesSet()<br>这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在一步没办法处理对象本身，只能增加一些额外的逻辑。若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet()函数。<br>当然，Spring为了降低对客户端代码的侵入性，给bean的配置提供了init-method属性，该属性指定在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上任然使用了InitializingBean接口。<br>（6）DisposableBean的destroy-method<br>和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>需要Spring创建的bean实例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第一步：bean被实例化,调用Person类的构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第二步：通过set方法去填充属性"</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第三步：调用BeanNameAware的setBeanName(),beanName:"</span> + beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">"第五步：ApplicationContextAware的setApplicationContext()方法被调用,这样该Bean就获得了自己所在的ApplicationContext"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第七步：InitializingBean的afterPropertiesSet()方法被调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第八步：Bean配置了init-method方法，则会执行init-method配置的方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第十步：调用DisposableBean的destory()方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的销毁方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第十一步：自定义的销毁方法myDestroy被调用"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"name is :"</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyBeanPostProcessor实现BeanPostProcessor接口，重写里面的postProcessBeforeInitialization和postProcessAfterInitialization方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用"</span>);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法"</span>);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personId"</span> <span class="attr">class</span>=<span class="string">"com.phicomm.lifecycle.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInit"</span> <span class="attr">destroy-method</span>=<span class="string">"myDestroy"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"hellokitty"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"postProcessor"</span> <span class="attr">class</span>=<span class="string">"com.phicomm.lifecycle.MyBeanPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcPersonServiceTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始初始化容器"</span>);</span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/phicomm/lifecycle/applicationContext.xml"</span>);</span><br><span class="line">System.out.println(<span class="string">"xml加载完毕"</span>);</span><br><span class="line">        Person person1 = (Person) ac.getBean(<span class="string">"personId"</span>);</span><br><span class="line">        System.out.println(person1);        </span><br><span class="line">        System.out.println(<span class="string">"关闭容器"</span>);</span><br><span class="line">        ((ClassPathXmlApplicationContext)ac).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行的结果的如下，符合Spring bean的生命周期中的各个步骤<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">开始初始化容器</span><br><span class="line">九月 15, 2018 9:43:42 上午 org.springframework.context.support.AbstractApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3eb07fd3: startup date [Sat Sep 15 09:43:42 CST 2018]; root of context hierarchy</span><br><span class="line">九月 15, 2018 9:43:42 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</span><br><span class="line">信息: Loading XML bean definitions from class path resource [com/phicomm/lifecycle/applicationContext.xml]</span><br><span class="line">第一步：bean被实例化,调用Person类的构造方法</span><br><span class="line">第二步：通过set方法去填充属性</span><br><span class="line">第三步：调用BeanNameAware的setBeanName(),beanName:personId</span><br><span class="line">第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory</span><br><span class="line">第五步：ApplicationContextAware的setApplicationContext()方法被调用,这样该Bean就获得了自己所在的ApplicationContext</span><br><span class="line">第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用</span><br><span class="line">com.phicomm.lifecycle.Person</span><br><span class="line">第七步：InitializingBean的afterPropertiesSet()方法被调用</span><br><span class="line">第八步：Bean配置了init-method方法，则会执行init-method配置的方法</span><br><span class="line">第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法</span><br><span class="line">xml加载完毕</span><br><span class="line">name is :hellokitty</span><br><span class="line">关闭容器</span><br><span class="line">九月 15, 2018 9:43:42 上午 org.springframework.context.support.AbstractApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@3eb07fd3: startup date [Sat Sep 15 09:43:42 CST 2018]; root of context hierarchy</span><br><span class="line">第十步：调用DisposableBean的destory()方法</span><br><span class="line">第十一步：自定义的销毁方法myDestroy被调用</span><br></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>（1）如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个protype bean的整个生命周期负责：容器在初始化，配置，装饰或者装配完一个prototype实例后，将它交个客户端，随后就对该prototype实例不闻不问了。<br>（2）BeanFactory容器中，B与ApplicationContext相比，有如下几点不同：<br>1、BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法；<br>2、BeanPostProcessor接口的postProcessBeforeInitialization()<br>方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册;<br>3、BeanFactory容器启动的时候，不会去实例化所有的Bean，包括所有scope为Sinleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。<br>BeanFactory的示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BfPersonServiceTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始初始化容器"</span>);</span><br><span class="line">ConfigurableBeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(</span><br><span class="line"><span class="keyword">new</span> ClassPathResource(<span class="string">"com/phicomm/lifecycle/applicationContext.xml"</span>));</span><br><span class="line">System.out.println(<span class="string">"xml加载完毕"</span>);</span><br><span class="line"><span class="comment">// beanFactory需要手动注册beanPostProcessor类的方法</span></span><br><span class="line">bf.addBeanPostProcessor(<span class="keyword">new</span> MyBeanPostProcessor());</span><br><span class="line">Person person1 = (Person) bf.getBean(<span class="string">"personId"</span>);</span><br><span class="line">System.out.println(person1);</span><br><span class="line">System.out.println(<span class="string">"关闭容器"</span>);</span><br><span class="line">bf.destroySingletons();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">开始初始化容器</span><br><span class="line">九月 15, 2018 9:58:02 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</span><br><span class="line">信息: Loading XML bean definitions from class path resource [com/phicomm/lifecycle/applicationContext.xml]</span><br><span class="line">xml加载完毕</span><br><span class="line">第一步：bean被实例化,调用Person类的构造方法</span><br><span class="line">第二步：通过set方法去填充属性</span><br><span class="line">第三步：调用BeanNameAware的setBeanName(),beanName:personId</span><br><span class="line">第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory</span><br><span class="line">第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用</span><br><span class="line">第七步：InitializingBean的afterPropertiesSet()方法被调用</span><br><span class="line">第八步：Bean配置了init-method方法，则会执行init-method配置的方法</span><br><span class="line">第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法</span><br><span class="line">name is :hellokitty</span><br><span class="line">关闭容器</span><br><span class="line">第十步：调用DisposableBean的destory()方法</span><br><span class="line">第十一步：自定义的销毁方法myDestroy被调用</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring中bean的生命周期&quot;&gt;&lt;a href=&quot;#Spring中bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring中bean的生命周期&quot;&gt;&lt;/a&gt;Spring中bean的生命周期&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>redis集群搭建</title>
    <link href="http://yoursite.com/2018/08/24/redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/08/24/redis集群搭建/</id>
    <published>2018-08-24T07:58:31.000Z</published>
    <updated>2018-08-24T08:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h3><h3 id="redis-cluster架构图"><a href="#redis-cluster架构图" class="headerlink" title="redis-cluster架构图"></a>redis-cluster架构图</h3><h3 id="redis-cluster图片-容错"><a href="#redis-cluster图片-容错" class="headerlink" title="redis-cluster图片-容错"></a>redis-cluster图片-容错</h3><h3 id="redis-cluster搭建过程"><a href="#redis-cluster搭建过程" class="headerlink" title="redis-cluster搭建过程"></a>redis-cluster搭建过程</h3><h3 id="添加Master节点"><a href="#添加Master节点" class="headerlink" title="添加Master节点"></a>添加Master节点</h3><h3 id="删除Master节点"><a href="#删除Master节点" class="headerlink" title="删除Master节点"></a>删除Master节点</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis的主从复制&quot;&gt;&lt;a href=&quot;#redis的主从复制&quot; class=&quot;headerlink&quot; title=&quot;redis的主从复制&quot;&gt;&lt;/a&gt;redis的主从复制&lt;/h3&gt;&lt;h3 id=&quot;redis-cluster架构图&quot;&gt;&lt;a href=&quot;#redis
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://yoursite.com/2018/08/17/designpattern/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/17/designpattern/装饰模式/</id>
    <published>2018-08-17T15:19:19.000Z</published>
    <updated>2018-09-11T08:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="装饰模式的动机和定义"><a href="#装饰模式的动机和定义" class="headerlink" title="装饰模式的动机和定义"></a>装饰模式的动机和定义</h3><h4 id="装饰模式的动机"><a href="#装饰模式的动机" class="headerlink" title="装饰模式的动机"></a>装饰模式的动机</h4><p>一般有两种方式可以实现给一个类或对象增加行为：<br>（1）继承机制：使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方式是静态的，用户不能控制增加行为的方法和时机。<br>（2）关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器（Decorator）。</p><h4 id="装饰模式的定义"><a href="#装饰模式的定义" class="headerlink" title="装饰模式的定义"></a>装饰模式的定义</h4><blockquote><p>装饰模式可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。<br>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.[GOF]<br>装饰模式可以在无需创建子类的情况下扩展类的功能。在对象功能扩展方面，它比继承更有弹性。</p></blockquote><p>装饰模式的类图如下所示：<br><img src="/img/Decorator/Decorator.png" alt><br>Component：抽象构件<br>ConcreteComponent：具体构件<br>Decorator：抽象装饰类，维持一个指向Component对象的指针或引用，并定义一个与Component接口一致的接口。Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。<br>ConcreteDecorator：具体装饰类</p><h3 id="装饰模式实例演示"><a href="#装饰模式实例演示" class="headerlink" title="装饰模式实例演示"></a>装饰模式实例演示</h3><p>通俗来讲，装饰模式就像打包一个快递。现在以一个具体的情景来说明装饰模式。<br>现实的发票有三部分组成：头部分，主体部分（数据部分），尾部分；不同的对象打印出来的头和尾是不一样的，但是主体部分是一样，要实现这样的需求，就应该采用装饰模式，下面是UML图：<br><img src="/img/Decorator/printer.png" alt><br>参照上图可知装饰模式的各种角色有：<br>(1)抽象构建角色（IPrintable）：定义一个抽象接口，以规范准备接受附加责任的对象。<br>(2)具体构件角色（Order）：这是被装饰者，定义一个将要被装饰模式增加功能的类。<br>(3)装饰角色（OrderDecorator）:持有一个构件对象的实例，并定义了抽象构件定义的接口。<br>(4)具体装饰角色（HeaderDecorator FooterDecorator）：负责给构件添加增加的功能。<br>首先，设计客户端使用的接口，在此例中即IPrintable，设计此接口的目的是对下面的实现类和各种装饰类加以抽象，方便客户端统一使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个有打印方法的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPrintable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 接口打印方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设计一个实现类可供客户端使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">IPrintable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发票的主题内容"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在开始设计具有真正功能的装饰类之前，先来考虑一下实现的问题。假设有很多装饰类被设计出来，在这些类中一定会有两类代码存在，一类是装饰上的功能代码，在此例中比如打印头部和尾部的代码；另一类是调用被装饰对象的功能代码，在此例中就是Order类的print()方法。<br>在这两类方法中，第一类代码是不重复的，每个类各不一样，但是第二类代码在这些类中却完全一样，这违背了“不要重复自己（Don’t Repeat Youself）DRY”原则，所以在这里需要设计一个所有装饰类的父类来改善这种设计。<br>发票装饰类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发票装饰抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDecorator</span> <span class="keyword">implements</span> <span class="title">IPrintable</span></span>&#123;</span><br><span class="line"><span class="comment">// 用于装饰的私有对象</span></span><br><span class="line"><span class="keyword">private</span> IPrintable iprintable;</span><br><span class="line"><span class="comment">// 构造方法，使用时传入装饰对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderDecorator</span><span class="params">(IPrintable iprintable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.iprintable = iprintable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实现接口方法，注意此处调用装饰对象的对应方法</span></span><br><span class="line">iprintable.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以打印发票头部信息的类如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderDecorator</span> <span class="keyword">extends</span> <span class="title">OrderDecorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderDecorator</span><span class="params">(IPrintable iprintable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(iprintable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"打印发票头部"</span>);</span><br><span class="line"><span class="keyword">super</span>.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以打印发票尾部的类的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooterDecorator</span> <span class="keyword">extends</span> <span class="title">OrderDecorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FooterDecorator</span><span class="params">(IPrintable iprintable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(iprintable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.print();</span><br><span class="line">System.out.println(<span class="string">"打印发票尾部"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">IPrintable iprintable = <span class="keyword">new</span> Order();</span><br><span class="line">iprintable.print();</span><br><span class="line">System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">iprintable = <span class="keyword">new</span> FooterDecorator(iprintable);</span><br><span class="line">iprintable.print();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">iprintable = <span class="keyword">new</span> HeaderDecorator(iprintable);</span><br><span class="line">iprintable.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">发票的主体内容</span><br><span class="line">------------------------------</span><br><span class="line">发票的主体内容</span><br><span class="line">打印发票尾部</span><br><span class="line">------------------------------</span><br><span class="line">打印发票头部</span><br><span class="line">发票的主体内容</span><br><span class="line">打印发票尾部</span><br></pre></td></tr></table></figure></p><h3 id="JDK中装饰模式介绍"><a href="#JDK中装饰模式介绍" class="headerlink" title="JDK中装饰模式介绍"></a>JDK中装饰模式介绍</h3><p>在JDK中，有很多使用装饰模式的案例，如java.io包中对流的处理。</p><h4 id="Java的I-O中装饰模式的体现"><a href="#Java的I-O中装饰模式的体现" class="headerlink" title="Java的I/O中装饰模式的体现"></a>Java的I/O中装饰模式的体现</h4><p>在Java中流（Stream）是一种有序的字节数据对象。流又分为输入流（InputStream）和输出流（OutputStream）。输入流从外部资源（文件，内存，socket等）读入字节数据到Java对象；输出流则把Java对象（字节数据）写入到外部资源。<br>所有Java I/O都可归类以下两种：（1）字节数据输入输出I/O；（2）字符数据输入输出I/O。在下例中，只研究InputStream类的装饰模式，理解了这一种设计方式，其他的就很好理解了，因为它们的设计方式是很相似的。<br>Java中的I/O体现装饰模式的类图如下：<br><img src="/img/Decorator/fileDecorator.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此输入对象将被增加过滤功能</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法时传入被修饰对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DataInputStream的部分实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此可见，JDK中的装饰模式与标准的装饰模式的差别很小。</p><h4 id="编写自己的Java-I-O装饰者"><a href="#编写自己的Java-I-O装饰者" class="headerlink" title="编写自己的Java I/O装饰者"></a>编写自己的Java I/O装饰者</h4><p>假设现有我有如下的需求：需要将所有输入的字母装换成大写。<br>通过装饰者模式来实现的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">UpperCaseInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个读取一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">super</span>.read();</span><br><span class="line"><span class="keyword">return</span> c == -<span class="number">1</span> ? c : Character.toUpperCase((<span class="keyword">char</span>) (c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次读取len长的字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="keyword">super</span>.read(b, offset, len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result; i++) &#123;</span><br><span class="line">b[i] = (<span class="keyword">byte</span>) Character.toUpperCase((<span class="keyword">char</span>) (b[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream in = <span class="keyword">new</span> UpperCaseInputStream(</span><br><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\test.txt"</span>)));</span><br><span class="line"><span class="keyword">while</span> ((c = in.read()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原始文件的内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>运行InputTest输出的代码如下：<br><img src="/img/Decorator/console.png" alt></p><h3 id="装饰着模式关键点"><a href="#装饰着模式关键点" class="headerlink" title="装饰着模式关键点"></a>装饰着模式关键点</h3><blockquote><p>装饰模式的作用是可以动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。<br>在实际应用中，装饰模式通常用做给现有的类增加功能，可以根据应用的需要，对装饰模式的类进行任意顺序的包装，最后生成符合要求的对象。注意传统的装饰模式的特点是聚合了被装饰类的接口。在使用上，如果每种装饰类可能抛出不同的异常，则要对异常进行特别处理。<br>开放-关闭原则的设计意义</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;装饰模式的动机和定义&quot;&gt;&lt;a href=&quot;#装饰模式的动机和定义&quot; class=&quot;headerlink&quot; title=&quot;装饰模式的动机和定义&quot;&gt;&lt;/a&gt;装饰模式的动机和定义&lt;/h3&gt;&lt;h4 id=&quot;装饰模式的动机&quot;&gt;&lt;a href=&quot;#装饰模式的动机&quot; class
      
    
    </summary>
    
      <category term="JAVA设计模式" scheme="http://yoursite.com/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>模板方法模式模式</title>
    <link href="http://yoursite.com/2018/08/17/designpattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/17/designpattern/模板方法模式/</id>
    <published>2018-08-17T15:19:19.000Z</published>
    <updated>2018-09-10T02:20:34.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA设计模式" scheme="http://yoursite.com/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>全面解析Java注解</title>
    <link href="http://yoursite.com/2018/08/17/Java/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/17/Java/注解的实现原理/</id>
    <published>2018-08-17T15:19:19.000Z</published>
    <updated>2018-09-04T11:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1.什么是注解"></a>1.什么是注解</h3><p>注解是JDK1.5的一个新特性，注解是插入你代码中的一种注释或者说是一种元数据（meta data），即一种描述数据的数据。所以，可以说注解就是源代码的元数据。这些注解信息可以在编译期使用预编译工具进行处理（pre-complier tools），也可以在运行期使用Java反射机制进行处理。<br>注解，其实就是对类，方法，属性进行一种标示，一种注释（注意，这个注释不是为了让我们开发或维护人员阅读更方便，而是为给JVM看），通过这些标示，JVM可以完成这些标示对应的功能。</p><h3 id="2-为什么要引入注解"><a href="#2-为什么要引入注解" class="headerlink" title="2.为什么要引入注解"></a>2.为什么要引入注解</h3><p>注解是JDK1.5引入的功能，但是为什么引入注解呢？在JDK1.5之前，Java还没有引入注解，这个时候如果我们要在Spring中声明一个Bean，我们只能通过xml配置的方式，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.phicomm.UserService"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是有了注解以后，我们可以不必写一个xml配置文件，可以直接在UserService类上完成Bean的声明工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于注解的开发方式。我们会发现它和代码结合的很紧密，所以注解比较适合做一些与代码相关度高的操作，例如将bean对应的服务暴露出去，<br>对于xml配置方式。我们会发现它将配置和代码隔离开来了所以XML配置更适合做一些全局的，与具体业务无关的操作。例如全局配置等。<br>基于注解开发还是XML的判断标准应该是：该配置与代码的相关度。如果代码与配置相关度高，那么使用注解配置，否则使用XML配置。</p><h3 id="3-JDK提供的注解"><a href="#3-JDK提供的注解" class="headerlink" title="3.JDK提供的注解"></a>3.JDK提供的注解</h3><p>JDK1.5版本在java.lang.annotation提供了四种元注解，专门注解其他的注解。<br><strong>@Documented</strong>：表示使用该注解的元素应被JavaDoc或类似工具文档化，它应用于类型声明，类型声明的注解会影响客户端对注解元素的使用。如果一个类型声明添加了Documented注解，那么它的注解会成为被注解元素的公共API的一部分。<br><strong>@Retention</strong>：定义该注解的生命周期，它接收RetentionPolicy参数。<br>RetentionPolicy.SOURCE：在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override，@SuppressWarning都属于这类注解。<br>RetentionPolicy.CLASS：在类加载的时候丢弃。在字节码文件的处理中有用。注释默认使用这种方式。<br>RetentionPolicy.RUNTIME：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。<br><strong>@Target</strong>：表示该注解用于什么地方。如果<strong>不明确指出，该注解可以放在任何地方</strong>。以下是一些可以用的参数。需要说明的是，属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。<br>ElementType.TYPE:用于描述类、接口或enum声明<br>ElementType.FIELD:用于描述实例变量<br>ElementType.METHOD<br>ElementType.PARAMETER<br>ElementType.CONSTRUCTOR<br>ElementType.LOCAL_VARIABLE<br>ElementType.ANNOTATION_TYPE 另一个注释<br>ElementType.PACKAGE 用于记录java文件的package信息<br><strong>@Inherited</strong>：表示一个注解类型会被自动继承，如果用户在类声明的时候查询注解类型，同时类声明中也没有这个类型的注解，那么注解类型会自动查询该类的父类，这个过程将会不停地重复，直到该类型的注解被找到为止，或是到达类结构的顶层（Object）。<br>JDK1.8加入了一种新的注解。<br><strong>@Repeatable</strong>：表示注解的值可以取多个。</p><p>JDK提供了五种内置注解：<br><strong>@Override</strong>：当我们想要覆盖父类的一个方法时，需要使用该注解告知编译器我们正在覆盖一个方法。这样的话，当父类的方法被删除或修改了，编译器会提示错误信息。<br><strong>@Deprecated</strong>：当我们想要让编译器知道一个方法已经被弃用（deprecate）时，应该使用这个注解。Java推荐在JavaDoc中提供信息，告知用户为什么这个方法被弃用，以及替代方法是什么。<br><strong>@SuppressWarning</strong>：这个注解仅仅告知编译器，忽略它们产生了特殊警告。比如，在Java泛型了使用原始类型。它的保持性策略是SOURCE，在编译器中将被丢弃。<br><strong>@SafeVarargs</strong>：参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作，它的存在会阻止编译器产生unchecked这样的警告。在JDK1.7中引入。<br><strong>@FunctionalInterfac</strong>e：函数式接口注解，这个是JDK1.8引入的。</p><h3 id="4-创建自定义的注解"><a href="#4-创建自定义的注解" class="headerlink" title="4.创建自定义的注解"></a>4.创建自定义的注解</h3><p>创建自定义注解需要注意如下：<br>（1）.注解方法不能有参数<br>（2）.注解方法的返回类型局限于原始类型，字符串，枚举，注解，或以上类型构成的数组<br>（3）.注解方法可以包含返回值<br>（4）.注解可以包含与其绑定的元注解，元注解为注解提供信息<br>（5）.如果只有一个参数成员，最好把参数名称设为“value”,后加小括号。<br>创建我们自定义的注解如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HelloAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "Hai"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用我们自己创建的注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HelloAnnotation</span>(say = <span class="string">"hello world"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HelloAnnotation helloAnnotation = TestMain.class.getAnnotation(HelloAnnotation.class);</span><br><span class="line">        System.out.println(helloAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的运行结果如下：<br><img src="/img/annotation0.jpg" alt></p><h3 id="5-注解的原理"><a href="#5-注解的原理" class="headerlink" title="5.注解的原理"></a>5.注解的原理</h3><h4 id="5-1-注解获得的具体对象是什么"><a href="#5-1-注解获得的具体对象是什么" class="headerlink" title="5.1 注解获得的具体对象是什么"></a>5.1 注解获得的具体对象是什么</h4><p>我们在TestMain类的main方法加入如下的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HelloAnnotation</span>(value = <span class="string">"hello world"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//运行时生成的动态代理对象是可以导出到文件的</span></span><br><span class="line">        System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        HelloAnnotation helloAnnotation = TestMain.class.getAnnotation(HelloAnnotation.class);</span><br><span class="line">        System.out.println(helloAnnotation.getClass().getName());</span><br><span class="line">        System.out.println(helloAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><img src="/img/annotation1.jpg" alt><br>而生成的动态代理类如下(省略到部分代码)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">HelloAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里生成的代理类重写了我们在注解中定义的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.phicomm.annotation.HelloAnnotation"</span>).getMethod(<span class="string">"value"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据“public final class $Proxy1 extends Proxy implements HelloAnnotation”这段代码，可以看出其实HelloAnnotation是一个接口。我们反编译HelloAnntation.class文件，得到如下的结果。<br><img src="/img/annotation3.jpg" alt><br>Java里面的Annotation的源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口Annotation被我们自定义的注解HelloAnnotation继承，而HelloAnnotation本质是一个接口，这个接口被代理类$Proxy1.java实现，而HelloAnnotation里面的方法都在$Proxy里面重写。这是JDK动态代理机制实现的。我们在TestMain获得的HelloAnnotation对象，就是由这个代理类生成的。</p><h4 id="5-2动态代理类-Proxy1是如何处理helloAnnotation-value-方法的调用的"><a href="#5-2动态代理类-Proxy1是如何处理helloAnnotation-value-方法的调用的" class="headerlink" title="5.2动态代理类$Proxy1是如何处理helloAnnotation.value()方法的调用的"></a>5.2动态代理类$Proxy1是如何处理helloAnnotation.value()方法的调用的</h4><p>熟悉JDK的动态代理一定会涉及到InvocationHandler，而annotation.value()方法的调用一定是通过绑定在InvocationHandler实例的invoke方法上，通过method.invoke()这种形式调用的。我们下面讲解这部分内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">HelloAnnotation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由多态的知识我们知道，helloAnnotation.value()的调用最终会转移到代理类$Proxy重写的value()方法上面，最终执行的代码是(String)super.h.invoke(this, m3, (Object[])null);那这里的InvocationHandler的实例是什么？<br>我们再Proxy的构造方法上面加断点，可以看出这里的InvocationHandler实例是AnnocationInvocationHandler的实例<br><img src="/img/annotation4.jpg" alt><br>而我们的helloAnnotation.value()方法是如何执行的？我们再AnnocationInvocationHandler.java的invoke()方法上加断点单步调试。<br><img src="/img/annotation5.jpg" alt><br>从上图可以看到，value()方法的返回值是从LinkedHashMap里面获得的。这个map结构的key值是方法名，value值是方法的返回值。我们一步步看这个LinkedHashMap结构是如何构造的。<br><img src="/img/annotation6.jpg" alt><br>这个LinkedHashMap是在AnnotationParser类的parseAnnotation2方法中构建的。我们单步调试进入parseNumberValue()方法内部<br><img src="/img/annotation7.png" alt><br><img src="/img/annotation8.png" alt><br><img src="/img/annotation9.png" alt><br>反编译TestMain.class的内容，我们获得了如下内容<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/reflectStudy/out/production/reflectStudy/com/phicomm/annotation/TestMain.class</span><br><span class="line">  Last modified 2018-8-18; size 1125 bytes</span><br><span class="line">  MD5 checksum b6f5e94bc326b15093fbf4b43283ff86</span><br><span class="line">  Compiled from "TestMain.java"</span><br><span class="line">public class com.phicomm.annotation.TestMain</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta">   #</span>1 = Methodref          #13.#32        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line"><span class="meta">   #</span>2 = String             #33            // sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line"><span class="meta">   #</span>3 = String             #34            // true</span><br><span class="line"><span class="meta">   #</span>4 = Methodref          #35.#36        // java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"><span class="meta">   #</span>5 = Class              #37            // com/phicomm/annotation/TestMain</span><br><span class="line"><span class="meta">   #</span>6 = Class              #38            // com/phicomm/annotation/HelloAnnotation</span><br><span class="line"><span class="meta">   #</span>7 = Methodref          #39.#40        // java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line"><span class="meta">   #</span>8 = Fieldref           #35.#41        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="meta">   #</span>9 = Methodref          #13.#42        // java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line"><span class="meta">  #</span>10 = Methodref          #39.#43        // java/lang/Class.getName:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>11 = Methodref          #44.#45        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"><span class="meta">  #</span>12 = InterfaceMethodref #6.#46         // com/phicomm/annotation/HelloAnnotation.value:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>13 = Class              #47            // java/lang/Object</span><br><span class="line"><span class="meta">  #</span>14 = Utf8               &lt;init&gt;</span><br><span class="line"><span class="meta">  #</span>15 = Utf8               ()V</span><br><span class="line"><span class="meta">  #</span>16 = Utf8               Code</span><br><span class="line"><span class="meta">  #</span>17 = Utf8               LineNumberTable</span><br><span class="line"><span class="meta">  #</span>18 = Utf8               LocalVariableTable</span><br><span class="line"><span class="meta">  #</span>19 = Utf8               this</span><br><span class="line"><span class="meta">  #</span>20 = Utf8               Lcom/phicomm/annotation/TestMain;</span><br><span class="line"><span class="meta">  #</span>21 = Utf8               main</span><br><span class="line"><span class="meta">  #</span>22 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line"><span class="meta">  #</span>23 = Utf8               args</span><br><span class="line"><span class="meta">  #</span>24 = Utf8               [Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>25 = Utf8               helloAnnotation</span><br><span class="line"><span class="meta">  #</span>26 = Utf8               Lcom/phicomm/annotation/HelloAnnotation;</span><br><span class="line"><span class="meta">  #</span>27 = Utf8               SourceFile</span><br><span class="line"><span class="meta">  #</span>28 = Utf8               TestMain.java</span><br><span class="line"><span class="meta">  #</span>29 = Utf8               RuntimeVisibleAnnotations</span><br><span class="line"><span class="meta">  #</span>30 = Utf8               value</span><br><span class="line"><span class="meta">  #</span>31 = Utf8               hello world</span><br><span class="line"><span class="meta">  #</span>32 = NameAndType        #14:#15        // "&lt;init&gt;":()V</span><br><span class="line"><span class="meta">  #</span>33 = Utf8               sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line"><span class="meta">  #</span>34 = Utf8               true</span><br><span class="line"><span class="meta">  #</span>35 = Class              #48            // java/lang/System</span><br><span class="line"><span class="meta">  #</span>36 = NameAndType        #49:#50        // setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>37 = Utf8               com/phicomm/annotation/TestMain</span><br><span class="line"><span class="meta">  #</span>38 = Utf8               com/phicomm/annotation/HelloAnnotation</span><br><span class="line"><span class="meta">  #</span>39 = Class              #51            // java/lang/Class</span><br><span class="line"><span class="meta">  #</span>40 = NameAndType        #52:#53        // getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line"><span class="meta">  #</span>41 = NameAndType        #54:#55        // out:Ljava/io/PrintStream;</span><br><span class="line"><span class="meta">  #</span>42 = NameAndType        #56:#57        // getClass:()Ljava/lang/Class;</span><br><span class="line"><span class="meta">  #</span>43 = NameAndType        #58:#59        // getName:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>44 = Class              #60            // java/io/PrintStream</span><br><span class="line"><span class="meta">  #</span>45 = NameAndType        #61:#62        // println:(Ljava/lang/String;)V</span><br><span class="line"><span class="meta">  #</span>46 = NameAndType        #30:#59        // value:()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>47 = Utf8               java/lang/Object</span><br><span class="line"><span class="meta">  #</span>48 = Utf8               java/lang/System</span><br><span class="line"><span class="meta">  #</span>49 = Utf8               setProperty</span><br><span class="line"><span class="meta">  #</span>50 = Utf8               (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>51 = Utf8               java/lang/Class</span><br><span class="line"><span class="meta">  #</span>52 = Utf8               getAnnotation</span><br><span class="line"><span class="meta">  #</span>53 = Utf8               (Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line"><span class="meta">  #</span>54 = Utf8               out</span><br><span class="line"><span class="meta">  #</span>55 = Utf8               Ljava/io/PrintStream;</span><br><span class="line"><span class="meta">  #</span>56 = Utf8               getClass</span><br><span class="line"><span class="meta">  #</span>57 = Utf8               ()Ljava/lang/Class;</span><br><span class="line"><span class="meta">  #</span>58 = Utf8               getName</span><br><span class="line"><span class="meta">  #</span>59 = Utf8               ()Ljava/lang/String;</span><br><span class="line"><span class="meta">  #</span>60 = Utf8               java/io/PrintStream</span><br><span class="line"><span class="meta">  #</span>61 = Utf8               println</span><br><span class="line"><span class="meta">  #</span>62 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.phicomm.annotation.TestMain();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/phicomm/annotation/TestMain;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: ldc           #2                  // String sun.misc.ProxyGenerator.saveGeneratedFiles</span><br><span class="line">         2: ldc           #3                  // String true</span><br><span class="line">         4: invokestatic  #4                  // Method java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">         7: pop</span><br><span class="line">         8: ldc           #5                  // class com/phicomm/annotation/TestMain</span><br><span class="line">        10: ldc           #6                  // class com/phicomm/annotation/HelloAnnotation</span><br><span class="line">        12: invokevirtual #7                  // Method java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;</span><br><span class="line">        15: checkcast     #6                  // class com/phicomm/annotation/HelloAnnotation</span><br><span class="line">        18: astore_1</span><br><span class="line">        19: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        22: aload_1</span><br><span class="line">        23: invokevirtual #9                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">        26: invokevirtual #10                 // Method java/lang/Class.getName:()Ljava/lang/String;</span><br><span class="line">        29: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        32: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        35: aload_1</span><br><span class="line">        36: invokeinterface #12,  1           // InterfaceMethod com/phicomm/annotation/HelloAnnotation.value:()Ljava/lang/String;</span><br><span class="line">        41: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        44: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 8</span><br><span class="line">        line 10: 19</span><br><span class="line">        line 11: 32</span><br><span class="line">        line 12: 44</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      45     0  args   [Ljava/lang/String;</span><br><span class="line">           19      26     1 helloAnnotation   Lcom/phicomm/annotation/HelloAnnotation;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: "TestMain.java"</span><br><span class="line">RuntimeVisibleAnnotations:</span><br><span class="line">  0: #26(#30=s#31)</span><br></pre></td></tr></table></figure></p><p>从上面可以看到如下的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#30 = Utf8               value</span><br><span class="line">#31 = Utf8               hello world</span><br></pre></td></tr></table></figure></p><p>可以看到#31与var3的31对应（也就是常量池的索引），对应的值解释hello world。这就是value()方法的调用细节。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注解本质上是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke()方法。该方法会从memerValues这里Map中索引出对应的值（这个map结构中自定义注解中的方法名作为key值，value值是方法的返回值）。而memberValues的来源是Java常量池。而给类添加的注解最终体现在类的字节码文件上面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是注解&quot;&gt;&lt;a href=&quot;#1-什么是注解&quot; class=&quot;headerlink&quot; title=&quot;1.什么是注解&quot;&gt;&lt;/a&gt;1.什么是注解&lt;/h3&gt;&lt;p&gt;注解是JDK1.5的一个新特性，注解是插入你代码中的一种注释或者说是一种元数据（meta data）
      
    
    </summary>
    
      <category term="Java语言学习" scheme="http://yoursite.com/categories/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://yoursite.com/2018/08/16/designpattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/16/designpattern/代理模式/</id>
    <published>2018-08-16T15:19:19.000Z</published>
    <updated>2018-08-17T13:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式为其他对象提供一种代理以控制对这个对象的访问。（Provide a surrogate（代理） for another object to Control access to it[GOF]）<br>GOF所设计的代理模式结构图如下所示：<br><img src="/img/proxy pattern.png" alt><br><strong>Subject接口</strong>：定义了RealSubject和Proxy的共用接口，这样在任何使用RealSubject的地方都可以使用Proxy。<br><strong>RealSubject</strong>：定义Proxy可以代表的实体。<br><strong>Proxy</strong>：保存一个引用可以访问RealSubject实体。通常和RealSubject一样也实现了Subject接口，它控制着对Subject实体的访问，并能负责创建和销毁它。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。加入现在有如下需求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"tank moving...."</span>);</span><br><span class="line"><span class="comment">//      记录坦克移动的时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>问题1</strong>：现在我有个需求，我想获得一个方法的具体运行时间，如何实现？可能你会这回做<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"tank moving...."</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"time:"</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>问题2</strong>：假如你无法修改move()方法的源码，比如说这个方法是别人的jar包里面别人提供给你的，是已经写好的源代码，就编译了class给你，这个时候没有办法在源码的基础上面修改，你想计算这个方法运行了多长时间怎么办？<br>可能你会这么做，用继承的方式实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank2</span> <span class="keyword">extends</span> <span class="title">Tank</span> </span>&#123;</span><br><span class="line"><span class="comment">//继承的实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">super</span>.move();</span><br><span class="line"><span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">System.out.println(stop - start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可能会用聚合的方式实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank3</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"><span class="comment">//聚合的方式实现</span></span><br><span class="line"><span class="keyword">private</span> Tank tank;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tank3</span><span class="params">(Tank tank)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.tank = tank;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">tank.move();</span><br><span class="line"><span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">System.out.println(stop - start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>问题3</strong>：我想将功能在上面进行叠加，先记录日志，后记录时间，怎么处理？还是用继承？可能还要加权限的检查，你又怎么处理？<br>如果还用继承的方式实现，将出现的类爆炸，根本无法实行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankTimeProxy</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"><span class="comment">//聚合的方式实现</span></span><br><span class="line"><span class="keyword">private</span> Moveable moveable;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TankTimeProxy</span><span class="params">(Moveable moveable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.moveable = moveable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"开始时间："</span> + start);</span><br><span class="line">moveable.move();</span><br><span class="line"><span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"结束时间："</span> + stop);</span><br><span class="line">System.out.println(stop - start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于记录日志的代理类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankLogProxy</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"><span class="comment">//聚合的方式实现</span></span><br><span class="line"><span class="keyword">private</span> Moveable moveable;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TankLogProxy</span><span class="params">(Moveable moveable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.moveable = moveable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"日志记录，tank start"</span>);</span><br><span class="line">moveable.move();</span><br><span class="line">System.out.println(<span class="string">"日志记录，tank stop"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端这样调用就可以实现先记录时间，后记录日志的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Moveable moveable = <span class="keyword">new</span> Tank();</span><br><span class="line">TankLogProxy tankLogProxy = <span class="keyword">new</span> TankLogProxy(moveable);</span><br><span class="line">TankTimeProxy tankTimeProxy = <span class="keyword">new</span> TankTimeProxy(tankLogProxy);</span><br><span class="line">tankTimeProxy.move();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，聚合比继承要好用的多。通过代理之间的组合，可以将多种功能组合起来。</p><p><strong>问题4</strong>：假设Moveable接口里面有多个方法，怎么处理？假如我需要计算100类的中方法的计算时间，那么我们需要重新写100个代理类，代理类的数量也在无线的膨胀，这是一件无法忍受的事情。我们可以根据接口去生成代理对象，用动态代理去做。</p><h3 id="动态代理-你不必知道我存在"><a href="#动态代理-你不必知道我存在" class="headerlink" title="动态代理-你不必知道我存在"></a>动态代理-你不必知道我存在</h3><p>动态代理：在程序运行时，运行反射机制动态创建而成。动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。还有一种动态代理CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类实现代理。通过在运行时，动态修改字节码达到修改类的目的。</p><p><strong>模拟JDK的实现</strong><br>假设被代理的对象都实现了<strong>某个接口</strong>，代理的时候是根据接口生成代理对象（这里的接口我们选择自己创建的Moveable接口）。<br>我们自己创建的Proxy如下所示，专门用来生成记录时间的代理类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//根据这段源码动态编译出代理对象</span></span><br><span class="line">String src = </span><br><span class="line"><span class="string">"package com.phicomm.proxy;"</span> +</span><br><span class="line"><span class="string">"public class TankTimeProxy implements Moveable &#123;"</span>+</span><br><span class="line"><span class="string">"private Moveable moveable;"</span> +</span><br><span class="line"><span class="string">"public TankTimeProxy(Moveable moveable) &#123;"</span> +</span><br><span class="line"><span class="string">"super();"</span> + </span><br><span class="line"><span class="string">"this.moveable = moveable;"</span> +</span><br><span class="line"><span class="string">"&#125;"</span> +</span><br><span class="line"><span class="string">"@Override "</span> +</span><br><span class="line"><span class="string">"public void move() &#123;"</span> +</span><br><span class="line"><span class="string">"long start = System.currentTimeMillis();"</span> +</span><br><span class="line"><span class="string">"System.out.println(\"开始时间：\" + start);"</span> +</span><br><span class="line"><span class="string">"moveable.move();"</span> +</span><br><span class="line"><span class="string">"long stop = System.currentTimeMillis();"</span> +</span><br><span class="line"><span class="string">"System.out.println(\"结束时间：\" + stop);"</span>+</span><br><span class="line"><span class="string">"System.out.println(stop - start);"</span> +</span><br><span class="line"><span class="string">"&#125;"</span>  +</span><br><span class="line"><span class="string">"&#125;"</span>;</span><br><span class="line"><span class="comment">//写入源文件</span></span><br><span class="line">String fileName = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src/com/phicomm/proxy/TankTimeProxy.java"</span>;</span><br><span class="line">File f = <span class="keyword">new</span> File(fileName);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">fw.write(src);</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile</span></span><br><span class="line">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">StandardJavaFileManager fileMgr = compiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">Iterable units = fileMgr.getJavaFileObjects(fileName);</span><br><span class="line">CompilationTask t = compiler.getTask(<span class="keyword">null</span>, fileMgr, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, units);</span><br><span class="line">t.call();</span><br><span class="line">fileMgr.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// load into memory and create an instance</span></span><br><span class="line"><span class="comment">//解析本地的文件</span></span><br><span class="line">URL[] urls = <span class="keyword">new</span> URL[] &#123; <span class="keyword">new</span> URL(<span class="string">"file:/"</span> + System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/src"</span>) &#125;;</span><br><span class="line">URLClassLoader ul = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">Class c = ul.loadClass(<span class="string">"com.phicomm.proxy.TankTimeProxy"</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line">Constructor ctr = c.getConstructor(Moveable.class);</span><br><span class="line"><span class="keyword">return</span> ctr.newInstance(<span class="keyword">new</span> Tank());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再测试的时候，不用管代理类的类名，直接就可以通过自己写的Proxy获得代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Moveable moveable = (Moveable) Proxy.newProxyInstance();</span><br><span class="line">moveable.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就获得了可以记录坦克运行时间的代理类。<br><strong>问题5</strong>：<br>现在我产生的代理只能够去代理Moveable接口的这样一种代理，并且只有记录时间的功能。那我需要它实现其他功能怎么办？实现其他接口的代理怎么办？我们现在就完全模拟JDK的动态代理去实现。<br>我们自己设计InvocationHandler类如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> object 代理类的类名</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> method 被代理的对象实现的接口的方法实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object object,Method method)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>动态的代理类由如下的代码生成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.phicomm.realProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.tools.JavaCompiler;</span><br><span class="line"><span class="keyword">import</span> javax.tools.StandardJavaFileManager;</span><br><span class="line"><span class="keyword">import</span> javax.tools.ToolProvider;</span><br><span class="line"><span class="keyword">import</span> javax.tools.JavaCompiler.CompilationTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line"><span class="comment">//简单起见，这里只有一个接口，传入一个接口，而不是一个接口数组</span></span><br><span class="line"><span class="comment">//传入被代理的对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class infce,InvocationHandler handler)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">String rt = <span class="string">"\r\t"</span>;</span><br><span class="line">Method[] methods = infce.getMethods();</span><br><span class="line">String methodStr = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line"><span class="comment">//代理类重写接口里面的方法</span></span><br><span class="line">methodStr += <span class="string">"@Override"</span> + rt + </span><br><span class="line"> <span class="string">"public void "</span> + method.getName() + <span class="string">"() &#123;"</span> + rt +</span><br><span class="line"> <span class="string">"    try &#123;"</span> + rt +</span><br><span class="line"> <span class="string">"    Method md = "</span> + infce.getName() + <span class="string">".class.getMethod(\""</span> + method.getName() + <span class="string">"\");"</span> + rt +</span><br><span class="line"> <span class="string">"    h.invoke(this,md);"</span> + rt +</span><br><span class="line"> <span class="string">"    &#125;catch(Exception e) "</span>+ rt+ </span><br><span class="line"> <span class="string">"    &#123;e.printStackTrace();&#125;"</span> + rt +</span><br><span class="line"> <span class="string">"&#125;"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类的构造方法里面将被代理类的对象注入进去</span></span><br><span class="line">String src = </span><br><span class="line"><span class="string">"package com.phicomm.realProxy;"</span> + rt + </span><br><span class="line"><span class="string">"import java.lang.reflect.Method;"</span> + rt +</span><br><span class="line"><span class="string">"public class $Proxy1 implements "</span> + infce.getName() + <span class="string">"&#123;"</span> + rt +</span><br><span class="line"><span class="string">"    public $Proxy1(InvocationHandler h) &#123;"</span> + rt +</span><br><span class="line"><span class="string">"        this.h = h;"</span> + rt +</span><br><span class="line"><span class="string">"    &#125;"</span> + rt +</span><br><span class="line"><span class="string">"    com.phicomm.realProxy.InvocationHandler h;"</span> + rt +</span><br><span class="line">methodStr +</span><br><span class="line"><span class="string">"&#125;"</span>;</span><br><span class="line">String fileName = <span class="string">"d:/src/com/phicomm/realProxy/$Proxy1.java"</span>;</span><br><span class="line">File f = <span class="keyword">new</span> File(fileName);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">fw.write(src);</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br><span class="line"><span class="comment">// 生成代理类的字节码文件</span></span><br><span class="line">JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">StandardJavaFileManager fileMgr = compiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">Iterable units = fileMgr.getJavaFileObjects(fileName);</span><br><span class="line">CompilationTask t = compiler.getTask(<span class="keyword">null</span>, fileMgr, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, units);</span><br><span class="line">t.call();</span><br><span class="line">fileMgr.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// load into memory and create an instance</span></span><br><span class="line"><span class="comment">//解析本地的文件</span></span><br><span class="line">URL[] urls = <span class="keyword">new</span> URL[] &#123; <span class="keyword">new</span> URL(<span class="string">"file:/"</span> +  <span class="string">"d:/src/"</span>) &#125;;</span><br><span class="line">URLClassLoader ul = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">Class c = ul.loadClass(<span class="string">"com.phicomm.realProxy.$Proxy1"</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line">Constructor ctr = c.getConstructor(InvocationHandler.class);</span><br><span class="line"><span class="keyword">return</span> ctr.newInstance(handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终，自己写的代理类就完成了。<br>被代理的类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object object,Method method)</span> </span>&#123;</span><br><span class="line">System.out.println(object.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"开始记录时间"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">method.invoke(target);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"记录时间结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以用自己写的代理类去实现动态代理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//传入被代理的对象</span></span><br><span class="line">MyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> Tank());</span><br><span class="line">Moveable moveable = (Moveable) Proxy.newInstance(Moveable.class, myInvocationHandler);</span><br><span class="line">moveable.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在JDK的动态代理中，过程与上面类似。JDK最终生成的代理类的形式为</p><pre><code class="java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="title">extend</span> <span class="title">Proxy</span> <span class="title">implemnets</span> <span class="title">Moveable</span> </span>{...    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span>  </span>{        <span class="keyword">try</span> {<span class="comment">//         m3为m3 = Class.forName("com.phicomm.realProxy.Moveable").getMethod("move");</span><span class="comment">//        通过反射区获取</span><span class="comment">//        h为我们自己实现的MyInvocationHandler，this为生成的代理类对象$Proxy0，</span><span class="comment">//        最终调用的MyInvocationHandler里面的invoke()方法</span>            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>)        } <span class="keyword">catch</span> (RuntimeException | Error var2) {            <span class="keyword">throw</span> var2;        } <span class="keyword">catch</span> (Throwable var3) {            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);        }    }...}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式为其他对象提供一种代理以控制对这个对象的访问。（Provide a surrogate（代理） for another object to Control access to it[GOF]）&lt;br&gt;GOF所设计的代理模式结构图如下所示：&lt;br&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="JAVA设计模式" scheme="http://yoursite.com/categories/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Recover Binary Search Tree</title>
    <link href="http://yoursite.com/2018/03/03/leetcode/99.Recover%20Binary%20Search%20Tree/"/>
    <id>http://yoursite.com/2018/03/03/leetcode/99.Recover Binary Search Tree/</id>
    <published>2018-03-03T14:45:10.000Z</published>
    <updated>2018-09-15T13:05:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode.com/problems/recover-binary-search-tree/description/" target="_blank" rel="noopener">Recover Binary Search Tree(难度级别：Hard)</a></p><blockquote><p><strong>Description</strong>:<br>Two elements of a binary search tree (BST) are swapped by mistake.<br>Recover the tree without changing its structure.<br><strong>Example</strong>:<br>Example 1:<br><img src="/img/leetcode/99-1.jpg" alt><br>Example 2:<br><img src="/img/leetcode/99-2.jpg" alt><br><strong>Follow up</strong>:<br>A solution using O(n) space is pretty straight forward.<br>Could you devise a constant space solution?</p></blockquote><h3 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h3><h4 id="method0"><a href="#method0" class="headerlink" title="method0"></a>method0</h4><p>这道题最直观的解法就是：<br>二叉排序树中序遍历得到是有序的。中序遍历完一遍以后，重新赋值一遍即可。这个解法可以面向n个元素错位的情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: recoverTree </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: BST(Binary Search Tree)的两个元素被错误的交换，</span></span><br><span class="line"><span class="comment"> * 在不改变其结构的前     提下恢复树(一种很直观的解法,可针对任意数目</span></span><br><span class="line"><span class="comment"> * 的节点错乱的情况,该解法的空间复杂度为O(n))</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;TreeNode&gt; treeNodeList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; treeValueList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(root);</span><br><span class="line">Collections.sort(treeValueList);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; treeNodeList.size(); i++) &#123;</span><br><span class="line">treeNodeList.get(i).val = treeValueList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(root.left);</span><br><span class="line">treeNodeList.add(root);</span><br><span class="line">treeValueList.add(root.val);</span><br><span class="line">inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="method1"><a href="#method1" class="headerlink" title="method1"></a>method1</h4><p>采用双指针代替一维向量。但是这里用到了递归，空间复杂度也不是O(1)。这里需要三个指针，first,second分别表示第一个和第二个错乱位置的节点，pre指向当前节点的中序遍历的前一个节点。这里用传统的中序遍历来做，不过在应该输出节点值的地方，换成了判断pre和当前节点值的大小，如果pre的大，若first为空，则将first指向pre值的节点，把second指向当前节点。这样中序遍历完整个树，若first和second都存在，则交换它们节点值即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> TreeNode pre;<span class="comment">// 当前节点的中序遍历的前一个节点</span></span><br><span class="line"><span class="keyword">private</span> TreeNode first;<span class="comment">// 第一个错乱位置的节点</span></span><br><span class="line"><span class="keyword">private</span> TreeNode second;<span class="comment">// 第二个错乱位置的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: recoverTreeII</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: BST(Binary Search Tree)的两个元素被错误的交换，在不改变其结构的前提下恢复树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTreeII</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">pre = <span class="keyword">null</span>;</span><br><span class="line">first = <span class="keyword">null</span>;</span><br><span class="line">second = <span class="keyword">null</span>;</span><br><span class="line">inOrderII(root);</span><br><span class="line"><span class="keyword">if</span> (first != <span class="keyword">null</span> &amp;&amp; second != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = first.val;</span><br><span class="line">first.val = second.val;</span><br><span class="line">second.val = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderII</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">inOrderII(root.left);</span><br><span class="line"><span class="comment">// 这里用传统的中序遍历递归来做，不过在应该输出节点值的地方，换成了判断pre和当前节点值的大小。</span></span><br><span class="line"><span class="comment">// 如果pre的大，若first为空，则将first指向pre指的节点，把second指向当前节点。这样中序遍历</span></span><br><span class="line"><span class="comment">// 完整个树，若first和second都存在，则交换它们的节点值即可</span></span><br><span class="line"><span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">pre = root;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pre.val &gt; root.val) &#123;</span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = pre;</span><br><span class="line">&#125;</span><br><span class="line">second = root;</span><br><span class="line">&#125;</span><br><span class="line">pre = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inOrderII(root.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="method2"><a href="#method2" class="headerlink" title="method2"></a>method2</h4><p>前两种方法都涉及到了递归操作，所以这两种方法的空间复杂度都要高于O(n)。为了达到O(n)的时间复杂度，其实这道题的解法是需要你了解二叉树的marris traversal遍历这种方法。这种遍历方法可以用O(1)的空间复杂度对二叉树进行遍历，是二叉树的一种非递归遍历方法。<br>这种方法应该是符合题目要求的解答。<br>这种解法后续看懂marris traversal的时候在补充。<br><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="noopener">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/recover-binary-search-t
      
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中switch具体实现细节</title>
    <link href="http://yoursite.com/2017/12/09/Java/Java%E4%B8%ADswitch%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2017/12/09/Java/Java中switch具体实现细节/</id>
    <published>2017-12-09T03:17:38.000Z</published>
    <updated>2018-09-03T15:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>switch case语句在很多编程语言中的功能都是等于条件判断，Java中为多路分支选择流程专门提供了switch语法，switch语句根据多个表达式的值，选择运行多个操作中的一个。当需要对选项进行等值判断时，使用switch语句更加简洁明了。switch的case语句可以处理int，short，byte，char类型的值。在JDK5以后可以是枚举类型，JDK7以后可以是String类型。但是，这里有个疑问，JDK5和JDK7以后，switch的语法为何可以使用非整形的类型。这篇文章主要揭开Java中当switch语句中的表达式为String和枚举的时候是如何处理的。</p><h3 id="Java中的switch的语法"><a href="#Java中的switch的语法" class="headerlink" title="Java中的switch的语法"></a>Java中的switch的语法</h3><p>switch的基本语法如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;  </span><br><span class="line"><span class="keyword">case</span> 表达式常量<span class="number">1</span>：语句<span class="number">1</span>； <span class="keyword">break</span>；  </span><br><span class="line"><span class="keyword">case</span> 表达式常量<span class="number">2</span>：语句<span class="number">2</span>； <span class="keyword">break</span>； </span><br><span class="line">......  </span><br><span class="line"><span class="keyword">case</span> 表达式常量n：语句n； <span class="keyword">break</span>；  </span><br><span class="line">[<span class="keyword">default</span>：语句n+<span class="number">1</span>；] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，一个case表达式常量成为标号，代表一个case分支的入口。switch语句在运行时首先计算switch圆括号中“表达式”的值，这个值必须是整形或字符串型的，同时后面各个case表达式常量的值的类型应与switch圆括号中“表达式”的值类型一致。一个case语句代表一个制定操作，然后转向结构出口。default子句是可选的，当表达式的值和case表达式常量的值都不匹配时，就运行default子句，转向结构出口。</p><h3 id="本质特征"><a href="#本质特征" class="headerlink" title="本质特征"></a>本质特征</h3><h4 id="当case表达式的类型是基本类型"><a href="#当case表达式的类型是基本类型" class="headerlink" title="当case表达式的类型是基本类型"></a>当case表达式的类型是基本类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">(<span class="keyword">int</span> caseNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (caseNumber) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">"您是通过搜索引擎来到本网站的。"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">"您是通过朋友介绍来到本网站的。"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(<span class="string">"您是通过报刊杂志来到本网站的。"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">System.out.println(<span class="string">"您是通过其它方法来到本网站的。"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"错误的选择！请输入１～４的数字做出选择。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break:break使得程序在执行完选中的分支后，可以跳出整个switch语句，完成switch。如果没有这个break，程序将在继续前进到下一个分支，直到遇到后面的break或者switch完成。<br>default:是可选的。如果没有default，程序在找不到匹配的case分支后，将在switch语句范围内不做什么事，直接完成switch。不过，无论default在switch语句中的哪个位置，JVM都会先找case，从第一个找到case开始执行，如果所有的case都不满足条件，才会执行default。</p><h4 id="当case表达式的类型String类型"><a href="#当case表达式的类型String类型" class="headerlink" title="当case表达式的类型String类型"></a>当case表达式的类型String类型</h4><p>JDK1.7以后，case表达式的类型可以为String类型。看下面这个例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringInSwitchCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringInSwitchCase</span><span class="params">(String mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ACTIVE"</span>:</span><br><span class="line">            System.out.println(<span class="string">"Application is running on Active mode"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"PASSIVE"</span>:</span><br><span class="line">            System.out.println(<span class="string">"Application is running on Passive mode"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"SAFE"</span>:</span><br><span class="line">            System.out.println(<span class="string">"Application is running on Safe mode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们反编译上面的代码得到的反编译代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringInSwitchCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringInSwitchCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringInSwitchCase</span><span class="params">(String mode)</span></span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">switch</span> ((s = mode).hashCode())&#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">74056953</span>: </span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"PASSIVE"</span>))</span><br><span class="line">                System.out.println(<span class="string">"Application is running on Passive mode"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2537357</span>: </span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"SAFE"</span>))</span><br><span class="line">                System.out.println(<span class="string">"Application is running on Safe mode"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1925346054</span>: </span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"ACTIVE"</span>))</span><br><span class="line">                System.out.println(<span class="string">"Application is running on Active mode"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这个代码，你就可以知道原来字符串的switch是通过hashcode()和equals()方法来实现的。记住，switch语句中的表达式只能使用整形，而hashcode()方法返回的int，而不是long。进行switch的实际是哈希值，然后通过使用equals()方法比较进行安全检查，这个检查是必要的，因为哈希可能发生碰撞。这就是Java1.7如何实现的字符串switch，它使用hashcode()来进行switch，然后通过squals方法验证。这其实是一个语法糖，而不是什么内建的本地功能。</p><h4 id="当case表达式的类型为枚举类型"><a href="#当case表达式的类型为枚举类型" class="headerlink" title="当case表达式的类型为枚举类型"></a>当case表达式的类型为枚举类型</h4><p>JDK1.5以后，case表达式的类型可以为枚举类型。看下面这个例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumInSwitchCase</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumInSwitchCase</span><span class="params">(Season season)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (season) &#123;</span><br><span class="line"><span class="keyword">case</span> SPRING:</span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SUMMER:</span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AUTUMN:</span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WINTER:</span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们反编译上面的代码得到的反编译代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumInSwitchCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> $SWITCH_TABLE$com$phicomm$switchdemo$Season[];      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumInSwitchCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumInSwitchCase</span><span class="params">(Season season)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> ($SWITCH_TABLE$com$phicomm$switchdemo$Season()[season.ordinal()])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// '\001'</span></span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// '\002'</span></span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// '\003'</span></span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// '\004'</span></span><br><span class="line">System.out.println(season.name());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] $SWITCH_TABLE$com$phicomm$switchdemo$Season()</span><br><span class="line">&#123;</span><br><span class="line">$SWITCH_TABLE$com$phicomm$switchdemo$Season;</span><br><span class="line"><span class="keyword">if</span> ($SWITCH_TABLE$com$phicomm$switchdemo$Season == <span class="keyword">null</span>) goto _L2; <span class="keyword">else</span> goto _L1</span><br><span class="line">_L1:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_L2:</span><br><span class="line">JVM INSTR pop ;</span><br><span class="line"><span class="keyword">int</span> ai[] = <span class="keyword">new</span> <span class="keyword">int</span>[Season.values().length];</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ai[Season.AUTUMN.ordinal()] = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchFieldError ) &#123; &#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ai[Season.SPRING.ordinal()] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchFieldError ) &#123; &#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ai[Season.SUMMER.ordinal()] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchFieldError ) &#123; &#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ai[Season.WINTER.ordinal()] = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchFieldError ) &#123; &#125;</span><br><span class="line"><span class="keyword">return</span> $SWITCH_TABLE$com$phicomm$switchdemo$Season = ai;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这个代码，你就可以知道原来枚举类型的switch也本质是通过整形来实现的。season.ordinal()返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零，然后构建$SWITCH_TABLE$com$phicomm$switchdemo$Season[]这个int型的数组。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是switch中当表达式为String，枚举类型的时候的实现细节，发现在代码底层都是将switch语句中的表达式转为int类型。但是，实现编码过程中，String类型作为switch语句的表达式用的还不是很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;switch case语句在很多编程语言中的功能都是等于条件判断，Java中为多路分支选择流程专门提供了switch语法，switch语句根据多个表达式的值，选择运行多个操作中的一个。当需要对选项进行等值判断时，使用switch语句更加简洁明了。switch的case语句可
      
    
    </summary>
    
      <category term="Java语言学习" scheme="http://yoursite.com/categories/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>全面解析Java枚举</title>
    <link href="http://yoursite.com/2017/12/08/Java/java%20enum/"/>
    <id>http://yoursite.com/2017/12/08/Java/java enum/</id>
    <published>2017-12-08T03:17:38.000Z</published>
    <updated>2018-08-19T14:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是枚举"><a href="#1-什么是枚举" class="headerlink" title="1.什么是枚举"></a>1.什么是枚举</h3><p>枚举类型是Java5中新增特性的一部分，它是一种特殊的数据类型。</p><blockquote><p>1.在某些情况下，一个类的对象是有限且固定的，如季节类，它只有春夏秋冬4个对象。这种实例有限且固定的类，在Java中被称为枚举类。<br>2.在Java中，使用enum关键字来使用枚举类。<br>3.枚举类是一种特殊的类，它和普通的类一样，有自己的成员变量，成员方法，构造方法（构造方法只能使用private访问修饰符，所以无法从外部调用构造方法，构造方法只在构造枚举值时被调用）。<br>4.使用enum定义枚举类默认继承了java.lang.Enum类，并实现了java.lang.Seriablizable和java.lang.Comparable两个接口。<br>5.所有的枚举值都是public static final的，且非抽象的枚举类不能在派生子类。<br>6.枚举类的所有实例（枚举值）<strong>必须在枚举类的第一行显示地列出</strong>，否则这个枚举类将永远不能产生实例。列出这些枚举实例（枚举值）时，系统会自动添加public static fianl修饰，无需程序员显示添加。</p></blockquote><h3 id="2-创建自定义的枚举类型"><a href="#2-创建自定义的枚举类型" class="headerlink" title="2.创建自定义的枚举类型"></a>2.创建自定义的枚举类型</h3><h4 id="2-1不包含抽象方法的枚举类"><a href="#2-1不包含抽象方法的枚举类" class="headerlink" title="2.1不包含抽象方法的枚举类"></a>2.1不包含抽象方法的枚举类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个季节的枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line"><span class="comment">//在第一行显示的列出4个枚举实例，系统会自动添加public static final修饰</span></span><br><span class="line">SPRING, SUMMER, AUTUMN, WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给这个枚举类中添加成员变量和成员方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line"><span class="comment">//因为已经定义了带参数的构造方法，所以在列出枚举值时必须传入对应的参数</span></span><br><span class="line">SPRING(<span class="string">"春天"</span>,<span class="number">0</span>), SUMMER(<span class="string">"夏天"</span>,<span class="number">1</span>), AUTUMN(<span class="string">"秋天"</span>,<span class="number">2</span>), WINTER(<span class="string">"冬天"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String seasonName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> seasonId;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个带参数的构造方法，枚举类的构造方法只能使用private修饰</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,<span class="keyword">int</span> seasonId)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.seasonId = seasonId;</span><br><span class="line"><span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSeasonId</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> seasonId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-包含抽象方法的枚举类"><a href="#2-2-包含抽象方法的枚举类" class="headerlink" title="2.2 包含抽象方法的枚举类"></a>2.2 包含抽象方法的枚举类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">PLUS &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">MINUS &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">MULTIPLY &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">DIVIDE &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-枚举的原理"><a href="#3-枚举的原理" class="headerlink" title="3.枚举的原理"></a>3.枚举的原理</h3><p>而我们反编译这个定义好的Season.class枚举类，得到如下的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line"><span class="comment">//我们自己定义的4种枚举实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER;</span><br><span class="line"><span class="keyword">private</span> String seasonName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> seasonId;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Season ENUM$VALUES[];</span><br><span class="line"><span class="comment">//私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String s, <span class="keyword">int</span> i, String seasonName, <span class="keyword">int</span> seasonId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(s, i);</span><br><span class="line"><span class="keyword">this</span>.seasonId = seasonId;</span><br><span class="line"><span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSeasonId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> seasonId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title">getSeason</span><span class="params">(<span class="keyword">int</span> seasonId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (seasonId) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// '\0'</span></span><br><span class="line"><span class="keyword">return</span> SPRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// '\001'</span></span><br><span class="line"><span class="keyword">return</span> SUMMER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// '\002'</span></span><br><span class="line"><span class="keyword">return</span> AUTUMN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// '\003'</span></span><br><span class="line"><span class="keyword">return</span> WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> SPRING;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season[] values() &#123;</span><br><span class="line">Season aseason[];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">Season aseason1[];</span><br><span class="line">System.arraycopy(aseason = ENUM$VALUES, <span class="number">0</span>, aseason1 = <span class="keyword">new</span> Season[i = aseason.length], <span class="number">0</span>, i);</span><br><span class="line"><span class="keyword">return</span> aseason1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title">valueOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Season) Enum.valueOf(com / phicomm / test / Season, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">//实例化枚举实例</span></span><br><span class="line">SPRING = <span class="keyword">new</span> Season(<span class="string">"SPRING"</span>, <span class="number">0</span>, <span class="string">"春天"</span>, <span class="number">0</span>);</span><br><span class="line">SUMMER = <span class="keyword">new</span> Season(<span class="string">"SUMMER"</span>, <span class="number">1</span>, <span class="string">"夏天"</span>, <span class="number">1</span>);</span><br><span class="line">AUTUMN = <span class="keyword">new</span> Season(<span class="string">"AUTUMN"</span>, <span class="number">2</span>, <span class="string">"秋天"</span>, <span class="number">2</span>);</span><br><span class="line">WINTER = <span class="keyword">new</span> Season(<span class="string">"WINTER"</span>, <span class="number">3</span>, <span class="string">"冬天"</span>, <span class="number">3</span>);</span><br><span class="line">ENUM$VALUES = (<span class="keyword">new</span> Season[] &#123; SPRING, SUMMER, AUTUMN, WINTER &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从反编译的代码可以看出编译器为我们生成了一个Season类（注意该类被final修饰，将无法被继承），而且该类继承自java.lang.Enum类（该类是一个抽象类）。并且生成了两个静态方法，value()和valueOf()方法。</p><h4 id="3-1枚举类中的常用方法"><a href="#3-1枚举类中的常用方法" class="headerlink" title="3.1枚举类中的常用方法"></a>3.1枚举类中的常用方法</h4><p>1.int comare(E o):该方法用于与制定枚举对象比较顺序，同一个枚举实例只能与相同类型的枚举实例比较。如果该枚举对象位于指定枚举对象之后，则返回正整数；反之返回负整数。否则，返回零。<br>2.String name():返回此枚举类的名称，及枚举值。<br>3.static values():返回一个包含全部枚举值的数组，可以用来遍历所有枚举值。<br>4.String toString():返回枚举值的名称，与name方法类似。<br>5.int ordinal():返回枚举值在枚举类中的索引值（从0开始），及枚举值在枚举生命中的顺序，这个循序依据枚举值声明的顺序而定。<br>6.static valueOf(String s):返回带指定名称的指定枚举类型的枚举常量，名称必须与在此类型中声明枚举常量所用的标识符完全匹配（不允许使用额外的空白字符）。这个方法与toString()对应，因此重写toString()方法，一定要重写valueOf()方法。<br>7.boolean equals()：比较两个枚举类对象的引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是枚举&quot;&gt;&lt;a href=&quot;#1-什么是枚举&quot; class=&quot;headerlink&quot; title=&quot;1.什么是枚举&quot;&gt;&lt;/a&gt;1.什么是枚举&lt;/h3&gt;&lt;p&gt;枚举类型是Java5中新增特性的一部分，它是一种特殊的数据类型。&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="Java语言学习" scheme="http://yoursite.com/categories/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>KNN</title>
    <link href="http://yoursite.com/2017/12/05/KNN/"/>
    <id>http://yoursite.com/2017/12/05/KNN/</id>
    <published>2017-12-05T12:43:43.000Z</published>
    <updated>2017-12-05T12:44:14.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Object类概述</title>
    <link href="http://yoursite.com/2017/11/16/Java/Object%E7%B1%BB%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/11/16/Java/Object类概述/</id>
    <published>2017-11-16T01:35:40.000Z</published>
    <updated>2017-12-05T12:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Object类"><a href="#什么是Object类" class="headerlink" title="什么是Object类"></a>什么是Object类</h3><blockquote><p><strong>java.lang.Object</strong><br>类Object是类层次结构的根类。每个类都使用Object作为超类。它位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。所有对象（包括数组）都实现这个类的方法。在不明确给出超类的情况下，Java会自动把Object作为要定义类的超类。</p></blockquote><h3 id="Object类方法有哪些"><a href="#Object类方法有哪些" class="headerlink" title="Object类方法有哪些"></a>Object类方法有哪些</h3><blockquote><p>Object类没有定义属性，一个有13个方法。</p></blockquote><h4 id="类构造器public-Object"><a href="#类构造器public-Object" class="headerlink" title="类构造器public Object()"></a>类构造器public Object()</h4><blockquote><p>大部分情况下，Java中通过形如new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。为体现此特性，Java中规定，在类定义过程中，对于未定义构造函数的类，默认都会有一个无参数的构造函数。当然做为所有类的基类，Object类自然也要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。</p></blockquote><h4 id="private-static-native-void-registerNatives"><a href="#private-static-native-void-registerNatives" class="headerlink" title="private static native void registerNatives()"></a>private static native void registerNatives()</h4><blockquote><p>registerNatives函数前面有native关键字修饰，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中完成，而是有C/C++去完成，并被编译成.dll，由Java去调用。方法的具体实现体现在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法。</p></blockquote><h4 id="protected-native-Object-clone-throws-CloneNotSupportedException"><a href="#protected-native-Object-clone-throws-CloneNotSupportedException" class="headerlink" title="protected native Object clone() throws CloneNotSupportedException"></a>protected native Object clone() throws CloneNotSupportedException</h4><blockquote><p>创建并返回此对象的一个副本。clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别专用不同的堆空间。clone()的正确调用需要实现cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。Cloneable接口仅是一个标记接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。</p></blockquote><h4 id="public-final-native-Class-lt-gt-getClass"><a href="#public-final-native-Class-lt-gt-getClass" class="headerlink" title="public final native Class&lt;?&gt; getClass()"></a>public final native Class&lt;?&gt; getClass()</h4><blockquote><p>getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。<br>类对象：在Java中，类是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性。因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称为“类对象”。</p></blockquote><h4 id="public-boolean-equals-Object-obj"><a href="#public-boolean-equals-Object-obj" class="headerlink" title="public boolean equals(Object obj)"></a>public boolean equals(Object obj)</h4><blockquote><p>==与equals在Java中经常被使用。两者的区别如下：==针对基本类型，比较的是值是否相同，针对引用类型，比较的是地址值是否相同；equals()只能比较引用类型，默认情况下，比较的是地址值是否相同，但是，我们可以根据自己的需要重写该方法。以String类equals()方法为例，用于比较两个字符串内容是否相等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h4 id="public-native-int-hashCode"><a href="#public-native-int-hashCode" class="headerlink" title="public native int hashCode()"></a>public native int hashCode()</h4><p>返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。<br>hashCode()具有如下约定：<br>1.在Java应用程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希哈是相同的，前提是将对象进行equals比较时所用的信息未做修改。在Java应用程序的一次执行到另一次执行，同一对象的hashCode()返回的哈希码无须保持一致；<br>2.如果两个对象相等(调用equals()方法)，那么这两个对象调用hashCode()返回的哈希码也必须相等；<br>3.反之，两个对象调用hashCode()返回的哈希码相等，这两个对象不一定相等<br>即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt;  equals()相等  =&gt; hashCode()相等。因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等 =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。<br>再次以String类的hashCode为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h4 id="public-String-toString"><a href="#public-String-toString" class="headerlink" title="public String toString()"></a>public String toString()</h4><p>返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。<br>Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：<br><strong>getClass().getName() + ‘@’ + Integer.toHexString(hashCode())</strong></p></blockquote><blockquote><h4 id="public-final-native-void-wait-long-timeout-throws-InterruptedException"><a href="#public-final-native-void-wait-long-timeout-throws-InterruptedException" class="headerlink" title="public final native void wait(long timeout) throws InterruptedException"></a>public final native void wait(long timeout) throws InterruptedException</h4><p>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。</p><h4 id="public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException"><a href="#public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException" class="headerlink" title="public final void wait(long timeout, int nanos) throws InterruptedException"></a>public final void wait(long timeout, int nanos) throws InterruptedException</h4><p>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。<br>timeout - 要等待的最长时间（以毫秒为单位）。<br>nanos - 额外时间（以毫微秒为单位，范围是 0-999999）。 </p><h4 id="public-final-void-wait-throws-InterruptedException"><a href="#public-final-void-wait-throws-InterruptedException" class="headerlink" title="public final void wait() throws InterruptedException"></a>public final void wait() throws InterruptedException</h4><p>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样</p><h4 id="public-final-native-void-notify"><a href="#public-final-native-void-notify" class="headerlink" title="public final native void notify()"></a>public final native void notify()</h4><p>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 </p><h4 id="public-final-native-void-notifyAll"><a href="#public-final-native-void-notifyAll" class="headerlink" title="public final native void notifyAll()"></a>public final native void notifyAll()</h4><p>唤醒在此对象监视器上等待的所有线程</p><h4 id="protected-void-finalize-throws-Throwable"><a href="#protected-void-finalize-throws-Throwable" class="headerlink" title="protected void finalize() throws Throwable"></a>protected void finalize() throws Throwable</h4><p>finalize方法主要与Java垃圾收集机制有关。在Object中定义finalize方法被定义成一个空方法，为什么要如此定义呢?finalize方法的调用时机是怎么样的呢？<br>首先，Object中定义finalize方法表名Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对象所占用空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是我们主动去调用的(虽然可以主动去调用，此时与其他自定义方法无异)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Object类&quot;&gt;&lt;a href=&quot;#什么是Object类&quot; class=&quot;headerlink&quot; title=&quot;什么是Object类&quot;&gt;&lt;/a&gt;什么是Object类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;java.lang.Object&lt;
      
    
    </summary>
    
      <category term="Java语言学习" scheme="http://yoursite.com/categories/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的代码块</title>
    <link href="http://yoursite.com/2017/11/09/Java/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>http://yoursite.com/2017/11/09/Java/Java中的代码块/</id>
    <published>2017-11-09T11:46:08.000Z</published>
    <updated>2018-09-04T00:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>代码块</strong>：在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。</p></blockquote><h4 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h4><blockquote><p>定义：在方法、循环、判断等语句中出现的代码块<br>修饰：只能用标签修饰<br>位置：普通代码可以出现在方法体内除“()”外的任何地方，包括方法体，代码块（即可以嵌套在代码块中）<br>执行：局部代码块依赖方法的执行而执行，按照正常的先后顺序执行<br>作用：限定变量的生命周期，及早释放，提高内存的利用率</p></blockquote><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><blockquote><p>定义：在类中定义且没有加任何修饰的代码块<br>位置：在类中，方法外出现，用{}括起来的代码<br>执行：依赖构造函数的调用而执行<br>作用：初始化实例变量和实例环境，一般用于提取构造函数中的公共代码<br>注意：构造代码块不是在构造函数之前执行的！编译器在编译的时候会把构造代码块插入到每个构造函数的最前面。构造代码块随着构造函数的执行而执行。如果某个构造函数调用了其他的构造函数，那么构造代码块不会插入到该构造函数中一面构造代码块执行多次。<br>举例如下：原始的.java文件如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorsBolckTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"我是构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstructorsBolckTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstructorsBolckTest</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(name);<span class="comment">// 调用了ConstructorsBolckTest(String name)</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstructorsBolckTest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>然后将编译的.class文件反编译的结果如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorsBolckTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstructorsBolckTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是构造代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstructorsBolckTest</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>(name);</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstructorsBolckTest</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是构造代码块"</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><blockquote><p>定义：在类定义中用static修饰的代码块<br>修饰：使用static修饰<br>位置：出现在类中的成员变量位置处<br>执行：在加载类时会先执行静态代码块，且只执行一次，如果有多个静态代码块则按照先后顺序执行<br>作用：一般用于静态变量的初始化，创建对象前的环境的加载<br>注意：静态代码块中不能直接访问非静态变量和方法，需要通过类的实例对象来访问</p></blockquote><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><blockquote><p>定义：可以简单认为同步代码块是使用synchronzied修饰的普通代码块<br>位置：同局部代码块<br>执行：同局部代码块<br>作用：用于多线程环境的同步保护<br>注意：同步代码块使用不当会造成死锁</p></blockquote><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><blockquote><p>1.静态代码块，构造代码块，构造方法的执行顺序<br>执行顺如如下：I,静态代码块；II，构造代码块；III，构造方法。并且，静态代码块只执行一次；在加载类时就执行一次。构造代码块每次调用构造方法都会执行。<br>2.写出如下代码的执行结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"静态代码块Fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"构造代码块Fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Fu</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"构造方法Fu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"静态代码块Zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"构造代码块Zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"构造方法Zi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>执行结构如下,因为子类初始化之前，会先进行父类的初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态代码块Fu</span><br><span class="line">静态代码块Zi</span><br><span class="line">构造代码块Fu</span><br><span class="line">构造方法Fu</span><br><span class="line">构造代码块Zi</span><br><span class="line">构造方法Zi</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>3.写出如下程序的执行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">Y b = <span class="keyword">new</span> Y();</span><br><span class="line">X()&#123;</span><br><span class="line">System.out.println(<span class="string">"X"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Y</span> </span>&#123;</span><br><span class="line">Y()&#123;</span><br><span class="line">System.out.println(<span class="string">"Y"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span></span>&#123;</span><br><span class="line">Y y = <span class="keyword">new</span> Y();</span><br><span class="line">Z()&#123;</span><br><span class="line"><span class="keyword">super</span>();<span class="comment">//仅仅表示要先初始化父类数据,再初始化子类数据</span></span><br><span class="line">System.out.println(<span class="string">"Z"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Z();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>执行结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Y</span><br><span class="line">X</span><br><span class="line">Y</span><br><span class="line">Z</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>成员变量初始化的步骤如下：先进行默认初始化，（int型默认是0，boolean默认为flase,Object型默认为null），再进行显示初始化，最后在构造函数中进行初始化。父子类中，先初始化父类数据,再初始化子类数据。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码块&lt;/strong&gt;：在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;局部代码块&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Java语言学习" scheme="http://yoursite.com/categories/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的内部类总结</title>
    <link href="http://yoursite.com/2017/11/09/Java/Java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/11/09/Java/Java中的内部类/</id>
    <published>2017-11-09T11:46:08.000Z</published>
    <updated>2018-09-06T11:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类定义"><a href="#内部类定义" class="headerlink" title="内部类定义"></a>内部类定义</h3><blockquote><p><strong>内部类</strong>：可以将一个类的定义放在另一个类的定义内部，这个类就是内部类。<br>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类没有影响。<br>其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特征（摘自《Think in Java》）<br>1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。<br>2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。<br>3.创建内部类对象的时刻并不依赖于外围类对象的创建。<br>4.内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。<br>5.内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p></blockquote><h3 id="内部类基础"><a href="#内部类基础" class="headerlink" title="内部类基础"></a>内部类基础</h3><p>在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。<br>当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.phicomm.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">省略get()和set()方法</span><br><span class="line">···</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">name = <span class="string">"chenssy"</span>;</span><br><span class="line">age = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"name:"</span> + getName() + <span class="string">";age"</span> + getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">OuterClass.InnerClass innerClass = outerClass.new InnerClass();</span><br><span class="line">innerClass.display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个应用程序中，我们可以看到内部类InnerClass可以访问外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们再访问外围类的成员时，就会用这个引用来选择外围类的成员。<br>其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型。OutClassName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outClass.new InnerClass();<br>同时，如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点是在编译器就知晓了，没有任何运行时的成本。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OuterClass..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuterClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();</span><br><span class="line">        innerClass.getOuterClass().display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个Class文件：OuterClass.class和OuterClass$Inner.class。<br>在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以它是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法，则需要通过内部类实例来访问。<br>在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二:成员内部类是依附于外围类，，所以只有先创建了外围类才能够创建内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"outerClass..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//使用外围内的属性</span></span><br><span class="line">            str = <span class="string">"innerClass..."</span>;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            <span class="comment">//使用外围内的方法</span></span><br><span class="line">            outerDisplay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.InnerClass inner = outer.getInnerClass();</span><br><span class="line">        inner.innerDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所有就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。<br>定义在方法里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destionation <span class="title">destionation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestionation</span> <span class="keyword">implements</span> <span class="title">Destionation</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestionation</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestionation(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 parcel5 = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destionation d = parcel5.destionation(<span class="string">"chenssy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义在作用域内<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"chenssy"</span>);</span><br><span class="line">            String string = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;</span><br><span class="line">        internalTracking(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 parcel6 = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        parcel6.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>在做Swing编程中，我们经常使用这种方式来绑定事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button2.addActionListener(  </span><br><span class="line"><span class="keyword">new</span> ActionListener()&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"你按了按钮二"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个内部类是没有名字的，再看如下这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass()&#123;</span><br><span class="line">            <span class="keyword">int</span> number = num + <span class="number">3</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass inner = out.getInnerClass(<span class="number">2</span>, <span class="string">"chenssy"</span>);</span><br><span class="line">        System.out.println(inner.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们就需要看清几个地方：<br>1.匿名内部类是没有访问修饰符的。<br>2.new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。<br>3.注意getInnnerClass()方法的形参，第一个形参是用final修饰的，第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。<br>4.匿名内部类是没有构造方法的，因为它连名字都没有何来构造方法。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>使用static修饰的内部类我们称为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：<br>1.它的创建是不需要依赖于外围类的。<br>2.它不能使用任何外围类的非static成员变量和方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"hello world"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 在静态内部类中可以存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _name1 = <span class="string">"hello world _static"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 静态内部类只能访问外围类的静态成员变量和方法</span></span><br><span class="line"><span class="comment">             * 不能访问外围类的非静态成员变量和方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">"OutClass name :"</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 非静态内部类中不能存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> String _name2 = <span class="string">"chenssy_inner"</span>;</span><br><span class="line">        <span class="comment">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"OuterClass name："</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 外围类访问静态内部类：内部类. */</span></span><br><span class="line">        System.out.println(InnerClass1._name1);</span><br><span class="line">        <span class="comment">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass1().display();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 非静态内部的创建需要依赖于外围类 */</span></span><br><span class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().new InnerClass2();</span><br><span class="line">        <span class="comment">/* 访问非静态内部类的成员需要使用非静态内部类的实例 */</span></span><br><span class="line">        System.out.println(inner2._name2);</span><br><span class="line">        inner2.display();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        outer.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个例子充分体现了静态内部类和非静态内部类的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内部类定义&quot;&gt;&lt;a href=&quot;#内部类定义&quot; class=&quot;headerlink&quot; title=&quot;内部类定义&quot;&gt;&lt;/a&gt;内部类定义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;内部类&lt;/strong&gt;：可以将一个类的定义放在另一个类的定义内部，这个类
      
    
    </summary>
    
      <category term="Java语言学习" scheme="http://yoursite.com/categories/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Median of Two Sorted Arrays</title>
    <link href="http://yoursite.com/2017/10/15/Java/Median-of-Two-Sorted-Arrays/"/>
    <id>http://yoursite.com/2017/10/15/Java/Median-of-Two-Sorted-Arrays/</id>
    <published>2017-10-15T03:17:42.000Z</published>
    <updated>2017-10-15T10:43:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Description</strong>:There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br><strong>Example 1</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line">The median is <span class="number">2.0</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>Example 2</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function">The median <span class="title">is</span> <span class="params">(<span class="number">2</span> + <span class="number">3</span>)</span>/2 </span>= <span class="number">2.5</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><blockquote><p>这种方法是在<br>Assume that the number of elements in A and B are both larger than k/2, and if we compare the k/2-th smallest element in A(i.e. A[k/2-1]) and the k-th smallest element in B(i.e. B[k/2 - 1]), there are three results:<br>(Becasue k can be odd or even number, so we assume k is even number here for simplicy. The following is also true when k is an odd number.)<br>A[k/2-1] = B[k/2-1]<br>A[k/2-1] &gt; B[k/2-1]<br>A[k/2-1] &lt; B[k/2-1]<br>if A[k/2-1] &lt; B[k/2-1], that means all the elements from A[0] to A<a href="i.e. the k/2 smallest elements in A">k/2-1</a> are in the range of k smallest elements in the union of A and B. Or, in the other word, A[k/2 - 1] can never be larger than the k-th smalleset element in the union of A and B.<br>Why?<br>We can use a proof by contradiction. Since A[k/2 - 1] is larger than the k-th smallest element in the union of A and B, then we assume it is the (k+1)-th smallest one. Since it is smaller than B[k/2 - 1], then B[k/2 - 1] should be at least the (k+2)-th smallest one. So there are at most (k/2-1) elements smaller than A[k/2-1] in A, and at most (k/2 - 1) elements smaller than A[k/2-1] in B.So the total number is k/2+k/2-2, which, no matter when k is odd or even, is surly smaller than k(since A[k/2-1] is the (k+1)-th smallest element). So A[k/2-1] can never larger than the k-th smallest element in the union of A and B if A[k/2-1]&lt;B[k/2-1];<br>Since there is such an important conclusion, we can safely drop the first k/2 element in A, which are definitaly smaller than k-th element in the union of A and B. This is also true for the A[k/2-1] &gt; B[k/2-1] condition, which we should drop the elements in B.<br>When A[k/2-1] = B[k/2-1], then we have found the k-th smallest element, that is the equal element, we can call it m. There are each (k/2-1) numbers smaller than m in A and B, so m must be the k-th smallest number. So we can call a function recursively, when A[k/2-1] &lt; B[k/2-1], we drop the elements in A, else we drop the elements in B.</p></blockquote><blockquote><p>We should also consider the edge case, that is, when should we stop?</p><ol><li>When A or B is empty, we return B<a href="or A[k-1]">k-1</a>, respectively;</li><li>When k is 1(when A and B are both not empty), we return the smaller one of A[0] and B[0]</li><li>When A[k/2-1] = B[k/2-1], we should return one of them</li></ol></blockquote><blockquote><p>In the code, we check if m is larger than n to garentee that the we always know the smaller array, for coding simplicy.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;br&gt;Find the median of
      
    
    </summary>
    
      <category term="leetcode解题报告" scheme="http://yoursite.com/categories/leetcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2017/09/25/quick-sort/"/>
    <id>http://yoursite.com/2017/09/25/quick-sort/</id>
    <published>2017-09-25T12:15:11.000Z</published>
    <updated>2017-11-22T15:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在找工作的过程中，遇到最多的手写代码的题中，出现最多的算得上是“快速排序”了。有一般的让你写快速排序的，也有让你将递归的快速排序算法改成非递归的。也有让你为了避免出现“快速排序”最差性能的时候随机选主元的情况。现在分别对三种要求进行编码实现。</p><h3 id="递归实现的快速排序"><a href="#递归实现的快速排序" class="headerlink" title="递归实现的快速排序"></a>递归实现的快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line"><span class="keyword">int</span> q = partition(array,start,end);</span><br><span class="line">quickSort(array, start, q-<span class="number">1</span>);</span><br><span class="line">quickSort(array, q+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = start -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> key = array[end];</span><br><span class="line"><span class="keyword">int</span> j = start;</span><br><span class="line"><span class="keyword">for</span>(;j&lt;end ;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[j] &lt; key)&#123;</span><br><span class="line">i++;</span><br><span class="line">array[i] = (array[i] + array[j]) - (array[j] = array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">array[i+<span class="number">1</span>] = array[i+<span class="number">1</span>] + array[end] - (array[end] = array[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速拍戏的非递归版本"><a href="#快速拍戏的非递归版本" class="headerlink" title="快速拍戏的非递归版本"></a>快速拍戏的非递归版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">stack.push(start);</span><br><span class="line">stack.push(end);</span><br><span class="line"><span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> right = stack.pop();</span><br><span class="line"><span class="keyword">int</span> left = stack.pop();</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> boundray = partition(array, left, right);</span><br><span class="line"><span class="comment">// 左区间</span></span><br><span class="line">stack.push(left);</span><br><span class="line">stack.push(boundray - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右区间</span></span><br><span class="line">stack.push(boundray + <span class="number">1</span>);</span><br><span class="line">stack.push(right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> key = array[end];</span><br><span class="line"><span class="keyword">int</span> j = start;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; end; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[j] &lt; key) &#123;</span><br><span class="line">i++;</span><br><span class="line">array[i] = (array[i] + array[j]) - (array[j] = array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">array[i + <span class="number">1</span>] = array[i + <span class="number">1</span>] + array[end] - (array[end] = array[i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序随机选主元的版本"><a href="#快速排序随机选主元的版本" class="headerlink" title="快速排序随机选主元的版本"></a>快速排序随机选主元的版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomizedQuickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> q = randomizedPatition(array, start, end);</span><br><span class="line">randomizedQuickSort(array, start, q - <span class="number">1</span>);</span><br><span class="line">randomizedQuickSort(array, q + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedPatition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> i = random.nextInt(end) % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">array[i] = (array[i] + array[end]) - (array[end] = array[i]);</span><br><span class="line"><span class="keyword">return</span> partition(array, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = start;</span><br><span class="line"><span class="keyword">int</span> key = array[end];</span><br><span class="line"><span class="keyword">for</span> (; j &lt; end; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[j] &lt; key) &#123;</span><br><span class="line">i++;</span><br><span class="line">array[i] = array[i] + array[j] - (array[j] = array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">array[end] = array[i + <span class="number">1</span>];</span><br><span class="line">array[i + <span class="number">1</span>] = key;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在找工作的过程中，遇到最多的手写代码的题中，出现最多的算得上是“快速排序”了。有一般的让你写快速排序的，也有让你将递归的快速排序算法改成非递归的。也有让你为了避免出现“快速排序”最差性能的时候随机选主元的情况。现在分别对三种要求进行编码实现。&lt;/p&gt;
&lt;h3 id=&quot;递
      
    
    </summary>
    
      <category term="lintcode解题报告" scheme="http://yoursite.com/categories/lintcode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
</feed>
