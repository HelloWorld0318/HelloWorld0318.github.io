<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于Spark Streaming+Canal+Kafka对Mysql增量数据实时进行检测分析]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F%E5%9F%BA%E4%BA%8ESpark-Streaming-Canal-Kafka%E5%AF%B9Mysql%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题分类]]></title>
    <url>%2F2019%2F08%2F01%2FLeetCode%E5%88%B7%E9%A2%98%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JVM内存空间划分与作用详解]]></title>
    <url>%2F2019%2F08%2F01%2Fjvm%2FJVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[作为一名Java程序员，在编写程序时除了尽情发挥Java的各种优势外，还应该去了解和思考一下Java技术体系中这些技术特征是如何实现的。 一旦使用了关键字strictfp来生明某个类，接口或者方法时，那么在这个关键字声明的范围内的所有浮点运算都是精确的，符合ieee-754标准。 JDK1.5在Java语法的易用性上面做出了非常大的改进。例如：自动装箱、范型、动态注解、枚举、可变长参数、遍历循环（foreach循环）等语法特性都是在JDK1.5中加入的。 HotSpot VM的热点代码探测能力可以通过执行计数器找到最具有编译价值的代码，然后通过JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无需等待本地代码输出才能执行程序，即使编译的时间压力也相对减少，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。 模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。站在整个软件工业化的高度来看，模块化是建立各种功能的标准件的前提。 Java内存模块图各区域介绍JDK1.8以后的JVM内存模块图程序计数器程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。程序计数器处于线程独占区。如果线程执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果只在执行的是native方法，这个计数器的值为undefined此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈虚拟机栈描述的是Java方法执行的动态内存模型。帧栈 每个方法执行，都会创建一个帧栈，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等。 局部变量表 存放编译器可知的各种基本数据类型，引用类型，returnAddress类型 局部变量表的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多少内存时固定的，在方法运行期间时不会改变局部变量表的大小大小 本地方法栈虚拟机栈为虚拟机执行Java方法服务。本地方法栈为虚拟机执行native方法服务。HostSpot虚拟机不区分本地方法栈和虚拟机栈 Java堆存放对象实例垃圾收集器管理的主要区域新生代，老年代 OOM分析]]></content>
      <categories>
        <category>深入理解JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[69.sqrt(x)]]></title>
    <url>%2F2018%2F09%2F15%2Fleetcode%2F69-sqrt-x%2F</url>
    <content type="text"><![CDATA[题目描述Sqrt(x)(难度级别：easy)Description:Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:12Input: 4Output: 2 Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 解题报告虽然这道题的难度级别只有easy，但是个人觉得还是一个非常有意思的题目。解题方法就是用“二分查找”的思想。还有一点需要注意的是，如果你用乘法，可能会出现超过int范围值的问题。具体解题代码如下：1234567891011121314151617181920212223242526272829public class Solution &#123; /** * @Title: mySqrt * @Description: Compute and return the square root of x * (采用二分查找的思路) * @param x x是一个整数，并且非负 * @return int x的 */ public int mySqrt(int x) &#123; if (x &lt; 2) &#123; return x; &#125; int start = 1; int end = x / 2; int lastMedium = start + (end - start) / 2; while (start &lt;= end) &#123; int medium = start + (end - start) / 2; if (x / medium &gt; medium) &#123;// 注意这里不要用乘法 start = medium + 1; lastMedium = medium; &#125; else if (x / medium &lt; medium) &#123; end = medium - 1; &#125; else &#123; return medium; &#125; &#125; return lastMedium; &#125;&#125;]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOP以及自己实现一个AOP]]></title>
    <url>%2F2018%2F09%2F14%2Fspring%2FAOP%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAOP%2F</url>
    <content type="text"><![CDATA[AOP概述在软件业，AOP为Aspect Oriented Programming的缩写，意为:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP(面向对象编程)的延续。是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。在AOP中，采用了横向抽取机制，取代了传统纵向继承体系重复性代码。AOP的经典应用有事务管理，性能监视，安全检查，缓存，日志等。 AOP术语1.目标类(Target)：需要被代理的对象。例如：UserService2.连接点(JoinPoint):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法。3.切入点(PointCut)：已经被增强的连接点。例如：addUser()，注意，切入点是连接点的子集。4.通知(Advice)：通知/增强，增强代码。例如：after,before。5.代理(Proxy)：代理类6.织入（Warve）：是指把增强advice应用到目标对象target来创建新的代理对象Proxy的过程7.切面(Aspect)：是切入点pointcut和通知advice的结合一个线是一个特殊的面。一个切入点和一个通知，组成一个特殊的面。 采用JDK的动态代理实现AOP利用Proxy实现AOP的主要步骤如下：（1）创建接口（2）创建接口实现类（3）创建代理工厂类 创建接口12345public interface UserService &#123; void addUser(); void deleteUser();&#125; 创建接口的实现类12345678910111213public class UserServiveImpl implements UserService&#123; @Override public void addUser() &#123; System.out.println("新增用户"); &#125; @Override public void deleteUser() &#123; System.out.println("删除用户"); &#125;&#125; 创建代理工厂类增强代码如下123456public interface LogAdvice &#123; // 在方法开始前开启日志 void logStart(Method method); // 在方法结束侯关闭日历 void logEnd(Method method);&#125; 增强代码的实现类如下：12345678910111213public class LogAdviceImpl implements LogAdvice&#123; @Override public void logStart(Method method) &#123; System.out.println("method name " + method.getName() + "start"); &#125; @Override public void logEnd(Method method) &#123; System.out.println("method name" + method.getName() + "end"); &#125;&#125; 创建代理工厂类123456789101112131415161718192021222324public class ProxyFactory implements InvocationHandler&#123; private Object target; private Object advice; public Object getProxyBean(Object target,Object advice) &#123; this.target = target; this.advice = advice; LogAdvice logAdvice = new LogAdviceImpl(); return Proxy.newProxyInstance(ProxyFactory.class.getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Method logStart = advice.getClass().getDeclaredMethod("logStart",Method.class); logStart.invoke(advice,method); Object result = method.invoke(target, args); Method logEnd = advice.getClass().getDeclaredMethod("logEnd", Method.class); logEnd.invoke(advice, method); return result; &#125;&#125; 测试代码如下：123456789public class Test &#123; public static void main(String[] args) &#123; ProxyFactory proxyFactory = new ProxyFactory(); UserService userService = (UserService) proxyFactory.getProxyBean( new UserServiveImpl(), new LogAdviceImpl()); userService.addUser(); &#125;&#125; 输出结果如下：123method name addUser log start新增用户method nameaddUser log end AOP总结利用Proxy实现AOP功能的总结如下：（1）目标类必须时间接口（2）返回创建的代理对象（3）重写InvocationHandler里面的invoke()方法（4）限制条件放在invoke()方法中]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring中bean的生命周期]]></title>
    <url>%2F2018%2F09%2F07%2Fspring%2FSpring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Spring中bean的生命周期 在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图为一个典型的bean装载到Springy应用上下文中的一个典型的生命周期过程。 （1）实例化Bean对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用creatBean进行实例化。对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。（2）设置对象属性（DI）实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。紧接着，Spring根据BeanDefinition中的信息进行依赖注入。并且根据BeanWrapper提供的设置属性的接口完成依赖注入。（3）注入Aware接口紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。（4）BeanPostProcessor当经过上述几个步骤后，bean对象已经被正确构造了，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。postProcessBeforeInitialization(Object bean,String beanName):当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会先于InitializationBean执行，因此称为前置处理。所有Aware接口的注入就是在这一步完成的。postProcessAfterInitialization(Object bean,String beanName):当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会在InitializationBean完成后执行，因此称为后置处理。（5）InitializingBean与init-method当BeanPostProcessor的前置处理完成后就会进行本阶段。InitializingBean接口只有一个函数：afterPropertiesSet()这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在一步没办法处理对象本身，只能增加一些额外的逻辑。若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet()函数。当然，Spring为了降低对客户端代码的侵入性，给bean的配置提供了init-method属性，该属性指定在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上任然使用了InitializingBean接口。（6）DisposableBean的destroy-method和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。 举例说明需要Spring创建的bean实例如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Person implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, InitializingBean, DisposableBean &#123; private String name; public Person() &#123; System.out.println("第一步：bean被实例化,调用Person类的构造方法"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println("第二步：通过set方法去填充属性"); this.name = name; &#125; public void setBeanName(String beanName) &#123; System.out.println("第三步：调用BeanNameAware的setBeanName(),beanName:" + beanName); &#125; public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println("第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory"); &#125; public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out .println("第五步：ApplicationContextAware的setApplicationContext()方法被调用,这样该Bean就获得了自己所在的ApplicationContext"); &#125; public void afterPropertiesSet() throws Exception &#123; System.out.println("第七步：InitializingBean的afterPropertiesSet()方法被调用"); &#125; // 自定义的初始化函数 public void myInit() &#123; System.out.println("第八步：Bean配置了init-method方法，则会执行init-method配置的方法"); &#125; public void destroy() throws Exception &#123; System.out.println("第十步：调用DisposableBean的destory()方法"); &#125; // 自定义的销毁方法 public void myDestroy() &#123; System.out.println("第十一步：自定义的销毁方法myDestroy被调用"); &#125; public String toString() &#123; return "name is :" + name; &#125;&#125; MyBeanPostProcessor实现BeanPostProcessor接口，重写里面的postProcessBeforeInitialization和postProcessAfterInitialization方法。12345678910111213public class MyBeanPostProcessor implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用"); return bean; &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法"); return bean; &#125;&#125; Spring的配置文件如下：1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="personId" class="com.phicomm.lifecycle.Person" init-method="myInit" destroy-method="myDestroy"&gt; &lt;property name="name" value="hellokitty"&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="postProcessor" class="com.phicomm.lifecycle.MyBeanPostProcessor"&gt;&lt;/bean&gt; &lt;/beans&gt; 测试代码如下：1234567891011public class AcPersonServiceTest &#123; public static void main(String[] args) throws IOException &#123; System.out.println("开始初始化容器"); ApplicationContext ac = new ClassPathXmlApplicationContext("com/phicomm/lifecycle/applicationContext.xml"); System.out.println("xml加载完毕"); Person person1 = (Person) ac.getBean("personId"); System.out.println(person1); System.out.println("关闭容器"); ((ClassPathXmlApplicationContext)ac).close(); &#125;&#125; 运行的结果的如下，符合Spring bean的生命周期中的各个步骤12345678910111213141516171819202122开始初始化容器九月 15, 2018 9:43:42 上午 org.springframework.context.support.AbstractApplicationContext prepareRefresh信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3eb07fd3: startup date [Sat Sep 15 09:43:42 CST 2018]; root of context hierarchy九月 15, 2018 9:43:42 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions信息: Loading XML bean definitions from class path resource [com/phicomm/lifecycle/applicationContext.xml]第一步：bean被实例化,调用Person类的构造方法第二步：通过set方法去填充属性第三步：调用BeanNameAware的setBeanName(),beanName:personId第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory第五步：ApplicationContextAware的setApplicationContext()方法被调用,这样该Bean就获得了自己所在的ApplicationContext第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用com.phicomm.lifecycle.Person第七步：InitializingBean的afterPropertiesSet()方法被调用第八步：Bean配置了init-method方法，则会执行init-method配置的方法第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法xml加载完毕name is :hellokitty关闭容器九月 15, 2018 9:43:42 上午 org.springframework.context.support.AbstractApplicationContext doClose信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@3eb07fd3: startup date [Sat Sep 15 09:43:42 CST 2018]; root of context hierarchy第十步：调用DisposableBean的destory()方法第十一步：自定义的销毁方法myDestroy被调用 注意（1）如果bean的scope设为prototype时，当容器关闭时，destroy方法不会被调用。对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个protype bean的整个生命周期负责：容器在初始化，配置，装饰或者装配完一个prototype实例后，将它交个客户端，随后就对该prototype实例不闻不问了。（2）BeanFactory容器中，B与ApplicationContext相比，有如下几点不同：1、BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法；2、BeanPostProcessor接口的postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册;3、BeanFactory容器启动的时候，不会去实例化所有的Bean，包括所有scope为Sinleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。BeanFactory的示例如下：1234567891011121314public class BfPersonServiceTest &#123; public static void main(String[] args) &#123; System.out.println("开始初始化容器"); ConfigurableBeanFactory bf = new XmlBeanFactory( new ClassPathResource("com/phicomm/lifecycle/applicationContext.xml")); System.out.println("xml加载完毕"); // beanFactory需要手动注册beanPostProcessor类的方法 bf.addBeanPostProcessor(new MyBeanPostProcessor()); Person person1 = (Person) bf.getBean("personId"); System.out.println(person1); System.out.println("关闭容器"); bf.destroySingletons(); &#125;&#125; 输出的结果如下：12345678910111213141516开始初始化容器九月 15, 2018 9:58:02 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions信息: Loading XML bean definitions from class path resource [com/phicomm/lifecycle/applicationContext.xml]xml加载完毕第一步：bean被实例化,调用Person类的构造方法第二步：通过set方法去填充属性第三步：调用BeanNameAware的setBeanName(),beanName:personId第四步：BeanFactoryAwared的setBeanFactory()方法被调用,beanFactory,这样该Bean就获得了自己所在的BeanFactory第六步：BeanPostProcessor的postProcessBeforeInitialization()方法被调用第七步：InitializingBean的afterPropertiesSet()方法被调用第八步：Bean配置了init-method方法，则会执行init-method配置的方法第九步：Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法name is :hellokitty关闭容器第十步：调用DisposableBean的destory()方法第十一步：自定义的销毁方法myDestroy被调用]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis集群搭建]]></title>
    <url>%2F2018%2F08%2F24%2Fredis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[redis的主从复制redis-cluster架构图redis-cluster图片-容错redis-cluster搭建过程添加Master节点删除Master节点总结]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2018%2F08%2F17%2Fdesignpattern%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式的动机和定义装饰模式的动机一般有两种方式可以实现给一个类或对象增加行为：（1）继承机制：使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方式是静态的，用户不能控制增加行为的方法和时机。（2）关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器（Decorator）。 装饰模式的定义 装饰模式可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.[GOF]装饰模式可以在无需创建子类的情况下扩展类的功能。在对象功能扩展方面，它比继承更有弹性。 装饰模式的类图如下所示：Component：抽象构件ConcreteComponent：具体构件Decorator：抽象装饰类，维持一个指向Component对象的指针或引用，并定义一个与Component接口一致的接口。Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。ConcreteDecorator：具体装饰类 装饰模式实例演示通俗来讲，装饰模式就像打包一个快递。现在以一个具体的情景来说明装饰模式。现实的发票有三部分组成：头部分，主体部分（数据部分），尾部分；不同的对象打印出来的头和尾是不一样的，但是主体部分是一样，要实现这样的需求，就应该采用装饰模式，下面是UML图：参照上图可知装饰模式的各种角色有：(1)抽象构建角色（IPrintable）：定义一个抽象接口，以规范准备接受附加责任的对象。(2)具体构件角色（Order）：这是被装饰者，定义一个将要被装饰模式增加功能的类。(3)装饰角色（OrderDecorator）:持有一个构件对象的实例，并定义了抽象构件定义的接口。(4)具体装饰角色（HeaderDecorator FooterDecorator）：负责给构件添加增加的功能。首先，设计客户端使用的接口，在此例中即IPrintable，设计此接口的目的是对下面的实现类和各种装饰类加以抽象，方便客户端统一使用。1234567/** * 一个有打印方法的接口 */public interface IPrintable &#123; // 接口打印方法 void print();&#125; 设计一个实现类可供客户端使用123456789/** * 发票 */public class Order implements IPrintable&#123; @Override public void print() &#123; System.out.println("发票的主题内容"); &#125;&#125; 在开始设计具有真正功能的装饰类之前，先来考虑一下实现的问题。假设有很多装饰类被设计出来，在这些类中一定会有两类代码存在，一类是装饰上的功能代码，在此例中比如打印头部和尾部的代码；另一类是调用被装饰对象的功能代码，在此例中就是Order类的print()方法。在这两类方法中，第一类代码是不重复的，每个类各不一样，但是第二类代码在这些类中却完全一样，这违背了“不要重复自己（Don’t Repeat Youself）DRY”原则，所以在这里需要设计一个所有装饰类的父类来改善这种设计。发票装饰类如下：123456789101112131415161718/** * 发票装饰抽象类 */public abstract class OrderDecorator implements IPrintable&#123; // 用于装饰的私有对象 private IPrintable iprintable; // 构造方法，使用时传入装饰对象 public OrderDecorator(IPrintable iprintable) &#123; this.iprintable = iprintable; &#125; @Override public void print() &#123; // 实现接口方法，注意此处调用装饰对象的对应方法 iprintable.print(); &#125; &#125; 可以打印发票头部信息的类如下所示：123456789101112public class HeaderDecorator extends OrderDecorator&#123; public HeaderDecorator(IPrintable iprintable) &#123; super(iprintable); &#125; @Override public void print() &#123; System.out.println("打印发票头部"); super.print(); &#125;&#125; 可以打印发票尾部的类的代码如下：12345678910111213public class FooterDecorator extends OrderDecorator&#123; public FooterDecorator(IPrintable iprintable) &#123; super(iprintable); &#125; @Override public void print() &#123; super.print(); System.out.println("打印发票尾部"); &#125;&#125; 客户端代码如下：1234567891011121314public class Client &#123; public static void main(String[] args) &#123; IPrintable iprintable = new Order(); iprintable.print(); System.out.println("------------------------------"); iprintable = new FooterDecorator(iprintable); iprintable.print(); System.out.println("------------------------------"); iprintable = new HeaderDecorator(iprintable); iprintable.print(); &#125;&#125; 输出的结果如下：12345678发票的主体内容------------------------------发票的主体内容打印发票尾部------------------------------打印发票头部发票的主体内容打印发票尾部 JDK中装饰模式介绍在JDK中，有很多使用装饰模式的案例，如java.io包中对流的处理。 Java的I/O中装饰模式的体现在Java中流（Stream）是一种有序的字节数据对象。流又分为输入流（InputStream）和输出流（OutputStream）。输入流从外部资源（文件，内存，socket等）读入字节数据到Java对象；输出流则把Java对象（字节数据）写入到外部资源。所有Java I/O都可归类以下两种：（1）字节数据输入输出I/O；（2）字符数据输入输出I/O。在下例中，只研究InputStream类的装饰模式，理解了这一种设计方式，其他的就很好理解了，因为它们的设计方式是很相似的。Java中的I/O体现装饰模式的类图如下：12345678910public class FilterInputStream extends InputStream &#123; // 此输入对象将被增加过滤功能 protected volatile InputStream in; // 构造方法时传入被修饰对象 protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; //其他代码&#125; DataInputStream的部分实现代码如下：12345678910public class DataInputStream extends FilterInputStream implements DataInput &#123; public DataInputStream(InputStream in) &#123; super(in); &#125; public final int read(byte b[]) throws IOException &#123; return in.read(b, 0, b.length); &#125;&#125; 由此可见，JDK中的装饰模式与标准的装饰模式的差别很小。 编写自己的Java I/O装饰者假设现有我有如下的需求：需要将所有输入的字母装换成大写。通过装饰者模式来实现的代码如下：12345678910111213141516171819public class UpperCaseInputStream extends FilterInputStream &#123; protected UpperCaseInputStream(InputStream in) &#123; super(in); &#125; // 一个读取一个字节 public int read() throws IOException &#123; int c = super.read(); return c == -1 ? c : Character.toUpperCase((char) (c)); &#125; // 一次读取len长的字节数组 public int read(byte[] b, int offset, int len) throws IOException &#123; int result = super.read(b, offset, len); for (int i = 0; i &lt; result; i++) &#123; b[i] = (byte) Character.toUpperCase((char) (b[i])); &#125; return result; &#125;&#125; 测试代码如下：1234567891011121314public class InputTest &#123; public static void main(String[] args) &#123; int c; try &#123; InputStream in = new UpperCaseInputStream( new BufferedInputStream(new FileInputStream("E:\\test.txt"))); while ((c = in.read()) &gt;= 0) &#123; System.out.print((char) c); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 原始文件的内容如下1hello world 运行InputTest输出的代码如下： 装饰着模式关键点 装饰模式的作用是可以动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。在实际应用中，装饰模式通常用做给现有的类增加功能，可以根据应用的需要，对装饰模式的类进行任意顺序的包装，最后生成符合要求的对象。注意传统的装饰模式的特点是聚合了被装饰类的接口。在使用上，如果每种装饰类可能抛出不同的异常，则要对异常进行特别处理。开放-关闭原则的设计意义]]></content>
      <categories>
        <category>JAVA设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式模式]]></title>
    <url>%2F2018%2F08%2F17%2Fdesignpattern%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>JAVA设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全面解析Java注解]]></title>
    <url>%2F2018%2F08%2F17%2FJava%2F%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.什么是注解注解是JDK1.5的一个新特性，注解是插入你代码中的一种注释或者说是一种元数据（meta data），即一种描述数据的数据。所以，可以说注解就是源代码的元数据。这些注解信息可以在编译期使用预编译工具进行处理（pre-complier tools），也可以在运行期使用Java反射机制进行处理。注解，其实就是对类，方法，属性进行一种标示，一种注释（注意，这个注释不是为了让我们开发或维护人员阅读更方便，而是为给JVM看），通过这些标示，JVM可以完成这些标示对应的功能。 2.为什么要引入注解注解是JDK1.5引入的功能，但是为什么引入注解呢？在JDK1.5之前，Java还没有引入注解，这个时候如果我们要在Spring中声明一个Bean，我们只能通过xml配置的方式，如下12public class UserService&#123;&#125; 1&lt;bean id="userService" class="com.phicomm.UserService"&gt; 但是有了注解以后，我们可以不必写一个xml配置文件，可以直接在UserService类上完成Bean的声明工作。123@Servicepublic class UserService&#123;&#125; 对于注解的开发方式。我们会发现它和代码结合的很紧密，所以注解比较适合做一些与代码相关度高的操作，例如将bean对应的服务暴露出去，对于xml配置方式。我们会发现它将配置和代码隔离开来了所以XML配置更适合做一些全局的，与具体业务无关的操作。例如全局配置等。基于注解开发还是XML的判断标准应该是：该配置与代码的相关度。如果代码与配置相关度高，那么使用注解配置，否则使用XML配置。 3.JDK提供的注解JDK1.5版本在java.lang.annotation提供了四种元注解，专门注解其他的注解。@Documented：表示使用该注解的元素应被JavaDoc或类似工具文档化，它应用于类型声明，类型声明的注解会影响客户端对注解元素的使用。如果一个类型声明添加了Documented注解，那么它的注解会成为被注解元素的公共API的一部分。@Retention：定义该注解的生命周期，它接收RetentionPolicy参数。RetentionPolicy.SOURCE：在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override，@SuppressWarning都属于这类注解。RetentionPolicy.CLASS：在类加载的时候丢弃。在字节码文件的处理中有用。注释默认使用这种方式。RetentionPolicy.RUNTIME：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。@Target：表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。以下是一些可以用的参数。需要说明的是，属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。ElementType.TYPE:用于描述类、接口或enum声明ElementType.FIELD:用于描述实例变量ElementType.METHODElementType.PARAMETERElementType.CONSTRUCTORElementType.LOCAL_VARIABLEElementType.ANNOTATION_TYPE 另一个注释ElementType.PACKAGE 用于记录java文件的package信息@Inherited：表示一个注解类型会被自动继承，如果用户在类声明的时候查询注解类型，同时类声明中也没有这个类型的注解，那么注解类型会自动查询该类的父类，这个过程将会不停地重复，直到该类型的注解被找到为止，或是到达类结构的顶层（Object）。JDK1.8加入了一种新的注解。@Repeatable：表示注解的值可以取多个。 JDK提供了五种内置注解：@Override：当我们想要覆盖父类的一个方法时，需要使用该注解告知编译器我们正在覆盖一个方法。这样的话，当父类的方法被删除或修改了，编译器会提示错误信息。@Deprecated：当我们想要让编译器知道一个方法已经被弃用（deprecate）时，应该使用这个注解。Java推荐在JavaDoc中提供信息，告知用户为什么这个方法被弃用，以及替代方法是什么。@SuppressWarning：这个注解仅仅告知编译器，忽略它们产生了特殊警告。比如，在Java泛型了使用原始类型。它的保持性策略是SOURCE，在编译器中将被丢弃。@SafeVarargs：参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作，它的存在会阻止编译器产生unchecked这样的警告。在JDK1.7中引入。@FunctionalInterface：函数式接口注解，这个是JDK1.8引入的。 4.创建自定义的注解创建自定义注解需要注意如下：（1）.注解方法不能有参数（2）.注解方法的返回类型局限于原始类型，字符串，枚举，注解，或以上类型构成的数组（3）.注解方法可以包含返回值（4）.注解可以包含与其绑定的元注解，元注解为注解提供信息（5）.如果只有一个参数成员，最好把参数名称设为“value”,后加小括号。创建我们自定义的注解如下：12345678910import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface HelloAnnotation &#123; String value() default "Hai";&#125; 使用我们自己创建的注解1234567@HelloAnnotation(say = "hello world")public class TestMain &#123; public static void main(String[] args)&#123; HelloAnnotation helloAnnotation = TestMain.class.getAnnotation(HelloAnnotation.class); System.out.println(helloAnnotation.value()); &#125;&#125; 输出的运行结果如下： 5.注解的原理5.1 注解获得的具体对象是什么我们在TestMain类的main方法加入如下的代码：12345678910@HelloAnnotation(value = "hello world")public class TestMain &#123; public static void main(String[] args)&#123;// 运行时生成的动态代理对象是可以导出到文件的 System.setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); HelloAnnotation helloAnnotation = TestMain.class.getAnnotation(HelloAnnotation.class); System.out.println(helloAnnotation.getClass().getName()); System.out.println(helloAnnotation.value()); &#125;&#125; 输出的结果如下：而生成的动态代理类如下(省略到部分代码)：1234567891011121314151617181920212223242526272829303132333435public final class $Proxy1 extends Proxy implements HelloAnnotation &#123; private static Method m1; private static Method m2; private static Method m4; private static Method m0; private static Method m3; public $Proxy1(InvocationHandler var1) throws &#123; super(var1); &#125;// 这里生成的代理类重写了我们在注解中定义的方法 public final String value() throws &#123; try &#123; return (String)super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; ... static &#123; try &#123; ... m3 = Class.forName("com.phicomm.annotation.HelloAnnotation").getMethod("value"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 根据“public final class $Proxy1 extends Proxy implements HelloAnnotation”这段代码，可以看出其实HelloAnnotation是一个接口。我们反编译HelloAnntation.class文件，得到如下的结果。Java里面的Annotation的源代码如下：12345678910public interface Annotation &#123; boolean equals(Object obj); int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType();&#125; 接口Annotation被我们自定义的注解HelloAnnotation继承，而HelloAnnotation本质是一个接口，这个接口被代理类$Proxy1.java实现，而HelloAnnotation里面的方法都在$Proxy里面重写。这是JDK动态代理机制实现的。我们在TestMain获得的HelloAnnotation对象，就是由这个代理类生成的。 5.2动态代理类$Proxy1是如何处理helloAnnotation.value()方法的调用的熟悉JDK的动态代理一定会涉及到InvocationHandler，而annotation.value()方法的调用一定是通过绑定在InvocationHandler实例的invoke方法上，通过method.invoke()这种形式调用的。我们下面讲解这部分内容。1234567891011public final class $Proxy1 extends Proxy implements HelloAnnotation &#123; public final String value() throws &#123; try &#123; return (String)super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125;&#125; 由多态的知识我们知道，helloAnnotation.value()的调用最终会转移到代理类$Proxy重写的value()方法上面，最终执行的代码是(String)super.h.invoke(this, m3, (Object[])null);那这里的InvocationHandler的实例是什么？我们再Proxy的构造方法上面加断点，可以看出这里的InvocationHandler实例是AnnocationInvocationHandler的实例而我们的helloAnnotation.value()方法是如何执行的？我们再AnnocationInvocationHandler.java的invoke()方法上加断点单步调试。从上图可以看到，value()方法的返回值是从LinkedHashMap里面获得的。这个map结构的key值是方法名，value值是方法的返回值。我们一步步看这个LinkedHashMap结构是如何构造的。这个LinkedHashMap是在AnnotationParser类的parseAnnotation2方法中构建的。我们单步调试进入parseNumberValue()方法内部反编译TestMain.class的内容，我们获得了如下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124Classfile /D:/reflectStudy/out/production/reflectStudy/com/phicomm/annotation/TestMain.class Last modified 2018-8-18; size 1125 bytes MD5 checksum b6f5e94bc326b15093fbf4b43283ff86 Compiled from "TestMain.java"public class com.phicomm.annotation.TestMain minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #13.#32 // java/lang/Object."&lt;init&gt;":()V #2 = String #33 // sun.misc.ProxyGenerator.saveGeneratedFiles #3 = String #34 // true #4 = Methodref #35.#36 // java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; #5 = Class #37 // com/phicomm/annotation/TestMain #6 = Class #38 // com/phicomm/annotation/HelloAnnotation #7 = Methodref #39.#40 // java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation; #8 = Fieldref #35.#41 // java/lang/System.out:Ljava/io/PrintStream; #9 = Methodref #13.#42 // java/lang/Object.getClass:()Ljava/lang/Class; #10 = Methodref #39.#43 // java/lang/Class.getName:()Ljava/lang/String; #11 = Methodref #44.#45 // java/io/PrintStream.println:(Ljava/lang/String;)V #12 = InterfaceMethodref #6.#46 // com/phicomm/annotation/HelloAnnotation.value:()Ljava/lang/String; #13 = Class #47 // java/lang/Object #14 = Utf8 &lt;init&gt; #15 = Utf8 ()V #16 = Utf8 Code #17 = Utf8 LineNumberTable #18 = Utf8 LocalVariableTable #19 = Utf8 this #20 = Utf8 Lcom/phicomm/annotation/TestMain; #21 = Utf8 main #22 = Utf8 ([Ljava/lang/String;)V #23 = Utf8 args #24 = Utf8 [Ljava/lang/String; #25 = Utf8 helloAnnotation #26 = Utf8 Lcom/phicomm/annotation/HelloAnnotation; #27 = Utf8 SourceFile #28 = Utf8 TestMain.java #29 = Utf8 RuntimeVisibleAnnotations #30 = Utf8 value #31 = Utf8 hello world #32 = NameAndType #14:#15 // "&lt;init&gt;":()V #33 = Utf8 sun.misc.ProxyGenerator.saveGeneratedFiles #34 = Utf8 true #35 = Class #48 // java/lang/System #36 = NameAndType #49:#50 // setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; #37 = Utf8 com/phicomm/annotation/TestMain #38 = Utf8 com/phicomm/annotation/HelloAnnotation #39 = Class #51 // java/lang/Class #40 = NameAndType #52:#53 // getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation; #41 = NameAndType #54:#55 // out:Ljava/io/PrintStream; #42 = NameAndType #56:#57 // getClass:()Ljava/lang/Class; #43 = NameAndType #58:#59 // getName:()Ljava/lang/String; #44 = Class #60 // java/io/PrintStream #45 = NameAndType #61:#62 // println:(Ljava/lang/String;)V #46 = NameAndType #30:#59 // value:()Ljava/lang/String; #47 = Utf8 java/lang/Object #48 = Utf8 java/lang/System #49 = Utf8 setProperty #50 = Utf8 (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; #51 = Utf8 java/lang/Class #52 = Utf8 getAnnotation #53 = Utf8 (Ljava/lang/Class;)Ljava/lang/annotation/Annotation; #54 = Utf8 out #55 = Utf8 Ljava/io/PrintStream; #56 = Utf8 getClass #57 = Utf8 ()Ljava/lang/Class; #58 = Utf8 getName #59 = Utf8 ()Ljava/lang/String; #60 = Utf8 java/io/PrintStream #61 = Utf8 println #62 = Utf8 (Ljava/lang/String;)V&#123; public com.phicomm.annotation.TestMain(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/phicomm/annotation/TestMain; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: ldc #2 // String sun.misc.ProxyGenerator.saveGeneratedFiles 2: ldc #3 // String true 4: invokestatic #4 // Method java/lang/System.setProperty:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 7: pop 8: ldc #5 // class com/phicomm/annotation/TestMain 10: ldc #6 // class com/phicomm/annotation/HelloAnnotation 12: invokevirtual #7 // Method java/lang/Class.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation; 15: checkcast #6 // class com/phicomm/annotation/HelloAnnotation 18: astore_1 19: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 22: aload_1 23: invokevirtual #9 // Method java/lang/Object.getClass:()Ljava/lang/Class; 26: invokevirtual #10 // Method java/lang/Class.getName:()Ljava/lang/String; 29: invokevirtual #11 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 32: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 35: aload_1 36: invokeinterface #12, 1 // InterfaceMethod com/phicomm/annotation/HelloAnnotation.value:()Ljava/lang/String; 41: invokevirtual #11 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 44: return LineNumberTable: line 8: 0 line 9: 8 line 10: 19 line 11: 32 line 12: 44 LocalVariableTable: Start Length Slot Name Signature 0 45 0 args [Ljava/lang/String; 19 26 1 helloAnnotation Lcom/phicomm/annotation/HelloAnnotation;&#125;SourceFile: "TestMain.java"RuntimeVisibleAnnotations: 0: #26(#30=s#31) 从上面可以看到如下的内容12#30 = Utf8 value#31 = Utf8 hello world 可以看到#31与var3的31对应（也就是常量池的索引），对应的值解释hello world。这就是value()方法的调用细节。 总结注解本质上是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke()方法。该方法会从memerValues这里Map中索引出对应的值（这个map结构中自定义注解中的方法名作为key值，value值是方法的返回值）。而memberValues的来源是Java常量池。而给类添加的注解最终体现在类的字节码文件上面。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F08%2F16%2Fdesignpattern%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式为其他对象提供一种代理以控制对这个对象的访问。（Provide a surrogate（代理） for another object to Control access to it[GOF]）GOF所设计的代理模式结构图如下所示：Subject接口：定义了RealSubject和Proxy的共用接口，这样在任何使用RealSubject的地方都可以使用Proxy。RealSubject：定义Proxy可以代表的实体。Proxy：保存一个引用可以访问RealSubject实体。通常和RealSubject一样也实现了Subject接口，它控制着对Subject实体的访问，并能负责创建和销毁它。 静态代理由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。加入现在有如下需求：12345678910111213141516public interface Moveable &#123; void move();&#125;public class Tank implements Moveable &#123; @Override public void move() &#123; System.out.println("tank moving....");// 记录坦克移动的时间 try &#123; Thread.sleep(new Random().nextInt(100000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 问题1：现在我有个需求，我想获得一个方法的具体运行时间，如何实现？可能你会这回做1234567891011121314public class Tank implements Moveable &#123; @Override public void move() &#123; long start = System.currentTimeMillis(); System.out.println("tank moving...."); try &#123; Thread.sleep(new Random().nextInt(100000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("time:" + (end - start)); &#125;&#125; 问题2：假如你无法修改move()方法的源码，比如说这个方法是别人的jar包里面别人提供给你的，是已经写好的源代码，就编译了class给你，这个时候没有办法在源码的基础上面修改，你想计算这个方法运行了多长时间怎么办？可能你会这么做，用继承的方式实现12345678910public class Tank2 extends Tank &#123;// 继承的实现 @Override public void move() &#123; long start = System.currentTimeMillis(); super.move(); long stop = System.currentTimeMillis(); System.out.println(stop - start); &#125;&#125; 也可能会用聚合的方式实现123456789101112131415public class Tank3 implements Moveable &#123;// 聚合的方式实现 private Tank tank; public Tank3(Tank tank) &#123; super(); this.tank = tank; &#125; @Override public void move() &#123; long start = System.currentTimeMillis(); tank.move(); long stop = System.currentTimeMillis(); System.out.println(stop - start); &#125;&#125; 问题3：我想将功能在上面进行叠加，先记录日志，后记录时间，怎么处理？还是用继承？可能还要加权限的检查，你又怎么处理？如果还用继承的方式实现，将出现的类爆炸，根本无法实行。1234567891011121314151617public class TankTimeProxy implements Moveable &#123; // 聚合的方式实现 private Moveable moveable; public TankTimeProxy(Moveable moveable) &#123; super(); this.moveable = moveable; &#125; @Override public void move() &#123; long start = System.currentTimeMillis(); System.out.println("开始时间：" + start); moveable.move(); long stop = System.currentTimeMillis(); System.out.println("结束时间：" + stop); System.out.println(stop - start); &#125;&#125; 用于记录日志的代理类1234567891011121314public class TankLogProxy implements Moveable &#123; // 聚合的方式实现 private Moveable moveable; public TankLogProxy(Moveable moveable) &#123; super(); this.moveable = moveable; &#125; @Override public void move() &#123; System.out.println("日志记录，tank start"); moveable.move(); System.out.println("日志记录，tank stop"); &#125;&#125; 客户端这样调用就可以实现先记录时间，后记录日志的功能123456789public class Client &#123; public static void main(String[] args) &#123; Moveable moveable = new Tank(); TankLogProxy tankLogProxy = new TankLogProxy(moveable); TankTimeProxy tankTimeProxy = new TankTimeProxy(tankLogProxy); tankTimeProxy.move(); &#125;&#125; 从上面可以看出，聚合比继承要好用的多。通过代理之间的组合，可以将多种功能组合起来。 问题4：假设Moveable接口里面有多个方法，怎么处理？假如我需要计算100类的中方法的计算时间，那么我们需要重新写100个代理类，代理类的数量也在无线的膨胀，这是一件无法忍受的事情。我们可以根据接口去生成代理对象，用动态代理去做。 动态代理-你不必知道我存在动态代理：在程序运行时，运行反射机制动态创建而成。动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。还有一种动态代理CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类实现代理。通过在运行时，动态修改字节码达到修改类的目的。 模拟JDK的实现假设被代理的对象都实现了某个接口，代理的时候是根据接口生成代理对象（这里的接口我们选择自己创建的Moveable接口）。我们自己创建的Proxy如下所示，专门用来生成记录时间的代理类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Proxy &#123; public static Object newProxyInstance() throws Exception&#123;// 根据这段源码动态编译出代理对象 String src = "package com.phicomm.proxy;" + "public class TankTimeProxy implements Moveable &#123;"+ "private Moveable moveable;" + "public TankTimeProxy(Moveable moveable) &#123;" + "super();" + "this.moveable = moveable;" + "&#125;" + "@Override " + "public void move() &#123;" + "long start = System.currentTimeMillis();" + "System.out.println(\"开始时间：\" + start);" + "moveable.move();" + "long stop = System.currentTimeMillis();" + "System.out.println(\"结束时间：\" + stop);"+ "System.out.println(stop - start);" + "&#125;" + "&#125;";// 写入源文件 String fileName = System.getProperty("user.dir") + "/src/com/phicomm/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); // compile JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); // load into memory and create an instance// 解析本地的文件 URL[] urls = new URL[] &#123; new URL("file:/" + System.getProperty("user.dir") + "/src") &#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.phicomm.proxy.TankTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Moveable.class); return ctr.newInstance(new Tank()); &#125;&#125; 我们再测试的时候，不用管代理类的类名，直接就可以通过自己写的Proxy获得代理对象。123456public class Test &#123; public static void main(String[] args) throws Exception &#123; Moveable moveable = (Moveable) Proxy.newProxyInstance(); moveable.move(); &#125;&#125; 这样我们就获得了可以记录坦克运行时间的代理类。问题5：现在我产生的代理只能够去代理Moveable接口的这样一种代理，并且只有记录时间的功能。那我需要它实现其他功能怎么办？实现其他接口的代理怎么办？我们现在就完全模拟JDK的动态代理去实现。我们自己设计InvocationHandler类如下1234567public interface InvocationHandler &#123; /** * @param object 代理类的类名 * @param method 被代理的对象实现的接口的方法实例 */ void invoke(Object object,Method method) ;&#125; 动态的代理类由如下的代码生成。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.phicomm.realProxy;import java.io.File;import java.io.FileWriter;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import javax.tools.JavaCompiler;import javax.tools.StandardJavaFileManager;import javax.tools.ToolProvider;import javax.tools.JavaCompiler.CompilationTask;public class Proxy &#123;// 简单起见，这里只有一个接口，传入一个接口，而不是一个接口数组// 传入被代理的对象实例 public static Object newInstance(Class infce,InvocationHandler handler) throws Exception&#123; String rt = "\r\t"; Method[] methods = infce.getMethods(); String methodStr = ""; for(Method method:methods)&#123;// 代理类重写接口里面的方法 methodStr += "@Override" + rt + "public void " + method.getName() + "() &#123;" + rt + " try &#123;" + rt + " Method md = " + infce.getName() + ".class.getMethod(\"" + method.getName() + "\");" + rt + " h.invoke(this,md);" + rt + " &#125;catch(Exception e) "+ rt+ " &#123;e.printStackTrace();&#125;" + rt + "&#125;"; &#125;// 代理类的构造方法里面将被代理类的对象注入进去 String src = "package com.phicomm.realProxy;" + rt + "import java.lang.reflect.Method;" + rt + "public class $Proxy1 implements " + infce.getName() + "&#123;" + rt + " public $Proxy1(InvocationHandler h) &#123;" + rt + " this.h = h;" + rt + " &#125;" + rt + " com.phicomm.realProxy.InvocationHandler h;" + rt + methodStr + "&#125;"; String fileName = "d:/src/com/phicomm/realProxy/$Proxy1.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); // 生成代理类的字节码文件 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units); t.call(); fileMgr.close(); // load into memory and create an instance// 解析本地的文件 URL[] urls = new URL[] &#123; new URL("file:/" + "d:/src/") &#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.phicomm.realProxy.$Proxy1"); System.out.println(c); Constructor ctr = c.getConstructor(InvocationHandler.class); return ctr.newInstance(handler); &#125;&#125; 最终，自己写的代理类就完成了。被代理的类如下：12345678910111213141516171819public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target)&#123; this.target = target; &#125; @Override public void invoke(Object object,Method method) &#123; System.out.println(object.getClass().getName()); System.out.println("开始记录时间"); try &#123; method.invoke(target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("记录时间结束"); &#125;&#125; 这样我们就可以用自己写的代理类去实现动态代理。12345678public class Client &#123; public static void main(String[] args) throws Exception &#123;// 传入被代理的对象 MyInvocationHandler myInvocationHandler = new MyInvocationHandler(new Tank()); Moveable moveable = (Moveable) Proxy.newInstance(Moveable.class, myInvocationHandler); moveable.move(); &#125;&#125; 在JDK的动态代理中，过程与上面类似。JDK最终生成的代理类的形式为 public final class $Proxy0 extend Proxy implemnets Moveable { ... public final void save() throws { try { // m3为m3 = Class.forName("com.phicomm.realProxy.Moveable").getMethod("move"); // 通过反射区获取 // h为我们自己实现的MyInvocationHandler，this为生成的代理类对象$Proxy0， // 最终调用的MyInvocationHandler里面的invoke()方法 super.h.invoke(this, m3, (Object[])null) } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } ... }]]></content>
      <categories>
        <category>JAVA设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Recover Binary Search Tree]]></title>
    <url>%2F2018%2F03%2F03%2Fleetcode%2F99.Recover%20Binary%20Search%20Tree%2F</url>
    <content type="text"><![CDATA[题目描述Recover Binary Search Tree(难度级别：Hard) Description:Two elements of a binary search tree (BST) are swapped by mistake.Recover the tree without changing its structure.Example:Example 1:Example 2:Follow up:A solution using O(n) space is pretty straight forward.Could you devise a constant space solution? 解题报告method0这道题最直观的解法就是：二叉排序树中序遍历得到是有序的。中序遍历完一遍以后，重新赋值一遍即可。这个解法可以面向n个元素错位的情况。12345678910111213141516171819202122232425262728293031323334class Solution&#123; /** * @Title: recoverTree * @Description: BST(Binary Search Tree)的两个元素被错误的交换， * 在不改变其结构的前 提下恢复树(一种很直观的解法,可针对任意数目 * 的节点错乱的情况,该解法的空间复杂度为O(n)) * @param root * @return void */ private List&lt;TreeNode&gt; treeNodeList = new ArrayList&lt;TreeNode&gt;(); private List&lt;Integer&gt; treeValueList = new ArrayList&lt;Integer&gt;(); public void recoverTree(TreeNode root) &#123; if (null == root) &#123; return; &#125; inOrder(root); Collections.sort(treeValueList); for (int i = 0; i &lt; treeNodeList.size(); i++) &#123; treeNodeList.get(i).val = treeValueList.get(i); &#125; &#125; private void inOrder(TreeNode root) &#123; if (null == root) &#123; return; &#125; inOrder(root.left); treeNodeList.add(root); treeValueList.add(root.val); inOrder(root.right); &#125;&#125; method1采用双指针代替一维向量。但是这里用到了递归，空间复杂度也不是O(1)。这里需要三个指针，first,second分别表示第一个和第二个错乱位置的节点，pre指向当前节点的中序遍历的前一个节点。这里用传统的中序遍历来做，不过在应该输出节点值的地方，换成了判断pre和当前节点值的大小，如果pre的大，若first为空，则将first指向pre值的节点，把second指向当前节点。这样中序遍历完整个树，若first和second都存在，则交换它们节点值即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; private TreeNode pre;// 当前节点的中序遍历的前一个节点 private TreeNode first;// 第一个错乱位置的节点 private TreeNode second;// 第二个错乱位置的节点 /** * @Title: recoverTreeII * @Description: BST(Binary Search Tree)的两个元素被错误的交换，在不改变其结构的前提下恢复树 * @param root * @return void */ public void recoverTreeII(TreeNode root) &#123; pre = null; first = null; second = null; inOrderII(root); if (first != null &amp;&amp; second != null) &#123; int temp = first.val; first.val = second.val; second.val = temp; &#125; &#125; private void inOrderII(TreeNode root) &#123; if (root == null) &#123; return; &#125; inOrderII(root.left); // 这里用传统的中序遍历递归来做，不过在应该输出节点值的地方，换成了判断pre和当前节点值的大小。 // 如果pre的大，若first为空，则将first指向pre指的节点，把second指向当前节点。这样中序遍历 // 完整个树，若first和second都存在，则交换它们的节点值即可 if (pre == null) &#123; pre = root; &#125; else &#123; if (pre.val &gt; root.val) &#123; if (first == null) &#123; first = pre; &#125; second = root; &#125; pre = root; &#125; inOrderII(root.right); &#125;&#125; method2前两种方法都涉及到了递归操作，所以这两种方法的空间复杂度都要高于O(n)。为了达到O(n)的时间复杂度，其实这道题的解法是需要你了解二叉树的marris traversal遍历这种方法。这种遍历方法可以用O(1)的空间复杂度对二叉树进行遍历，是二叉树的一种非递归遍历方法。这种方法应该是符合题目要求的解答。这种解法后续看懂marris traversal的时候在补充。Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中switch具体实现细节]]></title>
    <url>%2F2017%2F12%2F09%2FJava%2FJava%E4%B8%ADswitch%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[switch case语句在很多编程语言中的功能都是等于条件判断，Java中为多路分支选择流程专门提供了switch语法，switch语句根据多个表达式的值，选择运行多个操作中的一个。当需要对选项进行等值判断时，使用switch语句更加简洁明了。switch的case语句可以处理int，short，byte，char类型的值。在JDK5以后可以是枚举类型，JDK7以后可以是String类型。但是，这里有个疑问，JDK5和JDK7以后，switch的语法为何可以使用非整形的类型。这篇文章主要揭开Java中当switch语句中的表达式为String和枚举的时候是如何处理的。 Java中的switch的语法switch的基本语法如下所示：1234567switch(表达式)&#123; case 表达式常量1：语句1； break； case 表达式常量2：语句2； break； ...... case 表达式常量n：语句n； break； [default：语句n+1；] &#125; 其中，一个case表达式常量成为标号，代表一个case分支的入口。switch语句在运行时首先计算switch圆括号中“表达式”的值，这个值必须是整形或字符串型的，同时后面各个case表达式常量的值的类型应与switch圆括号中“表达式”的值类型一致。一个case语句代表一个制定操作，然后转向结构出口。default子句是可选的，当表达式的值和case表达式常量的值都不匹配时，就运行default子句，转向结构出口。 本质特征当case表达式的类型是基本类型123456789101112131415161718public static void demo1(int caseNumber) &#123; switch (caseNumber) &#123; case 1: System.out.println("您是通过搜索引擎来到本网站的。"); break; case 2: System.out.println("您是通过朋友介绍来到本网站的。"); break; case 3: System.out.println("您是通过报刊杂志来到本网站的。"); break; case 4: System.out.println("您是通过其它方法来到本网站的。"); break; default: System.out.println("错误的选择！请输入１～４的数字做出选择。"); &#125;&#125; break:break使得程序在执行完选中的分支后，可以跳出整个switch语句，完成switch。如果没有这个break，程序将在继续前进到下一个分支，直到遇到后面的break或者switch完成。default:是可选的。如果没有default，程序在找不到匹配的case分支后，将在switch语句范围内不做什么事，直接完成switch。不过，无论default在switch语句中的哪个位置，JVM都会先找case，从第一个找到case开始执行，如果所有的case都不满足条件，才会执行default。 当case表达式的类型String类型JDK1.7以后，case表达式的类型可以为String类型。看下面这个例子。1234567891011121314public class StringInSwitchCase &#123; public static void stringInSwitchCase(String mode) &#123; switch (mode) &#123; case "ACTIVE": System.out.println("Application is running on Active mode"); break; case "PASSIVE": System.out.println("Application is running on Passive mode"); break; case "SAFE": System.out.println("Application is running on Safe mode"); &#125; &#125;&#125; 我们反编译上面的代码得到的反编译代码如下：12345678910111213141516171819202122232425public class StringInSwitchCase &#123; public StringInSwitchCase() &#123; &#125; public static void stringInSwitchCase(String mode)&#123; String s; switch ((s = mode).hashCode())&#123; default: break; case -74056953: if (s.equals("PASSIVE")) System.out.println("Application is running on Passive mode"); break; case 2537357: if (s.equals("SAFE")) System.out.println("Application is running on Safe mode"); break; case 1925346054: if (s.equals("ACTIVE")) System.out.println("Application is running on Active mode"); break; &#125; &#125;&#125; 看到这个代码，你就可以知道原来字符串的switch是通过hashcode()和equals()方法来实现的。记住，switch语句中的表达式只能使用整形，而hashcode()方法返回的int，而不是long。进行switch的实际是哈希值，然后通过使用equals()方法比较进行安全检查，这个检查是必要的，因为哈希可能发生碰撞。这就是Java1.7如何实现的字符串switch，它使用hashcode()来进行switch，然后通过squals方法验证。这其实是一个语法糖，而不是什么内建的本地功能。 当case表达式的类型为枚举类型JDK1.5以后，case表达式的类型可以为枚举类型。看下面这个例子。123456789101112131415161718192021public enum Season &#123; SPRING,SUMMER,AUTUMN,WINTER;&#125;public class EnumInSwitchCase &#123; public static void enumInSwitchCase(Season season) &#123; switch (season) &#123; case SPRING: System.out.println(season.name()); break; case SUMMER: System.out.println(season.name()); break; case AUTUMN: System.out.println(season.name()); break; case WINTER: System.out.println(season.name()); break; &#125; &#125;&#125; 我们反编译上面的代码得到的反编译代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class EnumInSwitchCase&#123; private static int $SWITCH_TABLE$com$phicomm$switchdemo$Season[]; public EnumInSwitchCase() &#123; &#125; public static void enumInSwitchCase(Season season) &#123; switch ($SWITCH_TABLE$com$phicomm$switchdemo$Season()[season.ordinal()]) &#123; case 1: // '\001' System.out.println(season.name()); break; case 2: // '\002' System.out.println(season.name()); break; case 3: // '\003' System.out.println(season.name()); break; case 4: // '\004' System.out.println(season.name()); break; &#125; &#125; static int[] $SWITCH_TABLE$com$phicomm$switchdemo$Season() &#123; $SWITCH_TABLE$com$phicomm$switchdemo$Season; if ($SWITCH_TABLE$com$phicomm$switchdemo$Season == null) goto _L2; else goto _L1_L1: return;_L2: JVM INSTR pop ; int ai[] = new int[Season.values().length]; try &#123; ai[Season.AUTUMN.ordinal()] = 3; &#125; catch (NoSuchFieldError ) &#123; &#125; try &#123; ai[Season.SPRING.ordinal()] = 1; &#125; catch (NoSuchFieldError ) &#123; &#125; try &#123; ai[Season.SUMMER.ordinal()] = 2; &#125; catch (NoSuchFieldError ) &#123; &#125; try &#123; ai[Season.WINTER.ordinal()] = 4; &#125; catch (NoSuchFieldError ) &#123; &#125; return $SWITCH_TABLE$com$phicomm$switchdemo$Season = ai; &#125;&#125; 看到这个代码，你就可以知道原来枚举类型的switch也本质是通过整形来实现的。season.ordinal()返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零，然后构建$SWITCH_TABLE$com$phicomm$switchdemo$Season[]这个int型的数组。 总结以上就是switch中当表达式为String，枚举类型的时候的实现细节，发现在代码底层都是将switch语句中的表达式转为int类型。但是，实现编码过程中，String类型作为switch语句的表达式用的还不是很多。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全面解析Java枚举]]></title>
    <url>%2F2017%2F12%2F08%2FJava%2Fjava%20enum%2F</url>
    <content type="text"><![CDATA[1.什么是枚举枚举类型是Java5中新增特性的一部分，它是一种特殊的数据类型。 1.在某些情况下，一个类的对象是有限且固定的，如季节类，它只有春夏秋冬4个对象。这种实例有限且固定的类，在Java中被称为枚举类。2.在Java中，使用enum关键字来使用枚举类。3.枚举类是一种特殊的类，它和普通的类一样，有自己的成员变量，成员方法，构造方法（构造方法只能使用private访问修饰符，所以无法从外部调用构造方法，构造方法只在构造枚举值时被调用）。4.使用enum定义枚举类默认继承了java.lang.Enum类，并实现了java.lang.Seriablizable和java.lang.Comparable两个接口。5.所有的枚举值都是public static final的，且非抽象的枚举类不能在派生子类。6.枚举类的所有实例（枚举值）必须在枚举类的第一行显示地列出，否则这个枚举类将永远不能产生实例。列出这些枚举实例（枚举值）时，系统会自动添加public static fianl修饰，无需程序员显示添加。 2.创建自定义的枚举类型2.1不包含抽象方法的枚举类12345//定义一个季节的枚举类public enum Season &#123;// 在第一行显示的列出4个枚举实例，系统会自动添加public static final修饰 SPRING, SUMMER, AUTUMN, WINTER;&#125; 我们给这个枚举类中添加成员变量和成员方法12345678910111213141516171819202122public enum Season &#123;// 因为已经定义了带参数的构造方法，所以在列出枚举值时必须传入对应的参数 SPRING("春天",0), SUMMER("夏天",1), AUTUMN("秋天",2), WINTER("冬天",3); private String seasonName; private int seasonId; // 定义一个带参数的构造方法，枚举类的构造方法只能使用private修饰 private Season(String seasonName,int seasonId)&#123; this.seasonId = seasonId; this.seasonName = seasonName; &#125; public String getSeasonName()&#123; return seasonName; &#125; public int getSeasonId()&#123; return seasonId; &#125; &#125; 2.2 包含抽象方法的枚举类12345678910111213141516171819202122232425262728public enum Operation &#123; PLUS &#123; @Override public int calculate(int x, int y) &#123; return x + y; &#125; &#125;, MINUS &#123; @Override public int calculate(int x, int y) &#123; return x - y; &#125; &#125;, MULTIPLY &#123; @Override public int calculate(int x, int y) &#123; return x * y; &#125; &#125;, DIVIDE &#123; @Override public int calculate(int x, int y) &#123; return x / y; &#125; &#125;; public abstract int calculate(int x, int y);&#125; 3.枚举的原理而我们反编译这个定义好的Season.class枚举类，得到如下的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public final class Season extends Enum &#123;// 我们自己定义的4种枚举实例 public static final Season SPRING; public static final Season SUMMER; public static final Season AUTUMN; public static final Season WINTER; private String seasonName; private int seasonId; private static final Season ENUM$VALUES[];// 私有的构造方法 private Season(String s, int i, String seasonName, int seasonId) &#123; super(s, i); this.seasonId = seasonId; this.seasonName = seasonName; &#125; public String getSeasonName() &#123; return seasonName; &#125; public int getSeasonId() &#123; return seasonId; &#125; public static Season getSeason(int seasonId) &#123; switch (seasonId) &#123; case 0: // '\0' return SPRING; case 1: // '\001' return SUMMER; case 2: // '\002' return AUTUMN; case 3: // '\003' return WINTER; &#125; return SPRING; &#125;// 编译器为我们添加的静态的values()方法 public static Season[] values() &#123; Season aseason[]; int i; Season aseason1[]; System.arraycopy(aseason = ENUM$VALUES, 0, aseason1 = new Season[i = aseason.length], 0, i); return aseason1; &#125;// 编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf()方法 public static Season valueOf(String s) &#123; return (Season) Enum.valueOf(com / phicomm / test / Season, s); &#125; static &#123;// 实例化枚举实例 SPRING = new Season("SPRING", 0, "春天", 0); SUMMER = new Season("SUMMER", 1, "夏天", 1); AUTUMN = new Season("AUTUMN", 2, "秋天", 2); WINTER = new Season("WINTER", 3, "冬天", 3); ENUM$VALUES = (new Season[] &#123; SPRING, SUMMER, AUTUMN, WINTER &#125;); &#125;&#125; 从反编译的代码可以看出编译器为我们生成了一个Season类（注意该类被final修饰，将无法被继承），而且该类继承自java.lang.Enum类（该类是一个抽象类）。并且生成了两个静态方法，value()和valueOf()方法。 3.1枚举类中的常用方法1.int comare(E o):该方法用于与制定枚举对象比较顺序，同一个枚举实例只能与相同类型的枚举实例比较。如果该枚举对象位于指定枚举对象之后，则返回正整数；反之返回负整数。否则，返回零。2.String name():返回此枚举类的名称，及枚举值。3.static values():返回一个包含全部枚举值的数组，可以用来遍历所有枚举值。4.String toString():返回枚举值的名称，与name方法类似。5.int ordinal():返回枚举值在枚举类中的索引值（从0开始），及枚举值在枚举生命中的顺序，这个循序依据枚举值声明的顺序而定。6.static valueOf(String s):返回带指定名称的指定枚举类型的枚举常量，名称必须与在此类型中声明枚举常量所用的标识符完全匹配（不允许使用额外的空白字符）。这个方法与toString()对应，因此重写toString()方法，一定要重写valueOf()方法。7.boolean equals()：比较两个枚举类对象的引用。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[KNN]]></title>
    <url>%2F2017%2F12%2F05%2FKNN%2F</url>
    <content type="text"></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Object类概述]]></title>
    <url>%2F2017%2F11%2F16%2FJava%2FObject%E7%B1%BB%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是Object类 java.lang.Object类Object是类层次结构的根类。每个类都使用Object作为超类。它位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。所有对象（包括数组）都实现这个类的方法。在不明确给出超类的情况下，Java会自动把Object作为要定义类的超类。 Object类方法有哪些 Object类没有定义属性，一个有13个方法。 类构造器public Object() 大部分情况下，Java中通过形如new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。为体现此特性，Java中规定，在类定义过程中，对于未定义构造函数的类，默认都会有一个无参数的构造函数。当然做为所有类的基类，Object类自然也要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。 private static native void registerNatives() registerNatives函数前面有native关键字修饰，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中完成，而是有C/C++去完成，并被编译成.dll，由Java去调用。方法的具体实现体现在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法。 protected native Object clone() throws CloneNotSupportedException 创建并返回此对象的一个副本。clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别专用不同的堆空间。clone()的正确调用需要实现cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。Cloneable接口仅是一个标记接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。 public final native Class&lt;?&gt; getClass() getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。类对象：在Java中，类是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性。因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称为“类对象”。 public boolean equals(Object obj) ==与equals在Java中经常被使用。两者的区别如下：==针对基本类型，比较的是值是否相同，针对引用类型，比较的是地址值是否相同；equals()只能比较引用类型，默认情况下，比较的是地址值是否相同，但是，我们可以根据自己的需要重写该方法。以String类equals()方法为例，用于比较两个字符串内容是否相等。123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; public native int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。hashCode()具有如下约定：1.在Java应用程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希哈是相同的，前提是将对象进行equals比较时所用的信息未做修改。在Java应用程序的一次执行到另一次执行，同一对象的hashCode()返回的哈希码无须保持一致；2.如果两个对象相等(调用equals()方法)，那么这两个对象调用hashCode()返回的哈希码也必须相等；3.反之，两个对象调用hashCode()返回的哈希码相等，这两个对象不一定相等即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt; equals()相等 =&gt; hashCode()相等。因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等 =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。再次以String类的hashCode为例:123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; public String toString()返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：getClass().getName() + ‘@’ + Integer.toHexString(hashCode()) public final native void wait(long timeout) throws InterruptedException在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。 public final void wait(long timeout, int nanos) throws InterruptedException在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。timeout - 要等待的最长时间（以毫秒为单位）。nanos - 额外时间（以毫微秒为单位，范围是 0-999999）。 public final void wait() throws InterruptedException在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样 public final native void notify()唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 public final native void notifyAll()唤醒在此对象监视器上等待的所有线程 protected void finalize() throws Throwablefinalize方法主要与Java垃圾收集机制有关。在Object中定义finalize方法被定义成一个空方法，为什么要如此定义呢?finalize方法的调用时机是怎么样的呢？首先，Object中定义finalize方法表名Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对象所占用空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是我们主动去调用的(虽然可以主动去调用，此时与其他自定义方法无异)]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的代码块]]></title>
    <url>%2F2017%2F11%2F09%2FJava%2FJava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[代码块：在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。 局部代码块 定义：在方法、循环、判断等语句中出现的代码块修饰：只能用标签修饰位置：普通代码可以出现在方法体内除“()”外的任何地方，包括方法体，代码块（即可以嵌套在代码块中）执行：局部代码块依赖方法的执行而执行，按照正常的先后顺序执行作用：限定变量的生命周期，及早释放，提高内存的利用率 构造代码块 定义：在类中定义且没有加任何修饰的代码块位置：在类中，方法外出现，用{}括起来的代码执行：依赖构造函数的调用而执行作用：初始化实例变量和实例环境，一般用于提取构造函数中的公共代码注意：构造代码块不是在构造函数之前执行的！编译器在编译的时候会把构造代码块插入到每个构造函数的最前面。构造代码块随着构造函数的执行而执行。如果某个构造函数调用了其他的构造函数，那么构造代码块不会插入到该构造函数中一面构造代码块执行多次。举例如下：原始的.java文件如下123456789101112131415161718192021public class ConstructorsBolckTest &#123; public String name; public int age; &#123; System.out.println("我是构造代码块"); &#125; public ConstructorsBolckTest() &#123; &#125; public ConstructorsBolckTest(String name, int age) &#123; this(name);// 调用了ConstructorsBolckTest(String name) this.age = age; &#125; public ConstructorsBolckTest(String name) &#123; this.name = name; &#125;&#125; 然后将编译的.class文件反编译的结果如下12345678910111213141516171819202122232425import java.io.PrintStream;public class ConstructorsBolckTest&#123; public String name; public int age; public ConstructorsBolckTest() &#123; System.out.println("我是构造代码块"); &#125; public ConstructorsBolckTest(String name, int age) &#123; this(name); this.age = age; &#125; public ConstructorsBolckTest(String name) &#123; System.out.println("我是构造代码块"); this.name = name; &#125;&#125; 静态代码块 定义：在类定义中用static修饰的代码块修饰：使用static修饰位置：出现在类中的成员变量位置处执行：在加载类时会先执行静态代码块，且只执行一次，如果有多个静态代码块则按照先后顺序执行作用：一般用于静态变量的初始化，创建对象前的环境的加载注意：静态代码块中不能直接访问非静态变量和方法，需要通过类的实例对象来访问 同步代码块 定义：可以简单认为同步代码块是使用synchronzied修饰的普通代码块位置：同局部代码块执行：同局部代码块作用：用于多线程环境的同步保护注意：同步代码块使用不当会造成死锁 面试题 1.静态代码块，构造代码块，构造方法的执行顺序执行顺如如下：I,静态代码块；II，构造代码块；III，构造方法。并且，静态代码块只执行一次；在加载类时就执行一次。构造代码块每次调用构造方法都会执行。2.写出如下代码的执行结构123456789101112131415161718192021222324252627public class Fu &#123; static &#123; System.out.println("静态代码块Fu"); &#125; &#123; System.out.println("构造代码块Fu"); &#125; public Fu()&#123; System.out.println("构造方法Fu"); &#125;&#125;public class Zi extends Fu&#123; static&#123; System.out.println("静态代码块Zi"); &#125; &#123; System.out.println("构造代码块Zi"); &#125; public Zi()&#123; System.out.println("构造方法Zi"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125; 执行结构如下,因为子类初始化之前，会先进行父类的初始化123456静态代码块Fu静态代码块Zi构造代码块Fu构造方法Fu构造代码块Zi构造方法Zi 3.写出如下程序的执行结果123456789101112131415161718192021public class X &#123; Y b = new Y(); X()&#123; System.out.println("X"); &#125;&#125;public class Y &#123; Y()&#123; System.out.println("Y"); &#125;&#125;public class Z extends X&#123; Y y = new Y(); Z()&#123; super();//仅仅表示要先初始化父类数据,再初始化子类数据 System.out.println("Z"); &#125; public static void main(String[] args) &#123; new Z(); &#125;&#125; 执行结果如下1234YXYZ 成员变量初始化的步骤如下：先进行默认初始化，（int型默认是0，boolean默认为flase,Object型默认为null），再进行显示初始化，最后在构造函数中进行初始化。父子类中，先初始化父类数据,再初始化子类数据。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中的内部类总结]]></title>
    <url>%2F2017%2F11%2F09%2FJava%2FJava%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类定义 内部类：可以将一个类的定义放在另一个类的定义内部，这个类就是内部类。为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类没有影响。其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特征（摘自《Think in Java》）1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。3.创建内部类对象的时刻并不依赖于外围类对象的创建。4.内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。5.内部类提供了更好的封装，除了该外围类，其他类都不能访问。 内部类基础在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。123456789101112131415161718192021222324252627package com.phicomm.innerclass;public class OuterClass &#123; private String name; private int age; ··· 省略get()和set()方法 ··· public class InnerClass &#123; public InnerClass() &#123; name = "chenssy"; age = 23; &#125; public void display() &#123; System.out.println("name:" + getName() + ";age" + getAge()); &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.display(); &#125;&#125; 在这个应用程序中，我们可以看到内部类InnerClass可以访问外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们再访问外围类的成员时，就会用这个引用来选择外围类的成员。其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型。OutClassName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outClass.new InnerClass();同时，如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点是在编译器就知晓了，没有任何运行时的成本。1234567891011121314151617public class OuterClass &#123; public void display()&#123; System.out.println("OuterClass..."); &#125; public class InnerClass&#123; public OuterClass getOuterClass()&#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().display(); &#125;&#125; 到这里我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个Class文件：OuterClass.class和OuterClass$Inner.class。在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 成员内部类成员内部类也是最普通的内部类，它是外围类的一个成员，所以它是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法，则需要通过内部类实例来访问。在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二:成员内部类是依附于外围类，，所以只有先创建了外围类才能够创建内部类。12345678910111213141516171819202122232425262728public class OuterClass &#123; private String str; public void outerDisplay()&#123; System.out.println("outerClass..."); &#125; public class InnerClass&#123; public void innerDisplay()&#123; //使用外围内的属性 str = "innerClass..."; System.out.println(str); //使用外围内的方法 outerDisplay(); &#125; &#125; /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */ public InnerClass getInnerClass()&#123; return new InnerClass(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.getInnerClass(); inner.innerDisplay(); &#125;&#125; 局部内部类有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所有就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。定义在方法里面12345678910111213141516171819public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation("chenssy"); &#125;&#125; 定义在作用域内1234567891011121314151617181920212223242526public class Parcel6 &#123; private void internalTracking(boolean b)&#123; if(b)&#123; class TrackingSlip&#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip("chenssy"); String string = ts.getSlip(); &#125; &#125; public void track()&#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 parcel6 = new Parcel6(); parcel6.track(); &#125;&#125; 匿名内部类在做Swing编程中，我们经常使用这种方式来绑定事件123456button2.addActionListener( new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("你按了按钮二"); &#125; &#125;); 这个内部类是没有名字的，再看如下这个例子：1234567891011121314151617181920public class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;; /* 注意：分号不能省 */ &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, "chenssy"); System.out.println(inner.getNumber()); &#125;&#125;interface InnerClass &#123; int getNumber();&#125; 这里我们就需要看清几个地方：1.匿名内部类是没有访问修饰符的。2.new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。3.注意getInnnerClass()方法的形参，第一个形参是用final修饰的，第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。4.匿名内部类是没有构造方法的，因为它连名字都没有何来构造方法。 静态内部类使用static修饰的内部类我们称为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1.它的创建是不需要依赖于外围类的。2.它不能使用任何外围类的非static成员变量和方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class OuterClass &#123; private String sex; public static String name = "hello world"; /** *静态内部类 */ static class InnerClass1&#123; /* 在静态内部类中可以存在静态成员 */ public static String _name1 = "hello world _static"; public void display()&#123; /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println("OutClass name :" + name); &#125; &#125; /** * 非静态内部类 */ class InnerClass2&#123; /* 非静态内部类中不能存在静态成员 */ public String _name2 = "chenssy_inner"; /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display()&#123; System.out.println("OuterClass name：" + name); &#125; &#125; public void display()&#123; /* 外围类访问静态内部类：内部类. */ System.out.println(InnerClass1._name1); /* 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 */ OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); /* 访问非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.display(); &#125;&#125; 上面这个例子充分体现了静态内部类和非静态内部类的区别。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Median of Two Sorted Arrays]]></title>
    <url>%2F2017%2F10%2F15%2FJava%2FMedian-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[Description:There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).Example 1:123nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:123nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 这种方法是在Assume that the number of elements in A and B are both larger than k/2, and if we compare the k/2-th smallest element in A(i.e. A[k/2-1]) and the k-th smallest element in B(i.e. B[k/2 - 1]), there are three results:(Becasue k can be odd or even number, so we assume k is even number here for simplicy. The following is also true when k is an odd number.)A[k/2-1] = B[k/2-1]A[k/2-1] &gt; B[k/2-1]A[k/2-1] &lt; B[k/2-1]if A[k/2-1] &lt; B[k/2-1], that means all the elements from A[0] to Ak/2-1 are in the range of k smallest elements in the union of A and B. Or, in the other word, A[k/2 - 1] can never be larger than the k-th smalleset element in the union of A and B.Why?We can use a proof by contradiction. Since A[k/2 - 1] is larger than the k-th smallest element in the union of A and B, then we assume it is the (k+1)-th smallest one. Since it is smaller than B[k/2 - 1], then B[k/2 - 1] should be at least the (k+2)-th smallest one. So there are at most (k/2-1) elements smaller than A[k/2-1] in A, and at most (k/2 - 1) elements smaller than A[k/2-1] in B.So the total number is k/2+k/2-2, which, no matter when k is odd or even, is surly smaller than k(since A[k/2-1] is the (k+1)-th smallest element). So A[k/2-1] can never larger than the k-th smallest element in the union of A and B if A[k/2-1]&lt;B[k/2-1];Since there is such an important conclusion, we can safely drop the first k/2 element in A, which are definitaly smaller than k-th element in the union of A and B. This is also true for the A[k/2-1] &gt; B[k/2-1] condition, which we should drop the elements in B.When A[k/2-1] = B[k/2-1], then we have found the k-th smallest element, that is the equal element, we can call it m. There are each (k/2-1) numbers smaller than m in A and B, so m must be the k-th smallest number. So we can call a function recursively, when A[k/2-1] &lt; B[k/2-1], we drop the elements in A, else we drop the elements in B. We should also consider the edge case, that is, when should we stop? When A or B is empty, we return Bk-1, respectively; When k is 1(when A and B are both not empty), we return the smaller one of A[0] and B[0] When A[k/2-1] = B[k/2-1], we should return one of them In the code, we check if m is larger than n to garentee that the we always know the smaller array, for coding simplicy.]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2017%2F09%2F25%2Fquick-sort%2F</url>
    <content type="text"><![CDATA[最近在找工作的过程中，遇到最多的手写代码的题中，出现最多的算得上是“快速排序”了。有一般的让你写快速排序的，也有让你将递归的快速排序算法改成非递归的。也有让你为了避免出现“快速排序”最差性能的时候随机选主元的情况。现在分别对三种要求进行编码实现。 递归实现的快速排序1234567891011121314151617181920public static void quickSort(int[] array,int start,int end)&#123; if(start &lt; end)&#123; int q = partition(array,start,end); quickSort(array, start, q-1); quickSort(array, q+1, end); &#125;&#125;private static int partition(int[] array, int start, int end) &#123; int i = start -1; int key = array[end]; int j = start; for(;j&lt;end ;j++)&#123; if(array[j] &lt; key)&#123; i++; array[i] = (array[i] + array[j]) - (array[j] = array[i]); &#125; &#125; array[i+1] = array[i+1] + array[end] - (array[end] = array[i+1]); return i+1;&#125; 快速拍戏的非递归版本1234567891011121314151617181920212223242526272829303132333435public static void quickSort(int[] array, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(start); stack.push(end); while (!stack.empty()) &#123; int right = stack.pop(); int left = stack.pop(); if (left &lt; right) &#123; int boundray = partition(array, left, right); // 左区间 stack.push(left); stack.push(boundray - 1); // 右区间 stack.push(boundray + 1); stack.push(right); &#125; &#125;&#125;private static int partition(int[] array, int start, int end) &#123; int i = start - 1; int key = array[end]; int j = start; for (; j &lt; end; j++) &#123; if (array[j] &lt; key) &#123; i++; array[i] = (array[i] + array[j]) - (array[j] = array[i]); &#125; &#125; array[i + 1] = array[i + 1] + array[end] - (array[end] = array[i + 1]); return i + 1;&#125; 快速排序随机选主元的版本1234567891011121314151617181920212223242526272829public static void randomizedQuickSort(int[] array, int start, int end) &#123; if (start &lt; end) &#123; int q = randomizedPatition(array, start, end); randomizedQuickSort(array, start, q - 1); randomizedQuickSort(array, q + 1, end); &#125;&#125;public static int randomizedPatition(int[] array, int start, int end) &#123; Random random = new Random(); int i = random.nextInt(end) % (end - start + 1) + start; array[i] = (array[i] + array[end]) - (array[end] = array[i]); return partition(array, start, end);&#125;public static int partition(int[] array, int start, int end) &#123; int i = start - 1; int j = start; int key = array[end]; for (; j &lt; end; j++) &#123; if (array[j] &lt; key) &#123; i++; array[i] = array[i] + array[j] - (array[j] = array[i]); &#125; &#125; array[end] = array[i + 1]; array[i + 1] = key; return i + 1;&#125;]]></content>
      <categories>
        <category>lintcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Maximum Node]]></title>
    <url>%2F2017%2F09%2F23%2FBinary-Tree-Maximum-Node%2F</url>
    <content type="text"><![CDATA[Description:Find the maximum node in a binary tree, return the node.Example:Given a bianry bree:12345 1 / \ -5 2 / \ / \0 3 -4 -5 return the node with value 3. 最近在找工作的工程当中，有非常一个重要的考核就是手写代码。如果写的代码是递归式的代码，面试官可能还要求将递归式的代码改成非递归的代码。就以这道题为例： 这道题的递归解法如下：递归求解左子树的最大值节点maxLeftNode，递归求解右字数的最大值maxRightNode，然后maxLeftNode,maxRightNode,root三个节点进行比较即可。代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142/** * @Title: maxNode01 * @Description: 递归解法求解 * @param root 二叉树的根节点 * @return TreeNode 二叉树值最大的节点 * @throws */public TreeNode maxNode(TreeNode root) &#123; if (root == null || root.left == null &amp;&amp; root.right == null) &#123; return root; &#125; TreeNode result = null; TreeNode leftMaxNode = null; if (root.left != null) &#123; // 递归去求解左子树的最大值 leftMaxNode = maxNode(root.left); &#125; TreeNode rightMaxNode = null; if (root.right != null) &#123; // 递归去求解右子树的最大值 rightMaxNode = maxNode(root.right); &#125; if (leftMaxNode == null &amp;&amp; rightMaxNode != null) &#123; result = rightMaxNode; &#125; else if (leftMaxNode != null &amp;&amp; rightMaxNode == null) &#123; result = leftMaxNode; &#125; else &#123; if (leftMaxNode.val &gt; rightMaxNode.val) &#123; result = leftMaxNode; &#125; else &#123; result = rightMaxNode; &#125; &#125; // 和根节点进行比较 if (result.val &lt; root.val) &#123; result = root; &#125; return result;&#125; 非递归解法：通过对二叉树进行层次遍历去寻找最大值的节点。代码如下：1234567891011121314151617181920212223242526272829303132333435363738/** * @Title: maxNode * @Description: 寻找二叉树中值最大的节点(采用层次遍历二叉树的方法实现非递归的求解) * @param root 二叉树的根节点 * @return 二叉树值最大的节点 * @return TreeNode * @throws */public TreeNode maxNode(TreeNode root) &#123; if (root == null || root.left == null &amp;&amp; root.right == null) &#123; return root; &#125; TreeNode result = root; int lastLevelNode = 1; int curLevelNode = 0; // 通过队列进行层次遍历 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; while (lastLevelNode-- &gt; 0) &#123; TreeNode temp = queue.poll(); if (temp.val &gt; result.val) &#123; result = temp; &#125; if (temp.left != null) &#123; queue.offer(temp.left); curLevelNode++; &#125; if (temp.right != null) &#123; queue.offer(temp.right); curLevelNode++; &#125; &#125; lastLevelNode = curLevelNode; curLevelNode = 0; &#125; return result;&#125;]]></content>
      <categories>
        <category>lintcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java内存泄漏]]></title>
    <url>%2F2017%2F09%2F11%2FJava%2FJava%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[所谓内存泄漏就是指一个不再被程序使用的对象或变量一直占据在内存中。java中有垃圾回收机制，它可以保一个对象不再被引用的时候，即对象变成孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于java使用有向图的方式进行垃圾回收管理，可以消除循环引用的问题，例如有两个对象，相互引用，只要他们和根进程不可达的，那么GC也是可以回收它们的。例如下面的代码所示：1234567891011121314151617181920public class ReferenceCountGc &#123; public Object instance = null; private static final int _1MB = 1024 * 1024; private byte[] bigSieze = new byte[2 * _1MB]; public static void main(String[] args) &#123; ReferenceCountGc objA = new ReferenceCountGc(); ReferenceCountGc objB = new ReferenceCountGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; System.gc(); &#125;&#125; 输出gc的信息:看到，两个对象相互引用着，但是虚拟机还是把这两个对象回收掉了，这也说明虚拟机并不是通过引用计数法来判定对象是否存活的。Java中的内存泄漏的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不需要，但是长生命周期对象持有它的引用而导致不能被回收，这就是Java中可能出现内存泄漏的情况，例如，缓存系统，我们加载了一个对象放在缓存中（例如放在一个全局map对象中），然后一直不再使用它，这个对象一直被缓存引用，但却不能被使用。下面举两个例子：123456789101112131415161718192021222324252627import java.util.EmptyStackException;public class Stack &#123; private Object[] elements = new Object[10]; private int size = 0; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size == 0)&#123; throw new EmptyStackException(); &#125; return elements[--size]; &#125; private void ensureCapacity()&#123; if(elements.length == size)&#123; Object[] oldElements = elements; elements = new Object[2 * elements.length + 1]; System.arraycopy(oldElements, 0, elements, 0, size); &#125; &#125;&#125; 上面的原理很简单，加入堆栈加入了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这个对象是无法回收的，这才符合了内存泄漏的两个条件：无用，无法回收。 第二个例子是关于HasHSet修改参与计算哈希值字段值得例子1234567891011121314151617181920212223242526272829import java.util.HashSet;public class HashSetTest &#123; public static void main(String[] args) &#123; HashSet&lt;MPoint&gt; set = new HashSet&lt;MPoint&gt;(); MPoint mp1 = new MPoint(1,6); MPoint mp2 = new MPoint(2,7); MPoint mp3 = new MPoint(1,6); set.add(mp1); set.add(mp2); set.add(mp3); System.out.println(set.size()); // 2 mp1.setX(3); set.remove(mp1); System.out.println(set.size()); // 2 ,说明没有删除成功 System.out.println(set.contains(mp1));// false,修改了参与计算的hash值得变量,其对象不能再被找到 System.out.println(set.remove(mp1));// false,修改了参与计算hash值得变量,其对象不能被删除 mp2.setX(2); System.out.println(set.contains(mp2)); // true,没有修改关键属性的对象可以被找到 System.out.println(set.remove(mp2)); // true,没有修改关键属性的对象可以被删除 System.out.println(set.size());//1,但是那个元素已经无法找到了 &#125;&#125; 内存泄漏的另外一种情况是：当一个对象被存储进HashSet集合中以后，就不能修改这个对象中那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中的哈希值就不同了，在这种情况下，即使在contains()方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到的结果，这也会导致无法从HashSet集合中去单独删除当前的对象，造成内存泄漏。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实现一个线程死锁的程序]]></title>
    <url>%2F2017%2F09%2F08%2FJava%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[死锁的定义《现代操作系统》那本书中对死锁的定义如下：如果一个进程集合中的每个进程都在等待只能该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。 死锁的示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyLock &#123; // 创建两把锁对象 public static final Object objA = new Object(); public static final Object objB = new Object();&#125;public class DieLock extends Thread &#123; private boolean flag; public DieLock(boolean flag) &#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag) &#123; // flag为true的时候走这里 synchronized (MyLock.objA) &#123; // 已经持有了锁对象objA System.out.println("if objA"); synchronized (MyLock.objB) &#123; System.out.println("if objB"); &#125; &#125; &#125; else &#123; // flag为false的时候走这里 synchronized (MyLock.objB) &#123; // 已经持有了锁对象objB System.out.println("else objB"); synchronized (MyLock.objA) &#123; System.out.println("else objA"); &#125; &#125; &#125; &#125;&#125;public class DieLockDemo &#123; public static void main(String[] args) &#123; DieLock dl1 = new DieLock(true); DieLock dl2 = new DieLock(false); dl1.start(); dl2.start(); &#125;&#125;]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入一个url经历了什么]]></title>
    <url>%2F2017%2F09%2F07%2F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Count of Smaller Number before itself]]></title>
    <url>%2F2017%2F09%2F01%2FCount-of-Smaller-Number-before-itself%2F</url>
    <content type="text"></content>
      <categories>
        <category>lintcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[B-树,B+树的定义,特性,联系与区别]]></title>
    <url>%2F2017%2F09%2F01%2FB-B-B-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[B树B+树]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实例讲解MySQL的连接查询]]></title>
    <url>%2F2017%2F08%2F31%2FMySQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[连接查询的概念 内连接查询外链接查询左外连接查询右外连接查询全连接查询]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2017%2F08%2F31%2FJava%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是泛型 泛型，即“参数化类型” 。创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。 为什么需要泛型泛型实战从Collections的copy()方法中学习泛型123456789101112131415161718192021222324252627282930313233343536 /** * Copies all of the elements from one list into another. After the * operation, the index of each copied element in the destination list * will be identical to its index in the source list. The destination * list must be at least as long as the source list. If it is longer, the * remaining elements in the destination list are unaffected. &lt;p&gt; * * This method runs in linear time. * * @param &lt;T&gt; the class of the objects in the lists * @param dest The destination list. * @param src The source list. * @throws IndexOutOfBoundsException if the destination list is too small * to contain the entire source List. * @throws UnsupportedOperationException if the destination list's * list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation. */// copy方法中使用到了PECS原则，实现了对参数的保护public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; int srcSize = src.size(); if (srcSize &gt; dest.size()) throw new IndexOutOfBoundsException("Source does not fit in dest"); if (srcSize &lt; COPY_THRESHOLD || (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123; for (int i=0; i&lt;srcSize; i++) dest.set(i, src.get(i)); &#125; else &#123; ListIterator&lt;? super T&gt; di=dest.listIterator(); ListIterator&lt;? extends T&gt; si=src.listIterator(); for (int i=0; i&lt;srcSize; i++) &#123; di.next(); di.set(si.next()); &#125; &#125;&#125; &lt;? super T&gt;表示包括T在内的任何T的父类，&lt;? extends T&gt;表示包括T在内的任何T的子类 泛型中请注意使用PECS原则 请记住PECS原则：生产者(Producer)使用extends，消费者使用super。生产者使用extends:如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成&lt;? extends T&gt;，比如List&lt;? extends Integer&gt;，因此你不能往该列表中添加任何元素。消费者使用super:如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成&lt;? super T&gt;，比如List&lt;? super Integer&gt;，因此你不能保证从中读取到的元素的类型。即是生产者，也是消费者:如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Implement strStr()]]></title>
    <url>%2F2017%2F08%2F31%2FJava%2FKMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Description:Implement strStr().Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 暴力的解法如下：12345678910111213141516171819202122232425262728293031323334353637/*** @Title: strStr * @Description: 字符串匹配的暴力解法(时间复杂度O(n*m))* @param haystack 匹配串* @param needle 模式串* @return int 匹配串第一次匹配出现haystack的索引 * @throws */public int strStr(String haystack, String needle) &#123; if (haystack == null || needle == null) &#123; return -1; &#125; int needLength = needle.length(); if (needLength == 0) &#123; return 0; &#125; int haysLength = haystack.length(); char[] hays = haystack.toCharArray(); char[] need = needle.toCharArray(); int i = 0; int j = 0; while (i &lt; haysLength &amp;&amp; j &lt; needLength) &#123; if (hays[i] == need[j]) &#123; i++; j++; &#125; else &#123; // 进行回溯,重新比较 i = i - j + 1; j = 0; &#125; &#125; if (j == needLength) &#123; return i - j; &#125; else &#123; return -1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public int strStr(String haystack, String needle) &#123; if (haystack == null || needle == null) &#123; return -1; &#125; int needLength = needle.length(); if (needLength == 0) &#123; return 0; &#125; return kmp(haystack.toCharArray(),needle.toCharArray());&#125;private int kmp(char[] text, char[] patten) &#123; int[] next = GetNext(patten); int i = 0; int j = 0; while (i &lt; text.length &amp;&amp; j &lt; patten.length) &#123; // 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || text[i] == patten[j]) &#123; i++; j++; &#125; else &#123; // 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] // next[j]即为j所对应的next值 j = next[j]; &#125; &#125; if (j == patten.length) &#123; return i - j; &#125; else &#123; return -1; &#125;&#125; /** * @Title: GetNext * @Description: 求next数组(此过程相当于模式串的自我匹配) * @param p * @param next * @return void * @throws */private int[] GetNext(char[] p) &#123; int[] next = new int[p.length]; int pLen = p.length; next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; // p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125; return next;&#125;]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LRU Cache]]></title>
    <url>%2F2017%2F08%2F30%2Fleetcode%2FLRU%2F</url>
    <content type="text"><![CDATA[Description:Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.Follow up:Could you do both operations in O(1) time complexity?Example:1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 LRU Cache，在学习《操作系统》页面置换算法的时候开始接触。最近最少使用页面置换算法在《现在操作系统》这本书里面是这样描述的：在前面几条指令中频繁使用的页面很有可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。这个思想提示了一个可实现的算法：在缺页中断发生时，置换未使用时间最长的页面。这个策略称为LRU(Lease Recently Used，最近最少使用)页面置换算法。回到这道题中，这道题就相当于让你用软件去模拟LRU Cache的实现过程。通常让你去实现一个具有设计意义的小程序的过程当中，其实是蛮考验你的设计能力的。这道题的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.lang.reflect.Field;import java.util.LinkedHashMap;import java.util.Map.Entry;public class LRUCache &#123; private int capacity; // LinkedHashMap具有可预知的迭代顺序 private LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap; public LRUCache(int capacity) &#123; this.capacity = capacity; // 既然已经知道了最大容量,那么在创建LinedHashMap的过程当中就初始化它的容量,负载因子设置为1,避免在使用过程当中出现的扩容操作。 this.linkedHashMap = new LinkedHashMap&lt;Integer, Integer&gt;(capacity,1); &#125; public int get(int key) &#123; if (linkedHashMap.containsKey(key)) &#123; int result = linkedHashMap.get(key); put(key, result); return result; &#125; else &#123; return -1; &#125; &#125; public void put(int key, int value) &#123; if (linkedHashMap.size() &lt; capacity) &#123; if (linkedHashMap.containsKey(key)) &#123; linkedHashMap.remove(key); &#125; linkedHashMap.put(key, value); &#125; else &#123; if (linkedHashMap.containsKey(key)) &#123; linkedHashMap.remove(key); &#125; else &#123; Entry&lt;Integer, Integer&gt; entry = getHead(linkedHashMap); linkedHashMap.remove(entry.getKey()); &#125; linkedHashMap.put(key, value); &#125; &#125; // LinkedHashMap的tail存储的是最后put进入的节点 @SuppressWarnings("unchecked") public &lt;K, V&gt; Entry&lt;K, V&gt; getTailByReflection(LinkedHashMap&lt;K, V&gt; map) throws NoSuchFieldException, IllegalAccessException &#123; Field tail = map.getClass().getDeclaredField("tail"); tail.setAccessible(true); return (Entry&lt;K, V&gt;) tail.get(map); &#125; // linkedHashMap的head存储的是最先put进入的节点 public &lt;K, V&gt; Entry&lt;K, V&gt; getHead(LinkedHashMap&lt;K, V&gt; map) &#123; return map.entrySet().iterator().next(); &#125;&#125; 注意：抛开做这道题的层面，在更一般的场景中，请给LinkedHashMap用泛型来代替。]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap]]></title>
    <url>%2F2017%2F08%2F30%2FJava%2FLinkedHashMap%2F</url>
    <content type="text"><![CDATA[LinkedHashMap概述LinkedHashMap是Map接口的哈希表和链表实现，具有可预知的迭代顺序。此实现提供所有可供选择的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双向链表。此链表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。注意，LinkedHashMap也不是同步的。 LinkedHashMap实现对于LinkedHashMap而言，它继承于HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链表特定。 LinkedHashMap里面的Entry&lt;K,V&gt;节点LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链表。123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; LinkedHashMap获取头结点和尾节点LinkedHashMap获取头结点的代码如下：1234567// linkedHashMap的head存储的是最先put进入的节点public static &lt;K, V&gt; Entry&lt;K, V&gt; getHead(LinkedHashMap&lt;K, V&gt; map) &#123; if(map == null)&#123; return null; &#125; return map.entrySet().iterator().next();&#125; LinkedHashMap获取尾节点的代码如下：1234567891011public &lt;K, V&gt; Entry&lt;K, V&gt; getTail(LinkedHashMap&lt;K, V&gt; map) &#123; if(map == null)&#123; return null; &#125; Iterator&lt;Entry&lt;K, V&gt;&gt; iterator = map.entrySet().iterator(); Entry&lt;K, V&gt; tail = null; while(iterator.hasNext())&#123; tail = iterator.next(); &#125; return tail;&#125; 也可以通过反射来实现获取LinkedHashMap的尾节点12345678910@SuppressWarnings("unchecked")public static &lt;K, V&gt; Entry&lt;K, V&gt; getTailByReflection(LinkedHashMap&lt;K, V&gt; map) throws NoSuchFieldException, IllegalAccessException &#123; if(map == null)&#123; return null; &#125; Field tail = map.getClass().getDeclaredField("tail"); tail.setAccessible(true); return (Entry&lt;K, V&gt;) tail.get(map);&#125;]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码解析]]></title>
    <url>%2F2017%2F08%2F30%2FJava%2FConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[减少锁粒度是一种削弱多线程竞争的有效手段。这种技术典型的应用应该就是java.util.concurrent包下面的ConcurrentHashMap类。现在详细说明该类是如何实现的。 对于HashMap来说，最重要的两个方法就是get()和put()。一种最自然的想法就是对整个HashMap加锁。123public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123; return new SynchronizedMap&lt;&gt;(m);&#125; Collections下面的synchronizedMap(Map&lt;K,V&gt; m)就是采用的这样的策略。这样必然可以得到一个线程安全的对象。但是这样做，我们就可以认为加锁的粒度太大了。对于ConcurrentHashMap，它内部进一步细分了若干个小的HashMap，称之为段(SEGMENT)。默认情况下，一个ConcurrentHashMap被进一步细分为16个段。如果需要在ConcurrentHashMap中增加一个新的表项，并不是将整个HashMap加锁，而是首先根据hashcode得到该表项应该被存放在哪个段中，然后对该段加锁，并完成put()操作。在多线程环境中，如果多个线程同时进行put()操作，只要被加入的表项不存放在同一个段中，则线程间便可以做到真正的并行。由于默认有16个段，因此，如果足够幸运的话，ConcurrentHashMap可以同时接受16个线程同时插入(如果都插入不同的段中)，从而大大提高其吞吐量。下面看源码是怎么实现的。12]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2F2017%2F08%2F30%2FJava%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList概述ArrayList是List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括null在内的所有元素。除了实现List接口外，此类还提供一些方法来操作内部用来存储列表的数组。每个ArrayList实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时候指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity()操作来增加ArrayList的容量，这可以减少递增式再分配的数量。注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList的实现对于ArrayList而言，它实现了List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面分析ArrayList的源码 底层使用数组实现1234// 保存ArrayList中数据的数组transient Object[] elementData; // non-private to simplify nested class access// The size of the ArrayList (the number of elements it contains).private int size; 构造方法 ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的新列表以及构造一个包含指定 collection 的元素的列表，这些元素是按照该collection 的迭代器返回它们的顺序排列的。123456789101112131415161718192021222324252627/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 存储ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面一一讲解。12345678// 用指定的元素替代此列表中指定位置上的元素。返回以前位于该指定位置上的元素。public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 123456789101112131415161718// 将指定的元素添加到此列表的尾部。public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 123456789101112131415161718public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;// 按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。返回：如果此列表由于调用而发生更改，则返回true public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125; 123456789101112131415public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 读取1234public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 删除ArrayList提供了根据下标或者指定对象两种方式的删除功能。123456789101112public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); // 需要移动数组的长度 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 123456789101112131415161718192021222324public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 从源代码可以看出，从数组中移除元素的操作，也会导致被移除的元素的后面的所有元素向左移动一个位置。 调整数组容量从上面介绍的向ArrayList中存储元素的代码中，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超过当前数组的长度，如果查过，数组将会进行扩容，以满足添加数据的需求。123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 扩容为原来的3倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 从上述代码可以看到，数组进行扩容的时候，会将原来数组中的元素拷贝到新数组中，每次数组的扩容回事原来的3倍。这种操作的代价是很高的，因此在实际使用的时候，我们应该避免数组容量的扩张。当我们知道要保存的元素时多少时，要在构造ArrayList实例中，指定其容量，以避免数组扩容的发生。ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的诗句元素的大小的功能。trimToSize()方法实现如下：12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; Fail-Fast机制ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。对面对并发的修改时，迭代器很快会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2F2017%2F08%2F30%2FJava%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap概述 HashMap可以说是Java程序员使用得最多的key-value型的数据类型。HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键，但是HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据不一致。如果需要满足并发线程安全，可以用Collections的synchronizedHashMap方法使HashMap具有线程安全的能力，或者使用并发包下面的ConcurrentHashMap。 HashMap的数据结构在Java编程中，最基本的数据结构就是两种，一个是数组，一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，从上面就可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表（在JDK1.8当中，当链表的长度大于8的时候，转换为红黑树）。当新建一个HashMap的时候，就会初始化一个数组。1234567891011121314151617/*** The table, initialized on first use, and resized as* necessary. When allocated, length is always a power of two.* (We also tolerate length zero in some operations to allow* bootstrapping mechanics that are currently not needed.)*/transient Node&lt;K,V&gt;[] table;/*** Basic hash bin node, used for most entries. (See below for* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)*/static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125; 可以看出Node&lt;K,V&gt;就是数组中的元素，每个Map.Entry&lt;K,V&gt;其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。 HashMop的存储实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; //对key的hashcode()做hash return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table为空则创建 if ((tab = table) == null || (n = tab.length) == 0) // 如果你是执行Map map = new HashMap();其实底层的table数组并没有创建， // 在执行第一个put操作的时候调用resize()方法才会对table[]数组进行初始化 n = (tab = resize()).length; // 计算key在table数组中的索引位置，并且对null值进行处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果为null，那么直接插入 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 节点key存在,直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断该链是否为红黑树，如果是，以红黑树的方法put元素 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // hash映射到一个槽位上，开始遍历链表，准备插入 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 新的节点插入到链表的末尾 p.next = newNode(hash, key, value, null); // 链表长度大于8,转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果存在key，结束遍历 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 相当于p = p.next; p = e; &#125; &#125; // 如果e不为null,覆盖原来的value,返回oldValue if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) // 超过最大容量，就扩容 resize(); afterNodeInsertion(evict); //如果hashMap原来不存在我们要插入的key值，返回null。 return null;&#125; HashMap的resize(rehash)当HashMap里面的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList当中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。但是这个点在JDK1.8中进行了优化。这里面举个例子说明：这个设计确实非常的巧妙，既省去了重新计算hash的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前冲突的节点分散到了新的bucket中。这一块是JDK1.8新增的优化点。具体请看HashMap里面的resize()方法 HashMap的性能参数HashMap包含如下的几个构造器：public HashMap()：构建一个初始容量为16，负载因子为0.75的HashMappublic HashMap(int initialCapacity):构建一个初始容量为initialCapacity，负载因子为0.75的HashMappublic HashMap(int initialCapacity, float loadFactor):以指定初始容量、指定的负载因子创建一个HashMap。 initialCapacity:HashMap的最大容量，即为底层数组的长度。loadFactor:负载因子loadFactor定义为：散列表的实际元素数组（n）/散列表的容量（m）。 负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链地址法的散列表来说，查找一个元素的平均时间是O(1+n)，因此，如果负载因子越大，对空间的利用更充分，然后后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于分散，对空间造成严重浪费。 线程安全我们知道HashMap不是线程安全的，在并发编程中使用HashMap可能导致程序死循环。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务的概念以及事务的隔离级别]]></title>
    <url>%2F2017%2F08%2F29%2Fmysql%2FMySQL%E4%BA%8B%E7%89%A9%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E4%BA%8B%E7%89%A9%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[事务的概念如下：1，事务是数据库系统区别于其他一切文件系统的重要特征之一；2，事务是一组具有原子性的SQL语句，或是一个独立的工作单元。举个例子说明：银行应用是解释事务必要性的一个经典的例子。假设一个银行的数据库有两张表：支票表（checking）和储蓄（savings）表。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么需要至少三个步骤：1，检查支票账户中的余额是否高于200美元；2，从支票账户余额中减去200美元；3，在储蓄账户的余额中增加200美元。上述三个步骤的操作必须打包在一个事务中，任何一个步骤失败，则必须回滚所有的步骤。可以用START TRANSACTION语句开始一个事务，然后要么使用COMMIT提交事务将修改的数据持久保留，要么使用ROOLBACK撤销所有的修改 ，事务SQL的样本如下：12345START TRANSACTION;SELECT balance FROM checking WHERE custom_id = '10233276';UPDATE checking SET balance = balance - 200.00 WHERE custom_id = '10233276';UPDARE savings balance = balance + 200.00 WHERE custom_id = '10233276';COMMIT; 原子性(atomicity)一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。 一致性(consistency)数据库总是从一个一致性状态转移到另外一个一致性状态。在前面的例子中，一致性确保了，即使在执行第三句和第四句之间时系统奔溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。 隔离性(isolation)通常来说，一个事务所作的修改在最终提交以前，对其他事务都是不可见的。在前面的例子中，当执行完第三条语句，第四条语句还未开始时，此时有另外一个账户汇总程序开始运行，则其看到的支票账户的余额并没有被减去200美元。在SQL标准中，定义了四种隔离级别，每一个级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。 读取未提交(READ UNCOMMITTED)在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。读取未被提交的数据也叫做脏读（Dirty Read）。脏读就是指一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。比如：1.Mary的原工资为1000，财务人员将Mary的工资修改成了8000（但未提交事务）；2.Mary读取自己的工资，发现自己的工资变成了8000，欢天喜地；3.但是，财务发现操作有误，回滚了事务，Mary的工资又变成了1000。这样，Mary在第二步看到自己的工资是8000就是一个脏读的数据。 提交读(Read Committed)大多数数据库系统的默认隔离级别是READ COMMITTED。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所作的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。举个例子：1.在事务1中，Mary读取了自己的工资为1000，操作并没有完成；2.在事务2中，这时财务人员修改了Mary的工资为2000，并提交了事务；3.在事务1中，Mary再次读取自己的工资时，工资变成了2000。与第一次读取到的工资不一样，所以叫做不可重复读。 可重读(Repeatable Read)可重读解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的，解决了不可重复读问题。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。什么叫幻读，举个例子：1234目前工资为1000的员工有10人。1.事务1，读取所有工资为1000的员工；2.这时事务2向employee表插入了一条员工记录，工资也为1000；3.事务1再次读取所有工资为1000的员工，共读取到11条记录。 可串行化(Serializable)Serializable是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。 持久性事务一旦提交，则其所作的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 在写代码的时候，一定要避免大事务的操作。（大事务就是指运行时间比较长，操作的数据比较多的事务）。大事务存在风险：1，锁定太多的数据，造成大量的阻塞和锁超时；2，回滚时需要时间比较长；3，执行时间长，容易造成主从延迟。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架概述]]></title>
    <url>%2F2017%2F08%2F28%2FJava%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。Java提供了几个能有效组织和操作数据的数据结构，这些数据结构通常称为Java集合框架。在平常的学习开发中，灵活熟练地使用这些集合框架，可以很明显地提高我们的开发效率，当然仅仅会用还是不够的，理解其中的设计思想与原理才能更好提高我们的开发水平。下面是对Java集合框架的学习总结。 概述在Java2之前，Java是没有完整的集合框架的。它只是一些简单的可以自扩展的容器类，比如Vector，Stack，HashTable等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在Java2中，Java设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用。Java集合的框架图如下图所示（请大概记住这个图，对你使用集合框架有很大的帮助）：从上面的集合框架图可以看到，Java集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，并一种是Map，存储键/值对的映射。Collection接口又有3种子类型，List、Set、Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。集合框架体系如图所示： Collection接口Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法，AbstractCollection是提供Collection部分实现的抽象类。下图展示了Collection接口中的全部方法。其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。Collection接口有三个子接口，下面详细介绍。 ListList承诺可以将元素维护在特定的序列中。List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。有两种类型的List：(1)基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。(2)LinkedList，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢，但是它的特性集较ArrayList更大。 SetSet接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。在一个规则集内，一定不存在两个相等的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体的实现类，分别是散列集HashSet，链式散列集LinkedHashSet和树形集TreeSet。(1)HashSet:该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。(2)LinkedHashSet:LinkedHashSet是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。(3)TreeSet:TreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set。TreeSet将元素存储在红-黑树数据结构中。 Queue队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提取插入，提取，检验等操作。上图中，方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而removce()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。接口Deque,是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque()接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先级队列，优先级队列中元素被赋予优先级，拥有高优先级的先被删除。 Map接口Map,是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但不能有重复的键，每个键都对应一个值，真正存储在Map中的是键值构成的条目。下面是接口Map的类结构。从上面这张图中我们可以看到接口Map提供了很多查询，更新和获取存储的键值对的方法，更新包括方法clear(),put(),remove()等等。查询方法包括containsKey,containsValue等等。Map接口常用的有三个具体实现类，分别为HashMap,LinkedHashMap,TreeMap。 HashMapHashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 LinkedHashMapLinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。 TreeMapTreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。 其他集合类VectorJava设计者们在对之前的容器类进行重新设计时保留了一些数据结构，其中就有Vector。用法上，Vector与ArrayList基本一致，不同之处在于Vector使用了关键字synchronized将访问和修改向量的方法都变成同步的了，所以对于不需要同步的应用程序来说，类ArrayList比类Vector更高效。 StackStack，栈类，是Java2之前引入的，继承自类Vector。 HashTableHashTable和前面介绍的HashMap很类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，HashTable是继承自Dictionary的，HashTable中的函数都是同步的，这意味着它也是线程安全的，另外，HashTable中key和value都不可以为null。 ConcurrentHashMapConcurrent，并发，从名字就可以看出来ConcurrentHashMap是HashMap的线程安全版。同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高。 CopyOnWriteArrayListCopyOnWriteArrayList，是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。 总结(1)Java集合框架主要包括Collection和Map两种类型。其中Collection又有3种子类型，分别是List、Set、Queue。Map中存储的主要是键值对映射。(2)规则集Set中存储的是不重复的元素，线性表中存储可以包括重复的元素，Queue队列描述的是先进先出的数据结构，可以用LinkedList来实现队列。(3)效率上，规则集比线性表更高效。(4)ArrayList主要是用数组来存储元素，LinkedList主要是用链表来存储元素，HashMap的底层实现主要是借助数组+链表+红黑树来实现。(5)Vector、HashTable等集合类效率比较低但都是线程安全的。包java.util.concurrent下包含了大量线程安全的集合类，效率上有较大提升。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[今日头条2018年校园招聘解题报告-第一题]]></title>
    <url>%2F2017%2F08%2F23%2Fleetcode%2F%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12017%E5%B9%B4%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-%E7%AC%AC%E4%B8%80%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述如下：在平面坐标系内有N个点随机分布，当给定的其它N-1个点，没有一个点位于该点的右上方，该点即为满足条件的点，计算满足该条件的点的数目。输入样例：第一行输入点的数据N,接下来的N行分别表示输入每个点的横坐标和纵坐标输出满足条件的点的数目1234567输入样例:5 1 2 1 1 3 2 4 1 2 3输出：3，（其中(4,1),(3,2),(3,2)）为满足条件的点。 解题的思路如下：先将所有的节点按纵坐标排序(时间复杂度为O(nlogn))。首先，纵坐标最大的那个点肯定是符合条件的点，初始遍历数组的时候result=1。在这里，我们记录一个值maxValueOfX(初始化值记为纵坐标最大的那个点的横坐标)，表示当前已经遍历完的点中横坐标最大的值。然后再从纵坐标第二高的节点往前遍历已经排序好的数组，如果当前遍历的那个节点的横坐标大于等于maxVMalueOfX，那么这个点一定是符合条件的点，因为它的纵坐标比当前遍历完的所有节点的纵坐标都小，但是横坐标比他们都大，它的右上方肯定是没有节点的。最后更新maxValueOfX的值，这个步骤的时间复杂度为O(n)。最终这个算法的时间复杂度为O(nlogn)。具体实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package main;import java.util.Arrays;import java.util.Comparator;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; int n = sc.nextInt(); Coordinate[] array = new Coordinate[n]; for (int i = 0; i &lt; n; i++) &#123; Coordinate coordinate = new Coordinate(sc.nextInt(), sc.nextInt()); array[i] = coordinate; &#125; Comparator&lt;Coordinate&gt; compator = new Comparator&lt;Coordinate&gt;() &#123; @Override public int compare(Coordinate o1, Coordinate o2) &#123; if (o1.y &gt; o2.y) &#123; return 1; &#125; else if (o1.y &lt; o2.y) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;; Arrays.sort(array, compator); int maxValueOfX = array[n - 1].x; int result = 1; // 先访问的 节点的纵坐标一定大于后访问节点的纵坐标,后面的节点只需要比较横坐标 // 用maxValueOfX记录当前访问完节点的横坐标最大值,如果array[i].x &gt;= maxValueOfX,那么这个点符合条件 for (int i = n - 2; i &gt;= 0; i--) &#123; if (array[i].x &gt;= maxValueOfX) &#123; result++; maxValueOfX = array[i].x; &#125; &#125; System.out.println(result); &#125; &#125;&#125;class Coordinate &#123; int x; int y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Integer Cache]]></title>
    <url>%2F2017%2F08%2F23%2FJava%2FJAVA-Integer%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[这个博客翻译自Java Integer Cache 这篇JAVA文章是介绍和讨论关于整数缓存。这是JAVA 5中引入的一个功能，用于节省内存并提高性能。让我们先看一下使用Integer的实例代码，并展示整数缓存行为。从这里让我们学习怎么实现和为什么这样实现。你可以猜测一下JAVA程序的输出。显然，这里有一些小陷阱，这就是为什么我们有这个JAVA文章。12345678910111213141516171819package com.javapapers.java;public class JavaIntegerCache &#123; public static void main(String... strings) &#123; Integer integer1 = 3; Integer integer2 = 3; if (integer1 == integer2) System.out.println("integer1 == integer2"); else System.out.println("integer1 != integer2"); Integer integer3 = 300; Integer integer4 = 300; if (integer3 == integer4) System.out.println("integer3 == integer4"); else System.out.println("integer3 != integer4"); &#125;&#125; 我们通常期望的是两个语句都返回false。虽然这些值是相同的，但被比较的对象应该是不同的，因为它们将有不同的引用。如果你是初学者，那么在JAVA使用==检查对象引用，用equals()检查值。所以在这种情况下，不同的对象应该有不同的引用，所以当比较时，它们应该返回一个false的布尔值。这里奇怪的是，行为是不一样的。两个类似的if-condition返回不同的布尔值。 现在看看上面的JAVA程序的输出12integer1 == integer2integer3 != integer4 Java Integer Cache Implementation在JAVA5中，引入了一个新功能来节省内存并提高Integer类型对象处理的性能。Integer对象在内部进行缓存，并通过相同的引用对象进行重用。 这个应用适用于-128到127(最大整数值)范围内的整数值。 整数缓存仅适用于自动装箱。当使用构造函数构建时，整数对象不会被缓存。JAVA编译器从原型到其相应的JAVA包装器类类型的自动转换称为自动装箱。这等于使用valueof,如下：12Integer a = 10; //this is autoboxingInteger b = Integer.valueOf(10); //under the hood 所以现在我们知道这个缓存应该在JAVA JDK源码中实现。让我们来看看来着JAVA JDK的valueOf方法源码。一下是JAVA JDK8 build25。1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */ public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 在构造一个新的Integer实例之前，先查找IntegerCache.cache。这里有一个JAVA class处理Integer缓存。 IntegerCache ClassIntegerCache是Integer类的私有静态内部类。让我们看看那个类。它很好的记录在JDK中，并提供大部门信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; Javadoc 详细的说明这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。 实际上在 Java 5 中引入这个特性的时候，范围是固定的 -128 至 +127。后来在 Java 6 中，最大值映射到 java.lang.Integer.IntegerCache.high，可以使用 JVM 的启动参数设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。是什么原因选择这个 -128 到 127 这个范围呢？因为这个范围的整数值是使用最广泛的。 在程序中第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存。 Cache Enforcement in Java Language Specification在 Boxing Conversion 部分的Java语言规范(JLS)规定如下： 如果一个变量 p 的值属于：-128至127之间的整数(§3.10.1)，true 和 false的布尔值 (§3.10.3)，’u0000′ 至 ‘u007f’ 之间的字符(§3.10.4)中时，将 p 包装成 a 和 b 两个对象时，可以直接使用 a == b 判断 a 和 b 的值是否相等。 Other Cached Objects这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。 有 ByteCache 用于缓存 Byte 对象 有 ShortCache 用于缓存 Short 对象 有 LongCache 用于缓存 Long 对象 有 CharacterCache 用于缓存 Character 对象Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了Integer 可以通过参数改变范围外，其它的都不行。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MYSQL性能优化的最佳20+条经验]]></title>
    <url>%2F2017%2F08%2F17%2Fmysql%2FMYSQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B320%2B%E6%9D%A1%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[本篇博客翻译自Top 20+ MySQL Best Practices&#8195;&#8195;数据库操作往往成当今大多数Web应用程序的主要瓶颈。关于数据库的性能问题，这并仅仅是是DBA才需要关心的事。我们作为程序员需要通过正确构造表来完成我们的工作，编写优化的查询和更好的代码。在本文中，我讲列出一些MySQL优化技术给程序员们。 使用查询缓存优化你的查询 大多数的MySQL服务器都启用了查询缓存。它是提高性能的最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当相同的查询执行了多次时，后续相同的查询就不用操作表而直接访问缓存结果了。这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句不适用缓存。123456// query cache does NOT work$r = mysql_query("SELECT username FROM user WHERE signup_date &gt;= CURDATE()"); // query cache works!$today = date("Y-m-d");$r = mysql_query("SELECT username FROM user WHERE signup_date &gt;= '$today'"); 查询缓存在第一行不起作用的原因是使用了CURDATE()函数。这适用于所有非确定性的函数，如NOW()和RAND()等等。由于函数的返回结果可以改变，诸如此类的SQL函数都不会开启查询缓存。所以，你所需要的就是用一个变量来代替MySQL的函数，从而为该查询开启缓存。 explain你的select查询 使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮助你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结构还会告诉你，你的索引主键是如何被利用的，你的数据表示如何被搜索和排序的等等。挑选一个查询(尤其选择那种复杂的，多表关联的)，把EXPLAIN关键字加到前面。你可以使用phpmyadmin来做这个事情。它将在一个很好的表中给你显示出结果。比如，我们忘记加上了group_id索引，并且有表连接。当我们给group_id字段加上索引后前一个结果显示搜索了7883行， 而后一个只是搜索了两个表的9和16行。一个好的经验法则是在“rows”列下将所有的数字相乘，你的查询性能驾驭结果数字成比例。 当只有一行数据时使用LIMIT 1 当你查询有些表的时候，你已经知道结果只会有一条结果，但因为你可能需要去fatch游标，或是你也许会去检查返回的记录数。在这种情况下，加上LIMIT 1可能增加性能。这样的话，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查下一条符合记录的数据。1234567891011121314// do I have any users from Alabama? // what NOT to do:$r = mysql_query("SELECT * FROM user WHERE state = 'Alabama'");if (mysql_num_rows($r) &gt; 0) &#123; // ...&#125; // much better:$r = mysql_query("SELECT 1 FROM user WHERE state = 'Alabama' LIMIT 1");if (mysql_num_rows($r) &gt; 0) &#123; // ...&#125; 为搜索字段建索引 索引并不一定就是给主键或为唯一的字段。如果在你的表中，有某个字段你总要回经常用来用搜索，那么，请为其建立索引。从上图你可以看到那个搜索字符串“last_name LIKE ‘a%’”，一个是建立了索引，一个是没有简历索引，性能查了4倍左右。另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如：“WHERE post_content LIKE ‘%apple%’”，索引可能是没有意义的。你可能需要使用MySQL全文索引或者自己做一个索引（比如说：搜索关键词或是Tag什么的） 在Join表的时候使用相当类型的例，并将其索引 如果应用程序中包含很多Join查询，你需要确认两个表中join的字段是被建立过索引的。这将影响MySQL内部优化你的join查询的方式。此外，连接的列需要时相同的类型的。例如，如果你对一个数据类型为decimal的列和另外一张表的INT的列进行关联。MySQL将至少不能使用其中的一个索引。对String类型的类，字符编码也要求相同。(两张表的字符集可能出现不同的情况)12345678// looking for companies in my state$r = mysql_query("SELECT company_name FROM users LEFT JOIN companies ON (users.state = companies.state) WHERE users.id = $user_id"); // both state columns should be indexed// and they both should be the same type and character encoding// or MySQL might do full table scans 不要使用ORDER BY RAND() 这是一种最初听起来很酷的技巧，很多新手程序员也会陷入这种陷阱。当你开始在你的查询中使用这些的时候，你可能还没有意识到你会创造什么样子的可怕瓶颈。如果你真的需要从你的结果中得到随机的行，有很多更好的方法去做。当然，它需要额外的代码，但是你可以防止，随着数据的增长而变得更加严重的瓶颈。问题是，MySQL会不得不去执行RAND()函数(很耗CPU时间)，而且这是对每一行记录去执行，然后在对其排序。就算是你用了limit 1也无济于事(因为要排序)1234567891011// what NOT to do:$r = mysql_query("SELECT username FROM user ORDER BY RAND() LIMIT 1"); // much better: $r = mysql_query("SELECT count(*) FROM user");$d = mysql_fetch_row($r);$rand = mt_rand(0,$d[0] - 1); $r = mysql_query("SELECT username FROM user LIMIT $rand, 1"); 避免使用SELECT * 从表中读取的数据越多，查询的速度就越慢。它增加了磁盘操作的时间。另外，当数据库服务器和web服务器分离时，由于避灾两者之间传递数据，这将会增加网络传输的负载(在高并发下，网卡的IO资源也可能会被完全占用，所有不要传输一个无用的数据)。所以，你应该养成一个好习惯，在做SELECT操作的时候，总是制定需要的列。1234567891011// not preferred$r = mysql_query("SELECT * FROM user WHERE user_id = 1");$d = mysql_fetch_assoc($r);echo "Welcome &#123;$d['username']&#125;"; // better:$r = mysql_query("SELECT username FROM user WHERE user_id = 1");$d = mysql_fetch_assoc($r);echo "Welcome &#123;$d['username']&#125;"; // the differences are more significant with bigger result sets 永远为每张表设置一个ID 在每一张表中都设置一个id列作为其主键,设置为auto_increment,并且最好为INT类型。由于推荐是UNSIGNED INT，因为id值不可能为负值。即使你有一张user表，这张表有一个唯一的“username”字段，但是不要让他成为主键。VARCHAR字段作为主键是非常慢的。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能设置变得非常重要，比如，集群，分区……在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干别的表的主键构成。我们把这个情况就做“外键”。比如：有一个“学生表”，有学生ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”，其共同组成主键。 使用枚举ENUM而不是VARCHAR ENUM类型是非常快了紧凑的。在实际上，其保存的是TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“名族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR。MySQL也有一个建议(见第十条)告诉你怎么去重新组织你的表结构。当你有一个VARCHAR字段时，这个建议会告诉你把其改成ENUM类型。使用PROCEDURE ANALYSE()，你可以得到相关的建议。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程和进程的区别]]></title>
    <url>%2F2017%2F08%2F17%2FJava%2F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[这篇博客翻译自Oracle官方教程Processes and Threads 进程和线程 &#8195;&#8195;在并发编程中，这里有两个基本的执行单位：进程和线程。在JAVA编程语言中，并发编程主要关心线程。然后，进程也是同样重要的。&#8195;&#8195;即使在只有一个单一执行核心的计算机系统中，也有很多活动的进程和线程。因此，在任何给定的时刻，只有一个线程在实际执行。处理器的处理时间是通过操作系统的时间片在进程和线程中共享的。&#8195;&#8195;现在具有多处理器或者有多个执行内核的多处理器的计算机系统越来越普遍，这大大增加了系统并发执行的进程和线程的吞吐量—但是在没有多处理器或者多个执行内核的简单系统中，并发编程仍然是可能的。 进程 &#8195;&#8195;进程具有一个独立的执行环境。通常情况下，进程拥有一个完整的、私有的基本运行资源集合。特别的，每个进程都有自己的内存空间&#8195;&#8195;进程往往被看做是程序或应用的代名词，然而，用户看到的一个单独的应用程序实际上可能是一组相互协作的进程集合。为了便于进程间通信，大多数操作系统都支持进程间通信(IPC)，如pipes和sockets。IPC不仅支持在同一系统上通信，也支持不同的系统。JAVA虚拟机大多是单进程的。JAVA应用可以使用ProcessBuilder对象创建额外的进程，多进程应用超过了本课的范围。 线程 线程有时也称为轻量级的进程。进程和线程都提供一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。线程是在进程中存在的-每个进程最少有一个线程。线程共享进程的资源，包括内存和打开的文件。这样提高了效率，但潜在的问题就是线程之间的通信。多线程的执行时JAVA平台的一个基本特征。每个应用都至少有一个线程-或几个，算过算上“系统”线程的话，比如内存管理和信号处理。但是从程序员的角度来看，启动的只有一个线程，叫主线程。这个线程有能力创建额外的线程。 自己的总结 进程和线程的区别？1)线程的划分尺度小于进程，使得多线程程序的并发度高。2)进程是系统分配资源的独立单位，而线程只是进程中一个执行路径3)进程在切换时，耗费的资源较大，效率要差一些。对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口的区别]]></title>
    <url>%2F2017%2F08%2F14%2FJava%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.抽象类的概念 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义的抽象方法必须在具体的子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 2.接口的概念 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须都是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 3.两者的区别 (1)构造方法：抽象类可以有构造方法，接口中不能有构造方法(2)成员变量：抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的(3)成员方法：抽象类中可以包含非抽象的普通方法；接口中的方法必须都是抽象的，不能有非抽象的普通方法；抽象类中的抽象方法的访问类型可以是public，protected和默认类型(这时继承该抽象类的子类需要和该抽象类在同一包下面)，而接口中的抽象方法只能是public类型的，并且默认即为public abstract类型；抽象类中可以有静态方法，接口中不能包含静态方法。(4)设计理念：抽象类被继承体现的是“is a”的关系，抽象类中定义的是该继承体系的共性功能，接口被实现体现的是“like a”的关系，接口中定义的是该继承体系的扩展功能。 4.典型应用 模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断，记录日志访问和处理异常的代码，在各个子类中只是完成各自的业务逻辑，伪代码如下：123456789101112131415public abstract class BaseServlet extends HttpServlet&#123; public final void service(HttpServletRequest request,HttpServletResponse response) throws IOException,ServletException&#123; 记录访问日志 进行权限校验 if(具有权限) &#123; try&#123; doService(requset,response); &#125;catch&#123; 记录异常信息； &#125; &#125; &#125; protected abstract void doService(HttpRequset request,HttpResponse response) throws IOException,ServletException;&#125; 12345public class MyServlet extends BaseServlet &#123; protected void doService(HttpRequset request,HttpResponse response) throws IOException,ServletException)&#123; 本Servlet只处理的具体业务逻辑代码 &#125;&#125; 父类中的某段代码不确定，留给子类干，就用模板方法设计模式。]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java创建对象的5种方式]]></title>
    <url>%2F2017%2F08%2F14%2FJava%2FJava%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[做为一个Java开发者，我们每天都在创建对象。现在总结Java中创建对象的五种方式创建一个Java实体类Student作为测试使用1234567891011121314151617181920212223242526272829303132333435public class Student implements Cloneable,Serializable&#123; private static final long serialVersionUID = -6212470156629515269L; private String name; private int age; public Student()&#123; super(); &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Student s = null; s = (Student) super.clone(); return s; &#125;&#125; 1.通过new创建对象，这是最常见的创建对象的方式12345678public class Main00 &#123; public static void main(String[] args) &#123; Student s0 = new Student(); s0.setAge(10); s0.setName("houjinxiang"); System.out.println(s0.toString()); &#125;&#125; 2.运用反射，使用Class类的newInstance()方法创建对象123456789public class Main01 &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName("Student"); Student s1 = (Student) c.newInstance(); s1.setAge(10); s1.setName("houjinxiang"); System.out.println(s1.toString()); &#125;&#125; 3.运用反射，使用Constructor类下的方法创建对象12345678public class Main02 &#123; public static void main(String[] args) throws Exception&#123; Constructor c = Student.class.getConstructor(String.class,int.class); Student s2 = (Student) c.newInstance("houjinxiang",10); System.out.println(s2.toString()); &#125;&#125; 4.使用反序列化创建对象。注意：为了反序列化一个对象，我们需要让我们的类实现Serializable接口123456789101112131415public class Main03 &#123; public static void main(String[] args) &#123; Student s = new Student("houjinxiang", 10); try ( // 创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("student.dat")); // 创建反序列化对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("student.dat"));) &#123; oos.writeObject(s); Student s05 = (Student) ois.readObject(); System.out.println(s05.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意这里的try(){}catch(){}语法是JDK1.7的特性。try-with-resources这种声明方式指定了一个或多个资源，而且这些资源需要在程序结束的时候进行关闭。这种方式可以确保每个指定的资源都可以在声明结束的时候进行关闭（就是在try(){}结束的时候）。但是前提是这些资源必须实现接口java.lang.AutoCloseable（其中包括实现了java.io.Closeable接口的所有对象），原因是java.io.Closeable接口继承了java.lang.AutoCloseable接口。5.使用Clone的方法1234567891011public class Main04 &#123; public static void main(String[] args) &#123; Student s041 = new Student("houjinxiang", 10); try &#123; Student s041Clone = (Student) s041.clone(); System.out.println(s041Clone.toString()); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Cloneable是标记型接口，它内部都没有方法和属性，implements Cloneable表示该对象能被克隆，能使用Object.clone()方法。如果没有implements Cloneable的类调用Object.clone()方法就会抛出CloneNotSupportedException。在Student类下重写clone（）方法]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2017%2F08%2F08%2FJava%2FString%2F</url>
    <content type="text"><![CDATA[转载自深入Java字符串Java字符串类(java.lang.String)是Java中使用最多的类，也是最为特殊的一个类，很多时候，我们对它既熟悉又陌生。 从根本上认识java.lang.String类和String池 首先，我建议先看看String类的源码实现，这是从本质上认识String类的根本出发点。从中可以看到：1、String类是final的，不可被继承。public final class String。2、String类是的本质是字符数组char[], 并且其值不可改变。private final char value[];然后打开String类的API文档，可以发现：3、String类对象有个特殊的创建的方式，就是直接指定比如String x = “abc”，”abc”就表示一个字符串对象。而x是”abc”对象的地址，也叫做”abc”对象的引用。4、String对象可以通过“+”串联。串联后会生成新的字符串。也可以通过concat()来串联，这个后面会讲述。5、创建字符串的方式很多，归纳起来有三类：其一，使用new关键字创建字符串，比如String s1 = new String(“abc”);其二，直接指定。比如String s2 = “abc”;其三，使用串联生成新的字符串。比如String s3 = “ab” + “c”;6、Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。下面是个系统内存示意图： String对象的创建String对象的创建也很讲究，关键是要明白其原理。原理1：当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个X在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。另外，String的intern()方法是一个本地方法，定义为public native String intern(); intern()方法的价值在于让开发者能将注意力集中到String池上。当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。 认识trim()、intern()和concat()、“+”,认识空格、空串、null下面看个例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Created by IntelliJ IDEA.&lt;br&gt; * &lt;b&gt;User&lt;/b&gt;: leizhimin&lt;br&gt; * &lt;b&gt;Date&lt;/b&gt;: 2008-6-2 22:14:16&lt;br&gt; * &lt;b&gt;Note&lt;/b&gt;: Please add comment here! */ public class StringTest &#123; public static void main(String args[]) &#123; //在池中和堆中分别创建String对象"abc",s1指向堆中对象 String s1 = new String("abc"); //s2直接指向池中对象"abc" String s2 = "abc"; //在堆中新创建"abc"对象，s3指向该对象 String s3 = new String("abc"); //在池中创建对象"ab" 和 "c"，并且s4指向池中对象"abc" String s4 = "ab" + "c"; //c指向池中对象"c" String c = "c"; //在堆中创建新的对象"abc"，并且s5指向该对象 String s5 = "ab" + c; //concat会创建一个新的 String 对象返回 String s6 = "ab".concat("c"); String s7 = "ab".concat(c); System.out.println("------------实串-----------"); System.out.println(s1 == s2); //false System.out.println(s1 == s3); //false System.out.println(s2 == s3); //false System.out.println(s2 == s4); //true System.out.println(s2 == s5); //false System.out.println(s2 == s6); //false System.out.println(s2 == s7); //false String b1 = new String(""); String b2 = ""; String b3 = new String(""); String b4 = "".intern(); String b5 = "" + ""; String b6 = "".concat(""); String b7 = " ".trim(); String b8 = " "; String b9 = " ".trim(); System.out.println("------------空串-----------"); System.out.println(b1 == b2); //false System.out.println(b1 == b3); //false System.out.println(b2 == b3); //false System.out.println(b2 == b4); //true System.out.println(b2 == b5); //true* System.out.println(b2 == b6); //true* System.out.println(b2 == b7); //false* System.out.println("-----a----"); System.out.println(b2.equals(b7)); //true System.out.println(b7 == b8); //false System.out.println(b7 == b9); //false System.out.println(b7.equals(b9)); //true System.out.println(b9 == null);//false System.out.println("b8.trim():"); for (byte b : b8.getBytes()) &#123; System.out.print("&gt;&gt;&gt;" + (int) b + " "); &#125; System.out.println("\nb8.trim():"); for (byte b : b8.trim().getBytes()) &#123; System.out.print("&gt;&gt;&gt;" + (int) b + " "); &#125; System.out.println("\nb9.trim():"); for (byte b : b9.trim().getBytes()) &#123; System.out.print("&gt;&gt;&gt;" + (int) b + " "); &#125; &#125; &#125; String类里面intern()public String intern():返回字符串对象的规范化表示形式。一个初始时为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。所有字面值字符串和字符串赋值常量表达式都是内部的。返回：一个字符串，内容与此字符串相同，但它保证来自字符串池中。举例：尽管在输出中调用intern方法并没有什么效果，但是实际上后台这个方法会做一系列的动作和操作。在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。 String的常见用法字符串重编码 这个问题说来比较简单，转码就一行搞定，不信你看看，但究竟为什么要转码，是个很深奥的问题，看1234567891011121314151617181920212223242526272829/** * 字符串转码测试 * * @author leizhimin 2009-7-17 10:50:06 */public class TestEncoding &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; System.out.println("转码前，输出Java系统属性如下："); System.out.println("user.country:" + System.getProperty("user.country")); System.out.println("user.language:" + System.getProperty("user.language")); System.out.println("sun.jnu.encoding:" + System.getProperty("sun.jnu.encoding")); System.out.println("file.encoding:" + System.getProperty("file.encoding")); System.out.println("---------------"); String s = "熔岩博客"; String s1 = new String(s.getBytes(), "UTF-8"); String s2 = new String(s.getBytes("UTF-8"), "UTF-8"); String s3 = new String(s.getBytes("UTF-8")); String s4 = new String(s.getBytes("UTF-8"), "GBK"); String s5 = new String(s.getBytes("GBK")); String s6 = new String(s.getBytes("GBK"), "GBK"); System.out.println(s1); System.out.println(s2); System.out.println(s3); System.out.println(s4); System.out.println(s5); System.out.println(s6); &#125;&#125; 输出结果：123456789101112转码前，输出Java系统属性如下：user.country:CNuser.language:zhsun.jnu.encoding:GBKfile.encoding:GBK---------------???????熔岩博客鐔斿博鍗氬鐔斿博鍗氬熔岩博客熔岩博客 得出一结论：a、转一个码，又用该码来构建一个字符串，是绝对不会出现乱码的，—-你相当于没转。b、转码与否，与字符串本身编码有关，字符串本身的编码与谁有关？—-文件编码，或者你的IDE设置的编码有关。在此，我用的IDEA开发工具，默认是UTF-8编码，但操作系统使用的是GBK，但没有问题，我只要按照UTF-8来读取我的字符串就不会有乱码。但是文件已经是UTF-8了，你非要转为GBK，不乱才怪！那有什么办法呢？在Windows下，用记事本或者Editplus打开后另存为（并修改编码方式即可）。至于已经要从UFT-8转换为GBK，这就要靠内码转换工具了，是个比较复杂的问题，如果有谁想研究可以告诉我，一块研究研究。 字符比较不就是个匹配关系吗？String类的API有一些可以做比较，如果不行，可以寻求正则表达式来解决。 获取某个字符获取一个字符序列toCharArray() ，然后就随便玩去吧，中文就乱了。 字符串的截取substring() 字符串的替换与查找参看http://lavasoft.blog.51cto.com/blog/62575/179324 开始结束判断startsWith()/endWith() 字符串的排序比较compareTo(String anotherString) 按字典顺序比较两个字符串。123456789101112131415161718192021public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; //获取到两个字符串的较短的长度 int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; //如果两个字符的Unicode不相同，则直接返回 if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; // 如果前面的都相等，则返回两个字符串长度的差值 return len1 - len2; &#125; 但一直在想着compareTo可以用于实际中什么应用呢？？我这里例举使用compareTo进行简单 字符串的排序。（例如使用compareTo 进行姓名的排序）12345678910111213//需要进行排序的字符串 String[] array = new String[] &#123; "lilei", "libai", "james", "poly", "wobfei" &#125;; //使用简单的循环排序 for (int i = 0; i &lt; array.length - 1; i++) &#123; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[i].compareTo(array[j]) &gt; 0) &#123; String temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125; 使用上面针对String的排序以后，字符串的内容将会是：james libai lilei poly wobfei compareToIgnoreCase(String str) 不考虑大小写，按字典顺序比较两个字符串。 字符串的equals()和hashCode()注意：在比较一个字符串是否是空字符串的时候，使用””.equals(str);不要使用str.equals(“”);避免出现空指针异常已经实现了好了，直接调用，不用重写 字符串的类型转化太多了，String.valueOf()系列很多。类似的Long.parseLong(String s) 字符串的复制copyValueOf()123456public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125;public static String copyValueOf(char data[]) &#123; return new String(data); &#125; 大小写转换toLowerCase()toUpperCase() 正则匹配http://lavasoft.blog.51cto.com/blog/62575/179324]]></content>
      <categories>
        <category>Java语言学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Trapping Rain Water II]]></title>
    <url>%2F2017%2F08%2F08%2Fleetcode%2FTrapping-Rain-Water-II%2F</url>
    <content type="text"><![CDATA[Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining. Note:Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000. Example:12345678Given the following 3x6 height map:[ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1]]Return 4. The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.After the rain, water are trapped between the blocks. The total volume of water trapped is 4. 这道题是之前拿到Trapping Rain Water扩展而来的题，由2D变成了3D。与之前那道题不同，Trapping Rain Water在只需要比较左右的柱子高度即可，而现在则需要比较整个矩形的边。根据Trapping Rain Water知道，同样取边界最小的高度，所以很自然的想到优先级队列来保存周围的边界(小顶堆)。在我们访问过一个点以后继续往矩阵内部便利，这样还需要保存一个点的位置。为了防止访问过的点再次访问，还需要一个数组来标记这个点的访问状态。代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Solution &#123; /** * @Title: trapRainWater * @Description: 优先级队列去解决 * @param heightMap * @return * @return int * @throws */ public int trapRainWater(int[][] heightMap) &#123; int result = 0; if (heightMap == null || heightMap.length &lt; 3 || heightMap[0].length &lt; 3) &#123; return result; &#125; int row = heightMap.length; int column = heightMap[0].length; boolean[][] visit = new boolean[row][column]; int[] dx = &#123; -1, 0, 1, 0 &#125;; int[] dy = &#123; 0, 1, 0, -1 &#125;; Comparator&lt;Cell&gt; comparator = new Comparator&lt;Cell&gt;() &#123; @Override public int compare(Cell o1, Cell o2) &#123; if (o1.height &gt; o2.height) &#123; return 1; &#125; else if (o1.height &lt; o2.height) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;; Queue&lt;Cell&gt; queue = new PriorityQueue&lt;Cell&gt;(comparator); for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; column; j++) &#123; if (i == 0 || i == row - 1 || j == 0 || j == column - 1) &#123; if (!visit[i][j]) &#123; queue.add(new Cell(heightMap[i][j], i, j)); visit[i][j] = true; &#125; &#125; &#125; &#125; while (!queue.isEmpty()) &#123; Cell cell = queue.poll(); // 每次弹出的都是高度最小的柱子，这时候从该柱子出发，遍历其周边的四个方向的柱子，如果某个柱子未到达或超出边界且尚未被访问，则将该柱子加入堆中，如果该柱子的高度比当前柱子高度小，则更新该柱子的高度，同时记录此处所容纳的水，直至堆为空。 for (int i = 0; i &lt; 4; i++) &#123; int nextX = cell.x + dx[i]; int nextY = cell.y + dy[i]; if (nextX &lt; 0 || nextX &gt;= row || nextY &lt; 0 || nextY &gt;= column || visit[nextX][nextY]) &#123; continue; &#125; // 如果当前的柱子的高度比当前柱子的高度小,记录此刻可以容纳的水 if (heightMap[nextX][nextY] &lt; cell.height) &#123; result += cell.height - heightMap[nextX][nextY]; &#125; visit[nextX][nextY] = true; queue.add(new Cell(Math.max(heightMap[nextX][nextY], cell.height), nextX, nextY)); &#125; &#125; return result; &#125; public static void main(String[] args) &#123; int[][] heightMap = &#123; &#123; 12, 13, 1, 12 &#125;, &#123; 13, 4, 13, 12 &#125;, &#123; 13, 8, 10, 12 &#125;, &#123; 12, 13, 12, 12 &#125;, &#123; 13, 13, 13, 13 &#125; &#125;; Solution s = new Solution(); System.out.println(s.trapRainWater(heightMap)); &#125;&#125;class Cell &#123; public int height; public int x; public int y; public Cell(int height, int x, int y) &#123; super(); this.height = height; this.x = x; this.y = y; &#125;&#125;]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <url>%2F2017%2F08%2F08%2Fleetcode%2FTrapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[Trapping Rain WaterGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 分析：leftMaxHeight:表示当前柱子左面柱子的最高高度rightMaxHeight:表示当前柱子右面柱子的最高高度则当前柱子能够容纳的水与height[i]与leftMaxHeight和rightMaxHeight有关。代码如下:12345678910111213141516171819202122public class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length &lt; 3) &#123; return 0; &#125; int result = 0; // 获取左右挡板的最大高度 int[] left = new int[height.length]; int[] right = new int[height.length]; left[0] = height[0]; right[height.length - 1] = height[height.length - 1]; for (int i = 1; i &lt; height.length; i++) &#123; left[i] = Math.max(left[i - 1], height[i]); right[height.length - i - 1] = Math.max(right[height.length - i], height[height.length - i - 1]); &#125; // 再次遍历height[]，取它左右最大高度的最小值，减去height[i]，就是它的积水量。累加所有挡板的积水量。 for (int i = 1; i &lt; height.length - 1; i++) &#123; result += Math.min(left[i], right[i]) - height[i]; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[适配器模式(Adapter)]]></title>
    <url>%2F2017%2F08%2F08%2Fdesignpattern%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近实习过程中，参与开发了一个基于C/S软件的第五版本。开发过程中涉及到了Java Swing相关的知识。发现在Java Swing那边，随处可见都有适配器模式的体现，如WindowAdapter,MouseAdapter等，它们分别都实现了WindowAdapter、MouseAdapter等接口，这些都是类适配器的实例 1.适配器模式在JDK中的实例MouseLinster.java如下所示，应用接口充斥着很多的方法，这些方法在Swing开发中很常用，编程者如果要直接使用这个接口，则必须要实现所有方法。而编程者只使用该接口里面的几个方法，从而出现为了使用某一个方法，而不得不实现该接口里面的所有方法，这样代码中将会有很多空实现的方法。12345678910111213141516171819202122232425262728public interface MouseListener extends EventListener &#123; /** * Invoked when the mouse button has been clicked (pressed * and released) on a component. */ public void mouseClicked(MouseEvent e); /** * Invoked when a mouse button has been pressed on a component. */ public void mousePressed(MouseEvent e); /** * Invoked when a mouse button has been released on a component. */ public void mouseReleased(MouseEvent e); /** * Invoked when the mouse enters a component. */ public void mouseEntered(MouseEvent e); /** * Invoked when the mouse exits a component. */ public void mouseExited(MouseEvent e);&#125; MouseAdapter.java，此抽象类实现了各种鼠标监听器接口，编程实现这些接口时如果直接实现接口，必须实现所有的方法，而如果继承这个类的话，只需要实现需要实现的方法即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class MouseAdapter implements MouseListener, MouseWheelListener, MouseMotionListener &#123; /** * &#123;@inheritDoc&#125; */ public void mouseClicked(MouseEvent e) &#123;&#125; /** * &#123;@inheritDoc&#125; */ public void mousePressed(MouseEvent e) &#123;&#125; /** * &#123;@inheritDoc&#125; */ public void mouseReleased(MouseEvent e) &#123;&#125; /** * &#123;@inheritDoc&#125; */ public void mouseEntered(MouseEvent e) &#123;&#125; /** * &#123;@inheritDoc&#125; */ public void mouseExited(MouseEvent e) &#123;&#125; /** * &#123;@inheritDoc&#125; * @since 1.6 */ public void mouseWheelMoved(MouseWheelEvent e)&#123;&#125; /** * &#123;@inheritDoc&#125; * @since 1.6 */ public void mouseDragged(MouseEvent e)&#123;&#125; /** * &#123;@inheritDoc&#125; * @since 1.6 */ public void mouseMoved(MouseEvent e)&#123;&#125;&#125; 例子：123456botton.addMouseListener(new MouseAdapter()&#123; @override public void mouseMoved(MouseEvent e)&#123; System.out.println("鼠标移动了"); &#125;&#125;)]]></content>
      <categories>
        <category>JAVA设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[InvertBinaryTree]]></title>
    <url>%2F2017%2F05%2F13%2Fleetcode%2FInvertBinaryTree%2F</url>
    <content type="text"><![CDATA[翻转二叉树的非递归实现1234567891011121314151617181920212223242526/** * @Title: invertBinaryTree2 * @Description: 翻转二叉树的非递归解法，用栈来模拟 * @param root * @return void * @throws */public static void invertBinaryTree2(TreeNode root) &#123; if (root == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.empty()) &#123; TreeNode current = stack.pop(); TreeNode temp = current.left; current.left = current.right; current.right = temp; if(current.left != null)&#123; stack.push(current.left); &#125; if(current.right != null)&#123; stack.push(current.right); &#125; &#125;&#125;]]></content>
      <categories>
        <category>lintcode解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式(Singleton)]]></title>
    <url>%2F2017%2F05%2F13%2Fdesignpattern%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&#8195;&#8195;能保证线程安全的方法是《Effective Java》一书中给出的一种精妙的解决方法，它充分利用了Java虚拟机的特性。因为在多线程的环境下，JVM会对一个类的初始化去做一些限制，同一时间只允许一个线程去初始化一个类，这样就从虚拟机层面避免了大部分单例实现的问题。 1234567891011121314public class SingletonLazyloadSynSafe &#123; // 私有化构造方法 private SingletonLazyloadSynSafe()&#123; &#125; // 内部类 private static class SingletonHolder&#123; // 静态初始化器,由JVM来保证线程的安全性 private static final SingletonLazyloadSynSafe sigleton = new SingletonLazyloadSynSafe(); &#125; // 公有的静态获取实例的方法 public static SingletonLazyloadSynSafe getInstace()&#123; return SingletonHolder.sigleton; &#125;&#125; double check的方法实现单例模式 关于单例，线程安全，延迟加载，序列化与反序列化，反射安全是很重要的。]]></content>
      <categories>
        <category>JAVA设计模式</category>
      </categories>
  </entry>
</search>
